bot = []
var g4studentNames = {
    di: 'Diana Huang',
    sj: 'Shujing',
    aus: 'Austin',
    ande: 'Anderson',
    ale: 'Alexander',
    mr: 'Mingrui',
    //mingming1: 'Ming-Ming',
    bon: 'Bonnie',
    //bonbon: 'Bon-Bon',
    bo: 'Bonnie',
    b: 'Bonnie',
    austin: 'Austin',
    st: 'Stephen',
    stev: 'Stephen',
    ste: 'Stephen',
    fe: 'Felix',
    felix: 'Felix',
    fel: 'Felix',
    steph: 'Stephanie',
    stg: 'Stephanie',
    jay: 'Jayden',
    ivy: 'Ivy',
    vin: 'Vincent',
    alex: 'Alex',
    jeff: 'Jeff',
    san: 'Sandy',
    sa: 'Sandy',
    iv: 'Ivy',
}
let linebreakRE = /^----+/m
function magicSquare(n) {
    function outputSquare(n) {
        var i, j
        var w = n * n // largest integer in square
        var x = w.toString(10)
        var width = x.length + 2 // width of display

        let out = []
        for (i = 0; i < n; i++) {
            let store = []
            for (j = 0; j < n; j++) {
                store.push(
                    Cells[i][j]
                )
            }
            out.push(store)
        }
        return out
    }


    var g_LastVal = 0

    function calculate(n = 3) {
        var i
        var ssize = parseInt(n)
        var firstNumber = parseInt(form1.txt_firstNumber.value, 10)
        var gammaIncrement = parseInt(form1.txt_gammaInc.value, 10)
        var plus2Increment = parseInt(form1.txt_plus2Inc.value, 10)
        var pureSum = (ssize * (ssize * ssize + 1)) / 2
        form1.txt_pureSum.value = pureSum



        var firstNumTotal = ssize * (firstNumber - 1)
        form1.txt_firstNumTotal.value = firstNumTotal



        var cTotal = (ssize * (ssize + 1)) / 2
        form1.txt_CT.value = cTotal



        var gammaIncTotal =
            (cTotal - ssize) * (ssize * (gammaIncrement - 1))
        var plus2IncTotal = (cTotal - ssize) * (plus2Increment - 1)
        var setTotal = 0
        if (ssize % 2 != 0) {
            setTotal = 0
        } else if (ssize % 4 == 0) {
            setTotal = 0
        } else {
            setTotal =
                ((ssize * ssize) / 2) *
                (plus2Increment - gammaIncrement)
        }

        var calcMagicSum =
            pureSum +
            firstNumTotal +
            gammaIncTotal +
            plus2IncTotal +
            setTotal

        Cells = new Array(ssize)
        for (i = 0; i < ssize; i++) {
            Cells[i] = new Array(ssize)
            for (j = 0; j < ssize; j++) {
                Cells[i][j] = parseInt('0')
            }
        }


        var stype
        if (ssize % 2 != 0) {
            stype = ' Odd Magic Square'

            OddMagicSquare(
                0,
                0,
                ssize,
                firstNumber,
                gammaIncrement,
                plus2Increment,
                Cells
            )
        } else if (ssize % 4 == 0) {
            stype = ' Doubly Even Magic Square'

            DoublyEvenMagicSquare(
                0,
                0,
                ssize,
                firstNumber,
                gammaIncrement,
                plus2Increment,
                Cells
            )
        } else {
            stype = ' Singly Even Magic Square'

            SinglyEvenMagicSquare(
                0,
                0,
                ssize,
                firstNumber,
                gammaIncrement,
                plus2Increment,
                Cells
            )
        }

        var sum = GetActualSums(0, 0, ssize, Cells)

        if (calcMagicSum != sum) {
            msg =
                'Error: Calculated Sum = ' +
                calcMagicSum +
                ', Actual Sum = ' +
                sum
            window.alert(msg)
            return
        }


        if (sum == 0) {
            msg = 'Error: Sum = 0'
            window.alert(msg)
            return
        }




        msg =
            ssize +
            'x' +
            ssize +
            stype +
            ', Magic Sum = ' +
            sum +
            '\r\n'
        console.log(msg)
        return outputSquare(ssize)
    }

    function OddMagicSquare(
        startRow,
        startCol,
        size,
        firstNum,
        gammaInc,
        plus2Inc,
        Cells
    ) {



        var rowCenter, colCenter, curRow, curCol, endRow, endCol
        var count, counter, setValue, contents, loopCount, loopLimit
        var step_flag = new Boolean(false)

        endRow = startRow + size - 1
        endCol = startCol + size - 1


        count = size * size


        var numCellsEmpty = count


        count = count * gammaInc


        count = count + firstNum - 1


        rowCenter = Math.floor(size / 2)
        colCenter = Math.floor(size / 2) + 1


        rowCenter = startRow + rowCenter
        colCenter = startCol + colCenter

        curRow = rowCenter
        curCol = colCenter


        setValue = 0
        step_flag = false


        loopCount = 0
        loopLimit = count * 2


        for (
            counter = firstNum;
            counter < count + firstNum;
            counter += gammaInc
        ) {
            loopCount++




            if (loopCount > loopLimit) {
                msg =
                    'Loop Error: loopcount = ' +
                    loopCount +
                    ', loopLimit = ' +
                    loopLimit
                window.alert(msg)
                return
            }

            if (curRow > endRow) curRow = startRow
            if (curRow < startRow) curRow = endRow
            if (curCol > endCol) curCol = startCol
            if (curCol < startCol) curCol = endCol

            contents = Cells[curRow][curCol]

            if (contents == 0) {
                if (step_flag) {
                    step_flag = false
                    setValue = setValue + plus2Inc
                } else {
                    setValue = setValue + gammaInc
                }


                if (loopCount == 1) {
                    setValue = firstNum
                }

                Cells[curRow][curCol] = setValue
                curRow--
                curCol++

                numCellsEmpty--
                if (numCellsEmpty == 0) {
                    break
                }
            } else {

                curRow++


                curCol++


                counter = counter - gammaInc
                step_flag = true
            }


        }

        g_LastVal = setValue
    }

    function DoublyEvenMagicSquare(
        startRow,
        startCol,
        size,
        firstNum,
        gammaInc,
        plus2Inc,
        Cells
    ) {



        var temp, rowtype, coltype, row, col



        /*
         *  first pass left to right starting at 1
         *  +---+---+---+---+
         *  | 1 |   |   | 4 |  rowtype 0
         *  +---+---+---+---+
         *  |   | 6 | 7 |   |  rowtype 1
         *  +---+---+---+---+
         *  |   | 10| 11|   |  rowtype 2
         *  +---+---+---+---+
         *  | 13|   |   | 16|  rowtype 3
         *  +---+---+---+---+
         *
         *  second pass starting at the last cell and filling in the blanks
         *  +---+---+---+---+
         *  | 1 | 15| 14| 4 |
         *  +---+---+---+---+
         *  | 12| 6 | 7 | 9 |
         *  +---+---+---+---+
         *  | 8 | 10| 11| 5 |
         *  +---+---+---+---+
         *  | 13| 3 | 2 | 16|
         *  +---+---+---+---+
         */

        temp = firstNum

        for (row = 0; row < size; row++) {
            rowtype = row % 4

            for (col = 0; col < size; col++) {
                if (row == 0 && col == 0) {
                    temp = firstNum
                } else if (col == 0) {
                    temp += plus2Inc
                } else {
                    temp += gammaInc
                }
                coltype = col % 4

                switch (rowtype) {
                    case 0:
                    case 3:
                        switch (coltype) {
                            case 0:
                            case 3:
                                Cells[startRow + row][
                                    startCol + col
                                ] = temp
                        }
                        continue

                    case 1:
                    case 2:
                        switch (coltype) {
                            case 1:
                            case 2:
                                Cells[startRow + row][
                                    startCol + col
                                ] = temp
                        }
                        continue
                }
            }
        }



        temp = firstNum

        for (row = size - 1; row >= 0; row--) {
            for (col = size - 1; col >= 0; col--) {
                if (row == size - 1 && col == size - 1) {
                    temp = firstNum
                } else if (col == size - 1) {
                    temp += plus2Inc
                } else {
                    temp += gammaInc
                }
                coltype = col % 4

                if (Cells[startRow + row][startCol + col] == 0) {
                    Cells[startRow + row][startCol + col] = temp
                }
            }
        }

    }

    function SinglyEvenMagicSquare(
        startRow,
        startCol,
        size,
        firstNum,
        gammaInc,
        plus2Inc,
        arr
    ) {
        {
            Cells = arr

            var size1,
                offset,
                rowA,
                colA,
                rowB,
                colB,
                rowC,
                colC,
                rowD,
                colD
            var temp, t1, tempSize, tempStart, tempEnd

            /*
        we need to create 4 odd squares from the even square and place as follows
         +-----+-----+
         |  A  |  C  |
         +-----+-----+
         |  D  |  B  |
         +-----+-----+
        */

            size1 = size / 2
            offset = 0

            rowA = startRow
            colA = startCol


            msg2 =
                ', gammaInc = ' +
                gammaInc +
                ', plus2Inc = ' +
                plus2Inc

            var newStartVal = firstNum


            new OddMagicSquare(
                rowA,
                colA,
                size1,
                firstNum,
                gammaInc,
                plus2Inc,
                Cells
            )
            msg =
                'g_LastVal = ' +
                g_LastVal +
                ', newStartVal = ' +
                newStartVal




            var squareOffset = g_LastVal - firstNum + plus2Inc


            rowB = startRow + size1 + offset
            colB = startCol + size1 + offset

            msg1 = 'squareOffset = ' + squareOffset
            CopyWithOffset(
                rowA,
                colA,
                size1,
                rowB,
                colB,
                squareOffset
            )









            rowC = startRow
            colC = startCol + size1 + offset

            CopyWithOffset(
                rowB,
                colB,
                size1,
                rowC,
                colC,
                squareOffset
            )









            rowD = startRow + size1 + offset
            colD = startCol

            CopyWithOffset(
                rowC,
                colC,
                size1,
                rowD,
                colD,
                squareOffset
            )












            SwapLeftCells(rowA, rowD, startCol, size1)




            tempSize = 0
            for (t1 = 4; t1 < size1; t1 += 2) {
                tempSize++
            }

            tempStart = 0 // the first column
            tempEnd = size // the last column + 1

            for (temp = 0; temp < tempSize; temp++) {
                tempStart++
                tempEnd--

                SwapAllCells(rowA, rowD, tempStart, size1)





                SwapAllCells(rowA, rowB, tempEnd, size1)




            }

            tempStart = startCol + temp + 1


            SwapCenterCell(rowA, rowD, tempStart, size1)




        }
    }

    function SwapLeftCells(row1, row2, col, size) {

        var count, r1, r2
        var number_cells, temp1, temp2


        number_cells = Math.floor(size / 2)


        for (count = 0; count < number_cells; count++) {
            r1 = row1 + count
            r2 = row2 + count


            temp1 = Cells[r1][col]
            temp2 = Cells[r2][col]

            Cells[r1][col] = temp2
            Cells[r2][col] = temp1


            r1 = row1 + size - 1 - count
            r2 = row2 + size - 1 - count

            temp1 = Cells[r1][col]
            temp2 = Cells[r2][col]

            Cells[r1][col] = temp2
            Cells[r2][col] = temp1
        }
    }

    function SwapAllCells(row1, row2, col, size) {

        var count, r1, r2
        var temp1, temp2


        for (count = 0; count < size; count++) {
            r1 = row1 + count
            r2 = row2 + count

            temp1 = Cells[r1][col]
            temp2 = Cells[r2][col]

            Cells[r1][col] = temp2
            Cells[r2][col] = temp1
        }
    }

    function SwapCenterCell(row1, row2, col, size) {

        var r1, r2
        var temp1, temp2, temp3


        temp3 = Math.floor(size / 2)

        r1 = row1 + temp3
        r2 = row2 + temp3


        temp1 = Cells[r1][col]
        temp2 = Cells[r2][col]

        Cells[r1][col] = temp2
        Cells[r2][col] = temp1
    }

    function CopyWithOffset(row1, col1, size, row2, col2, offset) {
        var i = 0,
            j = 0
        var temp = 0

        for (i = 0; i < size; i++) {
            for (j = 0; j < size; j++) {
                temp = Cells[row1 + i][col1 + j] + offset
                Cells[row2 + i][col2 + j] = temp
            }
        }
    }

    function GetActualSums(startRow, startCol, size, Cells) {
        var sum = 0,
            temp = 0,
            i = 0,
            j = 0




        for (j = startCol; j < size; j++) {
            temp = 0
            for (i = startRow; i < size; i++) {
                temp += Cells[i][j]
            }

            if (sum == 0) {

                sum = temp
            }




            if (sum != temp) {
                msg =
                    'GetActualSums: Error: Column = ' +
                    j +
                    ', Magic Sum = ' +
                    sum +
                    ', Actual = ' +
                    temp
                window.alert(msg)
                return 0
            }
        }


        for (i = startRow; i < size; i++) {
            temp = 0
            for (j = startCol; j < size; j++) {
                temp += Cells[i][j]
            }




            if (sum != temp) {


                return 0
            }
        }


        temp = 0
        for (i = startRow, j = startCol; i < size; i++, j++) {
            temp += Cells[i][j]
        }

        if (sum != temp) {
            msg =
                'Error: LL-TR Diagonal Magic Sum = ' +
                sum +
                ', Actual = ' +
                temp
            window.alert(msg)
            return 0
        }


        temp = 0
        for (
            i = startRow, j = startCol + size - 1;
            i < size;
            i++, j--
        ) {
            temp += Cells[i][j]
        }

        if (sum != temp) {
            msg =
                'Error: LR-TL Diagonal Magic Sum = ' +
                sum +
                ', Actual = ' +
                temp
            window.alert(msg)
            return 0
        }
        return sum
    }





    window = {
        open(s) {
            return window
        },
        document: {
            open(s) {
                console.log(s)
            },
            write(s) {
                console.log(s)
            },

            writeln(s) {
                console.log(s)
            },
        }
    }
    function resetValues(form1) {
        let keys = resetValues.toString().match(/txt_\w.*?(?=\.value)/g)
        for (let key of keys) {
            form1[key] = {}
        }
        form1.txt_ssize.value = 3
        form1.txt_firstNumber.value = 1
        form1.txt_gammaInc.value = 1
        form1.txt_plus2Inc.value = 1
        form1.txt_pureSum.value = 0
        form1.txt_firstNumTotal.value = 0
        form1.txt_CT.value = 0
        form1.txt_GIT.value = 0
        form1.txt_PIT.value = 0
        form1.txt_SET.value = 0
        form1.txt_calcMagicSum.value = 0
    }
    form1 = {}
    resetValues(form1)
    return calculate(n)
}
let pprint = console.log
let circleBullet = '•'
let plusSign = '+'
let multiplySign = '×'
const amazonSlideData = [
  {
    url:"https://s3-us-west-2.amazonaws.com/s.cdpn.io/123941/waterfall-free-stock-photo-244915.jpg",
    backgroundColor:"green"
  },
  {
    url:"https://s3-us-west-2.amazonaws.com/s.cdpn.io/123941/free-stock-photos-1.jpg",
    backgroundColor:"orange"
  },
  {
    url: "https://s3-us-west-2.amazonaws.com/s.cdpn.io/123941/snowy-winter-vignette-bokeh-night-snow-falling-free-stock-photo.jpg",
    backgroundColor: "red"
  }

]
let MATH = {}
MATH.operators = {}
MATH.operators.easy = ['+', '-', '*']
MATH.operators.medium = ['+', '-', '*', '/']
MATH.operators.hard = ['+', '-', '*', '/', 'mod']

nestobj  = {a:1, b:2, c:3, d: {da:1, db:2, dc:3}}
let clipfile = '/home/kdog3682/CWF/public/clip.js'
let appscriptfile = '/home/kdog3682/CWF/public/app2.js'
let appscripturl = 'https://script.google.com/macros/s/AKfycbx3VFYdpdvIOMu6g5WFs4965dcYf7rTfF3YKDZ-Hr-KmUVut9My7qcOeqpeSJuMGbY3/exec'
//console.log(katexMixed('what is $x^2 + 3?')); throw '';
let period = '. '

const proseWords = [
    'mr',
    'mrs',
    'dr',
    'in',
    'of',
    'to',
    'is',
    'it',
    'on',
    'no',
    'us',
    'at',
    'go',
    'an',
    'my',
    'up',
    'me',
    'as',
    'he',
    'we',
    'so',
    'be',
    'by',
    'or',
    'do',
    'if',
    'hi',
]
const threeLetterWords = [
    'ago',
    'all',
    'any',
    'bad',
    'big',
    'few',
    'hot',
    'how',
    'mad',
    'new',
    'now',
    'old',
    'one',
    'red',
    'sad',
    'six',
    'ten',
    'two',
    'and',
    'but',
    'for',
    'nor',
    'off',
    'the',
    'yet',
    'air',
    'ant',
    'bed',
    'boy',
    'can',
    'car',
    'cat',
    'dad',
    'day',
    'dew',
    'dog',
    'elf',
    'elk',
    'gym',
    'ink',
    'jet',
    'key',
    'log',
    'man',
    'mom',
    'one',
    'pal',
    'rug',
    'saw',
    'son',
    'sun',
    'urn',
    'vet',
    'way',
    'yap',
    'zag',
    'zen',
    'zoo',
    'her',
    'him',
    'his',
    'our',
    'she',
    'you',
    'ace',
    'add',
    'act',
    'aid',
    'ail',
    'are',
    'ask',
    'ate',
    'bar',
    'dig',
    'eat',
    'get',
    'has',
    'let',
    'met',
    'nap',
    'out',
    'put',
    'run',
    'sat',
    'say',
    'see',
    'tan',
    'use',
    'was',
    'wed',
    'zap',
]

function display(s) {
    const Reset = '\x1b[0m'
    const Bright = '\x1b[1m'
    const Red = '\x1b[31m'
    const [name, lineNumber] = getStackInfo()
    const message = name + ': ' + lineNumber
    original(Bright + Red + message, Reset, s.name || s)
}
function getStackInfo(e) {
    // DONT WRITE CONSOLE.LOG
    const stack = getStackTrace(e)
    //original(stack)
    //throw ''
    const ignore = ['reduce', 'filter']
    for (let i = stack.length - 1; i >= 0; i--) {
        let now = stack[i]
        let next = stack[i + 1]
        let name = now[0]
        //original(name)
        switch (name) {
            //case 'args.map':
            case 'display':
            case 'lambdaDisplay':
            case 'proxyAssertion':
            case 'Console.display':
            case 'console.display':
                return next

            case '<anonymous>':
                if (stack[i - 1][0] == 'Console.display')
                    return ['global', stack[i][1]]
        }
    }
    return stack[0]
}
const getShortest = getShortestLongest('shortest')
//const getLongest = getShortestLongest('longest')

//function getLongest(a) {
//const lengths = a.map(partial(len))
//console.log({lengths}); throw ""
//}
//console.log(longestDecimal('1. 1.')); throw '';
linebreak =
    '------------------------------------------------------------------'
xobj = { a: '2/3', b: 4, c: 7, d: 8, e: 33, g: 123, f: 10 }
const moneyUnitRef = {
    nickels: 20,
    quarters: 4,
    pennies: 100,
    dimes: 10,
}

const increaseDecreaseRef = {
    percentIncrease: ['percent decrease', 'percent increase'],
    quantity: ['more', 'less'],
    older: ['older', 'younger'],
    age: ['younger', 'older'],
    older: ['younger', 'older'],
    delta: ['decreases', 'increases'],
    larger: ['larger', 'smaller'],
    size: ['larger', 'smaller'],
    smaller: ['larger', 'smaller'],
}
function rpw(...args) {
    return require('./node-utils.js').rpw(...args)
}

function json(a) {
    require('./node-utils.js').json(a)
}

function write(a, b) {
    return require('./node-utils.js').write(a, b)
}

function append(a, b) {
    return require('./node-utils.js').append(a, b)
}

function read(s) {
    return require('./node-utils.js').read(s)
}

function ofile(s) {
    return require('./node-utils.js').ofile(s)
}

function clip(s, m = 1) {
    if (arguments.length == 0) return read('clip.js')
    if (!s) return 
    require('./node-utils.js').clip(s, m)
}
const asciiLetters = [
    '        \n   ##   \n  #  #  \n #    # \n ###### \n #    # \n #    # \n        ',
    '        \n #####  \n #    # \n #####  \n #    # \n #    # \n #####  \n        ',
    '        \n  ####  \n #    # \n #      \n #      \n #    # \n  ####  \n        ',
    '        \n #####  \n #    # \n #    # \n #    # \n #    # \n #####  \n        ',
    '        \n ###### \n #      \n #####  \n #      \n #      \n ###### \n        ',
    '        \n ###### \n #      \n #####  \n #      \n #      \n #      \n        ',
    '        \n  ####  \n #    # \n #      \n #  ### \n #    # \n  ####  \n        ',
    '        \n #    # \n #    # \n ###### \n #    # \n #    # \n #    # \n        ',
    '   \n # \n # \n # \n # \n # \n # \n   ',
    '        \n      # \n      # \n      # \n      # \n #    # \n  ####  \n        ',
    '        \n #    # \n #   #  \n ####   \n #  #   \n #   #  \n #    # \n        ',
    '        \n #      \n #      \n #      \n #      \n #      \n ###### \n        ',
    '        \n #    # \n ##  ## \n # ## # \n #    # \n #    # \n #    # \n        ',
    '        \n #    # \n ##   # \n # #  # \n #  # # \n #   ## \n #    # \n        ',
    '        \n  ####  \n #    # \n #    # \n #    # \n #    # \n  ####  \n        ',
    '        \n #####  \n #    # \n #    # \n #####  \n #      \n #      \n        ',
    '        \n  ####  \n #    # \n #    # \n #  # # \n #   #  \n  ### # \n        ',
    '        \n #####  \n #    # \n #    # \n #####  \n #   #  \n #    # \n        ',
    '        \n  ####  \n #      \n  ####  \n      # \n #    # \n  ####  \n        ',
    '       \n ##### \n   #   \n   #   \n   #   \n   #   \n   #   \n       ',
    '        \n #    # \n #    # \n #    # \n #    # \n #    # \n  ####  \n        ',
    '        \n #    # \n #    # \n #    # \n #    # \n  #  #  \n   ##   \n        ',
    '        \n #    # \n #    # \n #    # \n # ## # \n ##  ## \n #    # \n        ',
    '        \n #    # \n  #  #  \n   ##   \n   ##   \n  #  #  \n #    # \n        ',
    '       \n #   # \n  # #  \n   #   \n   #   \n   #   \n   #   \n       ',
    '        \n ###### \n     #  \n    #   \n   #    \n  #     \n ###### \n        ',
]
var bindingNameRE =
    /^(?:var|const|class|(?:async )?function(?:\*|!)?) (\w+)/gm
var functionNameRE =
    /^(?:def|(?:async )?function(?:\\*|!)?) (\w+)/gm

abclist = ['a', 'b', 'c', 'd', 'e']
const questionWords = [
    'istaw',
    'would',
    'are',
    'can',
    'for',
    'will',
    'which',
    'whose',
    'shud',
    'who',
    'what',
    'where',
    'when',
    'why',
    'how',
    'should',
    'could',
    'do',
    'is',
    'have',
    'has',
    'does',
    'are',
    'might',
    'would',
    'can',
    'for',
    'will',
    'which',
    'whose',
    'shud',
    'who',
    'what',
    'where',
    'when',
    'why',
    'how',
    'should',
    'could',
    'do',
    'is',
    'have',
    'has',
    'does',
    'are',
    'might',
]
const babyNames = [
    'liam',
    'noah',
    'ben',
    'oliver',
    'james',
    'william',
    'lucas',
    'sophia',
    'isabella',
    'ava',
    'amelia',
    'charlotte',
    'emma',
    'olivia',
    'mia',
    'evelyn',
    'theo',
    'henry',
    'kaylee',
    'michelle',
    'isabelle',
    'michael',
]
var templaterRE = /\$(\w+(?:-\w+)*)/g
var comparisonRE = '\\b(?:(?:more|less) than|of)\\b'
var equalRE = / *= */
let eLastValue
onlyWordCommaRE = / *, *(?=\w)/
var commaRE = / *, *(?=\w)/
let quoteRE = /^(?:".*?"|'.*?')/
original = console.log
const consoleColors = {
    Reset: '\x1b[0m',
    Bright: '\x1b[1m',
    Green: '\x1b[32m',
    Blue: '\x1b[34m',
    Red: '\x1b[31m',
}
function blank() {
    return '$input'
}

const seasons = ['autumn', 'winter', 'spring', 'summer']
const nestedobj = {
    a: 1,
    b: 2,
    c: { a: 1, b: 22, D: { a: 1, b: 2, ccc: 33 } },
}
const aobj = { a: 1, b: 2, c: 3 }
const bobj = { aa: 1, bb: 2, cc: 3 }
const DAYS = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
]
const MONTHS = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
]
const TABINPUT = '\n\t$c\n'
const HTMLTAGS = [
    'p',
    'div',
    'a',
    'section',
    'main',
    'img',
    'svg',
]
const AGAIN = 'again'
const SKIP = 'skip'
const NEXT_LEVEL = 'nextlevel'
const INCORRECT = 'incorrect'
const CONTINUE = 'CONTINUE'
const DONE = 'DONE'
const CORRECT = 'CORRECT'
const IN_PROGRESS = 'IN_PROGRESS'
const NEXT = 'NEXT'
const STOP = 'STOP'
const z = 'z'
const SUCCESS = 'SUCCESS'

const LEADER_KEY = ';'
boop = 'BOOP'
a = 'a'
b = 'b'
alist = ['a', 'b', 'c', 'd', 'e']
const nativeConstructors = [
    'Array',
    'Function',
    'Object',
    'Promise',
    'String',
    'Number',
    'Null',
    'Undefined',
    'RegExp',
]

function isReferenceError(e) {
    return e.constructor.name == 'ReferenceError'
}

function isSyntaxError(e) {
    return e.constructor.name == 'SyntaxError'
}
function blue(s, key = 'blue') {
    const reset = '\x1b[0m'
    const bright = '\x1b[1m'
    const green = '\x1b[32m'
    const blue = '\x1b[34m'
    const red = '\x1b[31m'
    const dict = {
        green,
        blue,
        red,
    }
    if (!dict.hasOwnProperty(key)) {
        s += ': ' + key
        key = 'blue'
    }
    return console.log(bright + dict[key] + s + reset)
}
function dogLogFactory() {
    const Reset = '\x1b[0m'
    const Bright = '\x1b[1m'
    const Red = '\x1b[31m'
    const Green = '\x1b[32m'
    const Blue = '\x1b[34m'

    function info() {
        const [name, lineNumber] = getStackInfo()
        return name + ': ' + lineNumber
    }

    let count = 1

    return function lambdaDisplay(...args) {
        let message = `   [count ${count++}]`
        original(
            Bright + Red + info() + Blue + message + Reset,
            ...args
        )
    }
}

const WordToNumberDictionary = {
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90,
    hundred: 100,
    thousand: 1000,
    oneThousand: 1000,
    nineThousand: 9000,
    million: 1000000,
    billion: 1000000000,
    trillion: 1000000000000,
}

function trace(fn) {
    return function lambda(...args) {
        try {
            return fn(...args)
        } catch (e) {
            console.log({ e, args })
            throw 'trace error'
        }
    }
}
function getFunctionInfo(s) {
    s = s.toString().trim()
    let type = getFirstWord(s)
    let parameters
    let properties
    let returnValues

    let name = getFunctionName(s)
    if (!name) return
    if (test(/^[A-Z]\w*?Component$/, name)) type = 'component'

    switch (type) {
        case 'component':
        case 'function':
        case 'class':
            break
        case 'var':
        case 'const':
            type = 'variable'
            break
        case 'async':
            type = 'function'
            break
        case 'if':
        case 'for':
        case 'while':
        case 'let':
            return
        default:
            return
    }

    if (type == 'function') {
        parameters = getParameters(s)
        returnValues = findall(/return (\w+) *$/gm, s)
    }

    if (type == 'class') {
        properties = getClassPropertiesFromString(s)
    }

    return {
        body: s,
        name,
        type,
        properties: properties,
        parameters,
        returnValues,
    }
}
var dog = display
var pairlog = display

if (typeof window !== 'undefined') {
    module = {}
    module.exports = {}
    require = () => ({})
}
console.blue = blue
function noop() {
    return
}
function isUrl(s) {
    return s.startsWith('http')
}

function getNumber(s) {
    return toNumber(match(/-?\d+(?:\.\d+)?%?/, s))
}

function getNumbersAndVariables(s) {
    return match(/-?\d+(?:\.\d+)?%?|\b[abcxyz]\b/g, s)
}

function getNumberAndVariable(s) {
    return search(/(\d+)([a-zA-Z]*)/, s).map(toNumber)
}

function moveToFront(items, target) {
    items.sort((a, b) =>
        a == target ? -1 : b == target ? 1 : 0
    )
    return items
}

function lowHigh(x) {
    if (isObject(x)) {
        const items = Object.entries(x)
        if (items[0][1] > items[1][1]) {
            return [items[1][0], items[0][0]]
        }
        return [items[0][0], items[1][0]]
    }
}

function pairWith(fn, ...args) {
    return function lambda(x, i, arr) {
        return [x, fn(x, ...args)]
    }
}

function isImport(s) {
    return test(/^import|const {|require|^from/, s)
}

function replaceInner(r, f, s) {
    return s.replace(r, (_, x) => {
        const regex = RegExp(boundary(rescape(x)))
        //console.log([_, x, regex])
        return _.replace(regex, f)
    })
}

//function coordinatesFromHashString(s) {
//}

function nerdQA(question) {
    const answer = nerdSolver(question)
    return { question, answer }
}

function randomf(x) {
    if (isArray(x)) {
        return function lambdaRandomPick() {
            const p = randomPick(x)
            //consoleThrow(p)
            return p
        }
    }
}
function qgBuildTopic(topic) {
    const templates = QuestionGeneratorTemplates
    const topicGenerationNet = {
        inequalities: {
            reference: 'equations',
            transform(s) {
                return s.replace(/=/, randomInequality)
            },
        },
        absoluteValue: {
            references: [
                {
                    reference: 'addition',
                    amount: 5,
                    transform(s) {},
                },
            ],
        },
    }

    function runner(ref) {
        if (error(ref)) return
        let { reference, transform, amount } = ref
        let templates = QuestionGeneratorTemplates[reference]
        if (amount) templates = templates.slice(0, amount)
        return templates.map(transform)
    }

    function error({ reference }) {
        if (templates.hasOwnProperty(topic)) {
            console.log(
                'the QGT already has the topic. no need to build it.',
                topic
            )
            return 1
        }
        if (!topicGenerationNet.hasOwnProperty(topic)) {
            console.log(
                'the TGNet doesnt have the topic. we want to build it, but we cant.'
            )
            return 1
        }

        if (!templates.hasOwnProperty(reference)) {
            console.log(
                'the parent dict doesnt have the reference. we want to build it, but we cant.'
            )
            return 1
        }
    }

    const ref = topicGenerationNet[topic]
    const payload = ref.references
        ? filter(flat(ref.references.map(runner)))
        : runner(ref)

    if (payload) templates[topic] = payload
}

function nerdSolveInequality(s) {
    const ref = {
        '>': 1,
        '<': 2,
        '>=': 1,
        '<=': 2,
    }

    let op

    s = s.replace(/[<>]=?/, (x) => {
        //op = ref[x]
        op = x
        return '='
    })

    //console.log(s)
    let value = nerdSolveEquation(s)
    return `x ${op} ${value}`
}

function reWrap(s, x, regexFlags = '') {
    if (isString(s)) {
        if (/^\(/.test(s) || !hasSpaces(s)) {
            return s
        }
    }

    if (isArray(s)) {
        if (s.every((x) => isString(x) && x.length == 1)) {
            s = `[${s.join('')}]`
        } else if (isString(s[0])) {
            s = s.join('|')
        } else if (isRegExp(s[0])) {
            s = s.map(reStr).join('|')
        }
    }

    if (isObject(s)) {
        s = Object.keys(s).join('|')
    }

    if (x == String) return s
    if (!x) return `(?:${s})`
    if (x.capture) s = `(${s})`
    if (x.boundary) s = `\\b${s}\\b`
    if (isString(x)) {
        if (x.includes('$')) {
            s = x.replace(/\$1/g, s)
            return RegExp(s, regexFlags)
        }
        let flags = ''
        if (x.includes('g')) flags += 'g'
        if (x.includes('i')) flags += 'i'
        if (x.includes('c')) s = `(${s})`
        if (x.includes('b')) s = boundary(s)
        if (x.includes('r')) s = RegExp(s, flags)
    }
    return s
}
function reWrap(s, x, regexFlags = '') {
    if (isString(s)) {
        if (/^\(/.test(s) || !hasSpaces(s)) {
            return s
        }
    }

    if (isArray(s)) {
        if (s.every((x) => isString(x) && x.length == 1)) {
            s = `[${s.join('')}]`
        } else if (isString(s[0])) {
            s = s.join('|')
        } else if (isRegExp(s[0])) {
            s = s.map(reStr).join('|')
        }
    }

    if (isObject(s)) {
        s = Object.keys(s).join('|')
    }

    if (x == String) return s
    if (!x) return `(?:${s})`
    if (x.capture) s = `(${s})`
    if (x.boundary) s = `\\b(?:${s})\\b`

    if (isString(x)) {
        if (x.includes('$')) {
            s = x.replace(/\$1/g, s)
            return RegExp(s, regexFlags)
        }
        let flags = ''
        if (x.includes('g')) flags += 'g'
        if (x.includes('i')) flags += 'i'
        if (x.includes('c')) s = `(${s})`
        if (x.includes('b')) s = `\\b(?:${s})\\b`
        if (x.includes('p')) s = `\\b(?:${s})(?![\'\"a-zA-Z])`
        if (x.includes('r')) s = RegExp(s, flags)
    }
    return s
}

function reStr(r) {
    if (isRegExp(r)) return r.source
    return r.toString().replace(/^\/|\/\w*$/g, '')
}

function assignState(state, mixin) {
    for (let [k, v] of Object.entries(mixin)) {
        state[k] = v.bind(state)
    }
}

// ac

function zooka(s, arg = 1) {
    if (isInteger(s)) {
        console.log('hiya', s, arg)
        return Number(s) + arg
    }
    let mode = arg > 0 ? 'floor' : 'ceil'
    console.log(mode, 'hi')
    return Math[mode](parseFloat(s))
}

function greaterThan(n, threshold, mode = 'inclusive') {
    return mode == 'inclusive' ? n >= threshold : n > threshold
}

function lessThan(n, threshold, mode = 'inclusive') {
    return mode == 'inclusive' ? n <= threshold : n < threshold
}
function isBetween(x, range, mode = 'inclusive') {
    let [a, b] = range
    return mode == 'inclusive'
        ? x >= a && x <= b
        : x > a && x < b
}
function numberf(config) {
    if (!config) return yes
    const tests = []

    if (config.below) {
        tests.push((x) => lessThan(x, config.below))
    }

    if (config.negative) {
        tests.push(isNegativeAnswer)
    }

    if (config.positive) {
        tests.push(isPositiveAnswer)
    }

    if (config.above) {
        tests.push((x) => greaterThan(x, config.above))
    }

    if (config.between) {
        tests.push((x) => isBetween(x, config.between))
    }

    if (config.onlyPositive) {
        tests.push(onlyPositive)
    }
    if (config.digitSum) {
        tests.push((x) => getDigitSum(x) == config.digitSum)
    }
    if (config.even) {
        tests.push((x) => isEven(x))
    }

    if (config.odd) {
        tests.push((x) => isOdd(x))
    }

    if (config.len) {
        tests.push((x) => len(x) == config.len)
    }

    if (config.digits) {
        tests.push((x) => {
            const digits = splitNumber(x)
            return config.digits(digits)
        })
    }
    return (x) => tests.every((test) => test(x))
}

function isNegative(s) {
    return Number(parseInt(s)) < 0
}

function runDemo(fn, multiple) {
    function runCodeTest(fn, a, b) {
        /* not in use */
        let equality = stringify
        let code = stringcall(fn, a)
        let A = eval(code)
        let B = eval(parens(b))
        return equality(A) == equality(B)
    }
    let answer
    function getDemoStringFromInsideTheFunction(fn) {
        let s = search(/\/\*(.*?)\*\//s, fn.toString())
        s = s.replace(/^ *\**/gm, '')
        s = smartDedent(s)
        if (/-->/.test(s)) {
            let [a, b] = split(s, /-->/)
            answer = b
            return a
        }
        return parseJSON(s)
    }

    let s = getDemoStringFromInsideTheFunction(fn)
    let v = multiple ? linegetter(s).map(runner) : runner(s)
    console.log(v)
    return v

    function runner(s) {
        const value = fn(s)
        if (!value) return null
        if (answer) {
            answer = parseJSON(answer)
            console.log(stringify(answer) == stringify(value))
            console.log({ answer, value })
        }
        return value
    }
}

function mode(a) {
    const count = {}

    a.forEach((e) => {
        if (!(e in count)) {
            count[e] = 0
        }
        count[e]++
    })

    let bestElement
    let bestCount = 0

    Object.entries(count).forEach(([k, v]) => {
        if (v > bestCount) {
            bestElement = k
            bestCount = v
        }
    })

    return bestElement
}

function percentOf(n, percent = 0.5) {
    return Math.floor(n * percent)
}

function selectIndexes(a, n, start = 1, end = -2) {
    if (!start) start = 0
    if (!end) end = -1
    let length = a.length
    const store = new Set()
    while (n) {
        let i = rng(start, length + end)
        if (store.has(i)) {
            continue
        }
        store.add(i)
        n--
    }
    return Array.from(store)
}

function trimAround(s) {
    const ar = s.split('\n').filter(exists)
    const start = ar.map(getIndent)
    const startValue = mode(start)

    const end = ar.map((x) => search(/ *$/, x).length)
    const endValue = mode(end)
    return ar.map((x) => {
        return endValue
            ? x.slice(startValue, -endValue)
            : x.slice(startValue)
    })
}

function isExpression(s) {
    return /\bx\b/.test(s)
}

const alphabet = [
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
]

function filterf(f, { at = null } = {}) {
    if (at == 1) return (x) => f(x[0])
    if (at == 2) return (x) => f(x[1])
    return (x) => filter(x, f)
}
function logf(f) {
    return function lambda(x) {
        const value = f(x)
        if (!value) {
            console.log('[NO VALUE @logf]')
            return value
        }
        blue('-'.repeat(20))
        console.log(value)
        blue('-'.repeat(20))
        return value
    }
}
function logf(s) {
    return function lambda(s) {
        return console.log(s)
    }
}

function timeoutf(f, delay = 100) {
    return function lambda(...args) {
        stamp('Starting Timeout')
        setTimeout(() => {
            const value = f(...args)
            stamp('Finished with Timeout')
        }, delay)
    }
}

class StandardObject {
    constructor(store = {}) {
        this.store = store
    }
    get length() {
        return Object.keys(this.store).length
    }
    get keys() {
        return Object.keys(this.store)
    }
    get values() {
        return Object.values(this.store)
    }
    get entries() {
        return Object.entries(this.store)
    }
    has(key) {
        return this.store.hasOwnProperty(key)
    }
    get(key) {
        return this.store[key]
    }
}

function isError(x) {
    return x.constructor.name.includes('Error')
}

function isSet(x) {
    return x.constructor.name == 'Set'
}

function normalizePath(a, b) {
    return a + b
}

function stringify(s, birth) {
    return !exists(s)
        ? ''
        : isPrimitive(s)
        ? s
        : isFunction(s)
        ? s.toString()
        : JSON.stringify(s, birth, 2)
}

function isLast(i, a) {
    return a.length - 1 == i
}

function variableExists(v) {
    const expr = `typeof ${v} != 'undefined'`
    return eval(expr)
}

function functionStringBirth(s) {
    const watcher = new Watcher()
    return !exists(s)
        ? ''
        : isPrimitive(s)
        ? s
        : isFunction(s)
        ? s.toString()
        : JSON.stringify(s, replacer, 2)

    function replacer(k, v) {
        const name = v.constructor.name
        if (k.startsWith('_')) return //isPrivate//
        if (name == 'Object' || name == 'Array') {
            return v
        }

        if (name == 'Function' || name == 'AsyncFunction') {
            return v.toString()
            // a lambda function ... wont remember the state
        }
        if (name == 'String' || name == 'Number') {
            return stringify(v)
        } else if (v) {
            return {
                constructorName: v.constructor.name,
                constructorValue: mapState(v),
            }
        }
    }
}

function log(s) {
    console.log(s)
}

function panify(s, i, a) {
    if (i == 0) s += ''
    else if (i == a.length - 1) {
        if (s.length > 1) s = ' ' + s
    }
    //else if ( a[i + 1] == '.')
    else s = ' ' + s
    //else s = wrap(s, ' ')
    return divify('span', '', s)
}

function vueColor(item, key, extra = '') {
    item = item.replace(/\$/, '')
    return `<span :style="{color: colors[${
        key || item
    }]}">{{${item}}}${extra}</span>`
}

function isPrivate(s) {
    return s.startsWith('_')
}

function reconfigure(state, options) {
    if (!state.hasOwnProperty('config')) {
        console.log(
            'reconfigure always targets the config property'
        )
        return
    }
    assignExisting(state.config, options)
}

function toFunction(options = {}) {
    let name = options.name || ''
    let params = options.params || options.args || []
    let body = options.body || ''
    let mode = options.mode || Function
    let form = options.form || 'function'
    if (mode == String) {
        return toStringFunction(name, params, body, { form })
    }

    if (mode == Function) {
        return eval(
            parens(toStringFunction(name, params, body))
        )
    }

    if (options.return) {
        body = 'return ' + options.return
    }
    return new Function(...params, body)
}

function getArgsFromCallable(s) {
    let [a, b] = search(/(\w+)\((.*?)\)$/, s)
    return {
        caller: a,
        args: b,
    }
}

function oncef(fn) {
    let done = 0
    return function lambda(...args) {
        if (done) {
            console.log('already done')
            return
        }
        done = 1
        return fn(...args)
    }
}

function editStorage(storage, fn) {
    for (let [a, b] of storage.entries) {
        for (let [aa, bb] of Object.entries(b)) {
            const value = fn(aa, bb, a)
            if (value == null) continue
            storage.store[a][aa] = value
        }
    }
    return storage
}

function enforce(s) {
    s = s.replace(/[a-zA-Z]+$/, (x) => {
        return singlequote(x)
    })
    let allGood = eval(s)
    if (!allGood) {
        let code = s.replace(/==/, '=')
        eval(code)
    }
}

function isCodeExpression(s) {
    const regex = /^(?:[a-zA-Z]\w+\()/
}
function isColor(s) {
    return roygbiv.includes(s) || /^#/.test(s)
}

function arithmetic(operator, a, b) {
    const answer = eval(`${a} ${operator} ${b}`)

    if (operator == '*') operator = '\\times'
    if (operator == '/') operator = '\\div'

    const question = `${a} ${operator} ${b} =\\medspace?`
    const expression = `${a} ${operator} ${b} = ${answer}`
    const payload = { answer, question, expression }
    return payload
}

function coerceTo(x, mode) {
    assert(mode)
    if (mode == 'array' || mode == Array) {
        if (isArray(x)) {
            return x
        }
        if (isString(x)) {
            return /\n/.test(x)
                ? x.split(/\n/)
                : / /.test(x)
                ? x.split(' ')
                : x.split('')
        }
        throw 'not done'
    }

    if (mode == 'string' || mode == String) {
        if (isString(x)) {
            return x
        }
        if (isArray(x)) {
            return x.join(' ')
        }
        throw 'not done'
    }
    throw 'not done'
}

function stringDictionaryEntry(a, b) {
    const parse = (x) => {
        if (isString(x)) {
            return quotify(x)
        }
        return toStringArgument(x)
    }
    return `'${a}': ${parse(b)},`
}

function notIn(ref) {
    if (isObject(ref)) {
        ref = Object.keys(ref)
    }

    return function lambda(s) {
        if (isArray(s)) {
            if (isString(ref)) {
                return !s.includes(ref)
            }
            return unique(s, ref)
        }

        if (isString(ref)) {
            return s != ref
        }
        if (!ref) return true
        return !ref.includes(s)
    }
}

function lineFilter(s, fn) {
    return join(s.split('\n').filter(fn))
}

function info(state, ...keys) {
    const value = reduce(keys, (key) => state[key])
    console.log('INFO!!!', value)
    return value
}


function isMp3(x) {
    const e = ['m4a', 'wav', 'mp3']
    return e.includes(getExtension(x))
}

function getProseWords(s) {
    return s.match(/\b\w[\w\'-]*\w\b/g)
}

function puppetVisitor(x, parent) {
    return
    if (x == null) return `[Primitive]: null`
    const name = x.constructor.name
    const known = {
        TreeCursor: lookNode,
        BufferNode: lookNode,
        BufferNode$1: lookNode,
        Tree: lookNode,
        TreeNode: lookNode,
    }

    if (name.endsWith('Error')) {
        console.log()
        return x.stack
    }

    if (name == 'Object' || name == 'Array') {
        return x
    }

    if (name == 'Function' || name == 'AsyncFunction') {
        return x.name
        return `[Primitive]: ${x.name}`
    }

    if (name == 'Boolean') {
        return x
        return `[Primitive]: ${x}`
    }

    if (name == 'Number') {
        return x
        return `[Primitive]: ${x}`
    }

    if (name == 'String') {
        return x
        return `[Primitive]: [${x || 'empty-string'}]`
    }

    if (name in known) {
        const value = known[name](x)
        return value
    }
    return `[Name]: ${name || 'undefined'}`
}

function lookDiv(x) {
    return {
        name: x.className || x.tagName,
        text: x.textContent,
        pos: getBoundingClientRect(x),
        color: x.style.background,
    }
}

function forIterationArg(s) {
    if (s.endsWith('s')) {
        return s.slice(0, -1)
    }
    const dict = {
        children: 'child',
    }

    let match = search(/children$/i, s) || ''
    return dict[match.toLowerCase()] || 'item'
}
const knownAttrs = {
    //submit: ['@submit', 'onSubmit'],
    //click: ['@click', 'onClick'],
    //x: ['@x', 'onX'],
    //x: ['@x', 'onX'],
    //x: ['@x', 'onX'],
    //x: ['@x', 'onX'],
    //submit: ['@submit', 'onSubmit'],
}
function vueHelper(key, value) {
    let [a, b] = _vueHelper(key, value)
    return `${a}="${b}"`
}
function _vueHelper(key, value) {
    if (key == '@') {
        return ['@' + value, value]
    }

    if (key == ':') {
        if (value.includes('=')) {
            let [a, b] = value.split('=')
            return [':' + a, b]
        }
        return [':' + value, value]
    }
    if (value == null && key in knownAttrs) {
        return knownAttrs[key]
    }
    let vKey = vmap[key] || key
    if (key == 'for') {
        value = `(${forIterationArg(value)}, i) in ${value}`
    }

    return [vKey, value]
}

function singleWordParser(s) {
    if (s.includes('=')) {
        let [a, b] = split(s, '=')
        let div = 'div'
        if (a == 'for') {
            let arg = depluralize(b)
            let stuff = `(${arg}, index) in ${b}`
            className = toDashCase(arg) + '-item'
            return toOpeningTag('div', {
                class: className,
                'v-for': stuff,
            })
        }
    }
    if (s == 'div' || s == 'container') {
        let containerClass = 'container-' + 100
        return toOpeningTag(div, {
            class: containerClass,
        })
    }

    if (s == 'transition') {
        return toOpeningTag(s, {
            mode: 'out-in',
            name: 'fade',
        })
    }

    if (s == 'component') {
        return divify(s, {
            ':is': 'currentComponent',
        })
    }
    if (test(/^item\.\w+$/, s)) {
        let className = state.forArg
            ? state.forArg + '-' + toDashCase(s)
            : toDashCase(s)

        return divify('div', { class: className }, vueText(s))
    }

    return divify('div', { class: toDashCase(s) }, vueText(s))
    return toOpeningTag(div, { class: s })
}

function announceError(e) {
    console.log(['ERROR', getCaller(), e.toString()])
}

function repf(a, b, flags = 'g') {
    return function replacerLambda(s) {
        return replace(a, b, s, flags)
    }
}

function hasOverlap(a, b) {
    return a.some((x) => b.includes(x))
}

function typeOf(x) {
    if (x == null) return 'null'
    const name = x.constructor.name
    switch (name) {
        case 'String':
            return name + '-variable'
        default:
            return name
    }
}

function jshint(source) {
    const JSHINT = require('./jshint.js')

    const predef = {
        Vue: true,
        prettier: true,
        clearTimeout: true,
        setTimeout: true,
        console: true,
    }

    const options = {
        asi: true,
        debug: true,
        evil: true,
        eqnull: true,
        esversion: 8,
        expr: true,
        funcscope: true,
    }

    JSHINT.jshint(source.toString(), options, predef)
    return JSHINT.data()
}

function puppetVisitorDeep(x) {
    return runner(x)
    function runner(x) {
        if (x == null) return `[Primitive]: null`
        if (isPrimitive(x)) {
            return x
        }

        if (isSet(x)) {
            return Array.from(x)
        }

        const name = x.constructor.name
        if (name == 'Object' || name == 'Array') {
            return x
        }

        if (name == 'Function' || name == 'AsyncFunction') {
            return `[Primitive]: ${x.name}`
        }
        return reduceObject(x, (k, v) => {
            return [k, runner(v)]
        })
    }
}

function shortValue(s) {
    if (s.includes('\n')) {
        return (
            s.match(/.+/)[0] +
            ' ... ' +
            opposite(search(/[\[\{]/, s))
        )
    }
    return s
}

function lookNode(x, s) {
    if (!s) return x.name
    if (!x) return
    const value = shortValue(s.slice(x.from, x.to))
    const o = {
        name: x.name,
        from: x.from,
        to: x.to,
        value: value,
        //long: s.slice(x.from, x.to)
    }
    return o
}

function isZDate(s) {
    return isString(s) && s.length == 20 && s.endsWith('z')
}


function getHMSM(date) {
    if (!date) date = new Date()
    else if (isString(date)) {
        date = new Date(date)
    }
    const hours = date.getHours()
    const minutes = date.getMinutes()
    const seconds = date.getSeconds()
    const ms = date.getMilliseconds()
    const ampm = hours >= 12 ? 'PM' : 'AM'
    return [
        hours >= 12 ? hours - 12 : hours,
        minutes,
        seconds,
        ms,
        ampm,
    ]
}
function mutate(x, fn, ...args) {
    for (let [k, v] of Object.entries(x)) {
        const value = fn(v, ...args)
        if (value) x[k] = value
    }
}

function getDayAndMonth(date) {
    if (!date) date = new Date()

    var day = DAYS[date.getDay()]
    var month = MONTHS[date.getMonth()]
    return [day, month]
}
function datePhrase(s) {
    if (!s || isBoolean(s)) s = 'day, month number year'
    if (s.includes('$')) {
        return templater2(s, {
            season: getSeason,
            year: getYear,
        })
    }
    const date = new Date()
    const [day, month] = getDayAndMonth(date)
    const [_, dayNumber, year] = getMDY(date)
    const number = ordinal(dayNumber)
    return templater2(s, { number, day, month, year })
}

function ordinal(n, s = '') {
    return (
        n +
        ([, 'st', 'nd', 'rd'][(n % 100 >> 3) ^ 1 && n % 10] ||
            'th') +
        s
    )
}

function getMDY(date) {
    date = isNull(date)
        ? new Date()
        : isPrimitive(date)
        ? new Date(date)
        : date
    const year = date.getFullYear()
    const month = date.getMonth() + 1
    const day = date.getDate()
    return [month, day, year]
}

function isString(s) {
    return typeof s === 'string'
}

function conditional(fn, condition) {
    return function lambda(x) {
        if (ftest(condition, x)) return fn(x)
        return x
    }
}

function isArray(a) {
    return Array.isArray(a)
}

function isObject(x) {
    return (
        Object.prototype.toString.call(x) == '[object Object]'
    )
}
function getConstructorName(x) {
    return (x && x.constructor && x.constructor.name) || ''
}
function isObjectLiteral(x) {
    return getConstructorName(x) == 'Object'
}

function seeInfo(x) {
    //
    //waiting on me...
    //v=new x((vv) => vv()).then((y) => console.log(y))
    //console.log(v)
    //console.log(Object.keys(v))
    //console.log(v)
    //Object.getOwnPropertyNames(new x(identity))
    //console.log(Object.getOwnPropertyNames(new x(identity)))
    //Object.getOwnPropertyNames(x)
    //Object.getOwnPropertyNames
    //console.log(Object.getPrototypeOf({}).hasOwnProperty('__defineGetter__'))
    //return Object.getPrototypeOf(x).hasOwnProperty('__defineGetter__')
}

function mapState(state) {
    const name = state.constructor.name
    const ref = {
        Set: Array.from,
        RegExp: String,
        Watcher: 'seen',
        //'Storage': 'store',
    }
    if (ref.hasOwnProperty(name)) {
        const key = ref[name]
        return isFunction(key) ? key(state) : state[key]
    }
}

function reduceIterableHelper(acc, value, k) {
    if (isArray(value) && value.length == 2) {
        acc[value[0]] = value[1]
    } else if (!isNull(value)) {
        acc[k] = value
    }
    return acc
}
function reduceObject(o, fn = (k, v) => [k, v]) {
    return Object.entries(o || {}).reduce((acc, item, i) => {
        const value = fn(...item, i)
        return reduceIterableHelper(acc, value, item[0])
    }, {})
}
function reduceArray(a, fn) {
    if (isNestedArray(a)) {
        return a.reduce((acc, item, i) => {
            const value = fn(...item, i)
            return reduceIterableHelper(acc, value, item[0])
        }, {})
    } else {
        return a.reduce((acc, item, i) => {
            const value = fn(item, i)
            return reduceIterableHelper(acc, value, item)
        }, {})
    }
}
function reduce(items, fn) {
    if (!exists(items)) return {}
    const objectReducer = (k, v) => [k, v]

    if (isObject(items)) {
        return reduceObject(items, fn || objectReducer)
    }

    return reduceArray(items, fn || objectReducer)
}

function uncomment(s) {
    //return s.replace(/^\/\/ */, '')
    return s.replace(/^(?:\/\/|"|#) */, '')
}

function escapeNewlinesAndQuotes(s) {
    return s.replace(/[\n\'\"]/g, (x) => {
        switch (x) {
            case '\n':
                return '\\n'
            case "'":
                return "\\'"
            case '"':
                return '\\"'
        }
    })
}

function yes() {
    return true
}

function longShort(a, b) {
    if (isNumber(a)) {
        return a >= b ? [a, b] : [b, a]
    }
    return len(a) >= len(b) ? [a, b] : [b, a]
}

function shortLong(a, b) {
    if (isNumber(a)) {
        //console.log(a <= b, 'hi')
        //console.log(); throw ''
        return a <= b ? [a, b] : [b, a]
    }
    return len(a) <= len(b) ? [a, b] : [b, a]
}

function getLines(s, a, b) {
    let regex = ''
    let marker = '\\n.*'
    if (b) {
        if (a) {
            regex += '^.*\n'
            regex += marker.repeat(a - 1)
        }
        regex += '('
        regex += `(?:.*\\n){0,${b - 1}}.*`
        regex += ')'
    } else {
        regex += '('
        regex += '^.*'
        regex += `(?:\\n.*){0,${a - 1}}`
        regex += ')'
    }
    //console.log(regex)
    return search(regex, s)
}
function isSimilar(a, b) {
    //function runner(s) {
    //const words = getWords(getLines(s.trimStart(), 3), {mode:'code'})
    //return words
    //}

    function runner(s) {
        return s.trimStart().slice(0, 10).trim()
    }

    function runner(s) {
        return getLines(s.trimStart(), 0, 1).trim()
    }

    if (type(a) !== type(b)) return false
    if (!a || !b) return false
    if (isString(a)) {
        return runner(a) == runner(b)
        return (
            unique(...longShort(runner(a), runner(b))).length <
            3
        )
    }
    return true
}
function push(items, x, unique) {
    if (!x) return items
    if (isSet(x)) {
        x = Array.from(x)
    }
    if (unique) {
        if (isArray(x)) {
            for (let item of x) {
                if (!items.includes(item)) items.push(item)
            }
        } else if (!items.includes(x)) {
            items.push(x)
        }
    } else {
        isArray(x) ? items.push(...x) : items.push(x)
    }
    return items
}
function mergeState(state, key, value) {
    state[key] = merge(state[key], value)
    return state
}

function mergeProperty(state, key, value) {
    state[key] = merge(state[key], value)
    return state
}
function iterTest(s, items) {
    for (let i = 0; i < items.length - 1; i += 2) {
        if (test(items[i], s)) {
            return items[i + 1]
        }
    }
    return getLast(items)
}

function hasPeriod(s) {
    return s.includes('.')
}

function getFunction(key, s) {
    const functionRE = `^(?:(?:async )?function|const|var|class) ${key}[^]+?\\n}`
    return search(regex, s)
}

function argumentGetter(args) {
    if (args.length == 1) {
        return
    }
    return Array.from(args)
}
function argumentFiller(args, ...fillers) {
    if (args.length == 1) {
        return [fillers[0], args[0]]
    }
    return args
}

function toMilliseconds(s) {
    s = Number(s) || 0
    if (s >= 50) {
        return s
    }
    return s * 1000
}

function isAsync(x) {
    return x.constructor.name == 'AsyncFunction'
}

function partition(items, n = 2) {
    function partitionWithFunctions(items, ...args) {
        //console.log(items, args); throw '';
        //console.log(args, 'hffffffffffffi')
        const store = range(args.length + 1, [])
        for (let item of items.filter(exists)) {
            for (let i = 0; i < args.length; i++) {
                let arg = args[i]
                //console.log([arg, item, ftest(arg, item)])

                if (ftest(arg, item)) {
                    store[i].push(item)
                    break
                }

                if (i == args.length - 1) {
                    store[store.length - 1].push(item)
                }
            }
        }
        return store
    }
    if (!isNumber(n)) {
        return partitionWithFunctions(...arguments)
    }
    const store = []
    for (let i = 0; i < items.length; i++) {
        if (i % n == 0) {
            store.push([])
        }
        getLast(store).push(items[i])
    }
    assert(store[0].length == n)
    return store
}

function getInterestingBindings(s) {
    const regex = /[a-zA-Z][\w.]{2,}(?=[\(\[\]])/g
    return Array.from(s.match(regex) || [])
}

function hasBrackets(s) {
    return test(/{/, s)
}

function hasBracket(s) {
    return test(/{/, s)
}

function throwError(...args) {
    console.log(args)
    throw ''
}

function coinflip(n = 0.1) {
    if (arguments.length > 1) {
        return Math.random() > 0.5 ? arguments[0] : arguments[1]
    }
    return Math.random() > 1 - n
}

function isUtf(s) {
    const utfe = [
        'txt',
        'lang',
        'drafts',
        'js',
        'py',
        'vim',
        'json',
        'css',
        'html',
    ]
    return utfe.includes(getExtension(s))
}

s = `

`

function smartMore(s) {}
function opposite(s) {
    const dict = {
        '{': '}',
        visible: 'hidden',
        hidden: 'visible',
        '[': ']',
        '(': ')',
        true: false,
        false: true,
        '^': '$',
        '}': '{',
        ']': '[',
        ')': '(',
        1: 0,
        0: 1,
    }
    if (isNull(s)) {
        return true
    }
    s = s.toString()
    return dict.hasOwnProperty(s) ? dict[s] : s
}

class CumulativeStorage {
    constructor(store) {
        this.store = store || {}
    }
    get value() {
        return this.store
    }
    add(...args) {
        addProperty(this.store, ...args)
    }
}

function addProperty(o, ...args) {
    if (args.length == 2) {
        return addPropertyLambda2(o, ...args)
    }

    if (args.length == 3) {
        if (args[2] == Array) {
            return addPropertyLambdaArray(o, ...args)
        }
        return addPropertyLambda3(o, ...args)
    }

    function addPropertyLambdaArray(o, key, value) {
        if (!o.hasOwnProperty(key)) {
            o[key] = []
        }
        isArray(value)
            ? o[key].push(...value)
            : o[key].push(value)

        return o
    }
}

function exists(input) {
    if (input == null) return false
    if (isString(input)) return input.trim().length > 0
    if (isArray(input)) return input.filter(exists).length > 0
    if (isObject(input)) return Object.keys(input).length > 0
    return true
}

function addPropertyLambda2(o, key, value) {
    if (o[key]) {
        if (isObject(value)) {
            Object.assign(o[key], value)
        } else if (isArray(value)) {
            o[key] = [...o[key], ...value]
        } else {
            if (isArray(o[key])) {
                push(o[key], value)
            } else {
                o[key] = [o[key], value]
            }
        }
        return o
    }

    o[key] = value
    return o
}

function addPropertyLambda3(o, parentKey, key, value) {
    if (!o.hasOwnProperty(parentKey)) {
        o[parentKey] = {}
    }
    o[parentKey][key] = value
    return o
}

function iterRange(...args) {
    const store = []
    args = gatherArgs(args)
    for (let i = args[0]; i <= args[1]; i++) {
        store.push(i)
    }
    return store
}

function isPureObject(x) {
    return x && x.constructor.name == 'Object'
}

function isThisFunction(s) {
    s = s.toString()
    return test(/\bthis\b/, s)
}

function rainbow(a, b = 10, stops = 20) {
    return rainbowStops(a, b, stops)

    function rainbowStop(h) {
        let f = (n, k = (n + h * 12) % 12) => {
            return (
                0.5 -
                0.5 * Math.max(Math.min(k - 3, 9 - k, 1), -1)
            )
        }
        let rgb2hex = (r, g, b) =>
            '#' +
            [r, g, b]
                .map((x) =>
                    Math.round(x * 255)
                        .toString(16)
                        .padStart(2, 0)
                )
                .join('')
        return rgb2hex(f(0), f(8), f(4))
    }

    function rainbowStops(a, length, stops) {
        let store = []
        let base = a
        for (let i = 0; i < length; i++) {
            let start = base + i
            let increment = start / stops
            console.log(increment)
            const value = rainbowStop(
                increment / length,
                1,
                0.5
            )
            store.push(value)
        }
        return store
    }
}

function average(a, b) {
    return (a + b) / 2
}

class Indexed extends StandardObject {
    constructor(store = {}) {
        super(store)

        this.tracker = exists(store)
            ? reduce(store, (k, v) => [
                  k,
                  { index: 0, done: !exists(v) },
              ])
            : {}

        this.key = this.keys[0]
        this.config = {
            autoIncrement: true,
            autoIncrement: false,
            modulus: false,
        }
    }

    get(index) {
        return this.store[this.key][index]
    }

    get index() {
        return this.tracker[this.key].index
    }

    set index(n) {
        if (this.isDone()) {
            if (this.config.autoIncrement) {
                this._incrementKey(this.key)
            }
            return
        }
        this.tracker[this.key].index = n
    }

    set indexOld(val) {
        if (this.get(val)) {
            this.tracker[this.key].index = val
        } else {
            this.tracker[this.key].done = true
            const done = this._incrementKey(this.key)
            if (done) {
                this.finished = true
            }
        }
    }

    get value() {
        return this.store[this.key][this.index]
    }
    get length() {
        return this.store[this.key].length
    }

    _incrementKey(key) {
        let count = 0
        while (count++ < this.keys.length) {
            key = modularIncrement(this.keys, key)
            if (this.tracker[key].done === false) {
                this.key = key
                return false
            }
        }
        return true
    }

    set(key) {
        this.key = key
    }

    isDone() {
        const done = this.index == this.length
        if (done) {
            this.tracker[this.key].done = true
        }
        return done
    }
}

function isObject(x) {
    return type(x) == 'Object'
}

class LimitError extends Error {
    constructor() {
        console.log('limit error')
    }
}

function simpleBreaker(limit = 100) {
   let count = 0
   return function lambdaBreaker(s) {
       if (count++ > limit) {
           throw new LimitError()
       }
   }
}
function breaker(limit = 20) {
    if (typeof __once__ == 'undefined') {
        __once__ = 0
    }
    if (++__once__ == limit) {
        console.log(getCaller(-1))
        throw 'limit reached @brekaer'
    }
}
breaker.reset = () => {
    if (typeof __once__ == 'undefined') {
        __once__ = 0
    }
    __once__ == 0
}

function isNumber(s) {
    return (
        typeof s == 'number' || test('^-?\\d+(?:\\.\\d+)?$', s)
    )
}

function test(regex, s, flags = '') {
    try {
        return prepareRegex(regex).test(s)
    } catch (e) {
        console.log({ s })
        throw ''
    }
}

function range(...args) {
    let a
    let b
    let c

    if (args.length == 3 && args.every(isNumber)) {
        let store = []
        let [a, b, c] = args
        for (let i = a; i <= b; i += c) {
            store.push(i)
        }
        return store
    }
    if (isFunction(args[1])) {
        let store = []
        for (let i = 1; i <= args[0]; i++) {
            args.length == 2
                ? store.push(args[1](i))
                : store.push(args[1](...args.slice(2)))
        }
        return store
    }
    if (!isPrimitive(getLast(args))) {
        c = args.pop()
    }

    if (args.length == 1) {
        if (isStringNumberRange(args[0])) {
            ;[a, b] = split(args[0], '-').map(Number)
            console.log(a, b)
        } else {
            b = args[0]
            a = 1
        }
    } else {
        ;[a, b] = args
    }

    if (isArray(b)) {
        b = b.length - 1
        a = 0
    }

    const store = []
    for (let i = Number(a); i <= Number(b); i++) {
        if (c) {
            if (c.toString() == [].toString()) store.push([])
            else if (c.toString() == {}.toString())
                store.push({})
        } else {
            store.push(i)
        }
    }
    return store
}

function isPrimitive(value) {
    return (
        typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'symbol' ||
        typeof value === 'boolean'
    )
}

function textTable(items) {
    const matrix = new Matrix(items, { width: 4 })
    let t = ''
    matrix.iterate((value, k, v, i, linebreak) => {
        t += i + '. ' + value + '   '
        if (linebreak) t += '\n'
    })
    return t
}

function isDoubleIterable(items) {
    return isObject(items) || isNestedArray(items)
}

function isYouQuestion(s) {
    return isQuestion(s) && /\byou\b/.test(s)
}

function isQuestion(s) {
    return /\?/.test(s)
    //const questionRE = RegExp(
    //'^(?:[@$]?\\w+, )?' + ncg('', questionWords),
    //'i'
    //)
    //return questionRE.test(s)
}

function isQuote(s) {
    return test(/^['"]/, s)
}

function isStringNumberRange(s) {
    return /^\d+-\d+$/.test(s)
}

class Tally {
    constructor(items) {
        this.storage = items ? 
            tally(items) : new Storage({_mode: Number})
    }

    add(key) {
        const value = this.storage.add(key)
        return value
    }
    pop() {
        const store = []
        let lowest = getShortest(this.storage.values)
        let lowestValue
        for (let [a, b] of this.storage.entries) {
            if (b == lowest && isNull(lowestValue)) {
                lowestValue = a
            } else {
                store.push(a)
            }
        }
        return [lowestValue, store]
    }
    highest() {
        const longest = getLongest(this.storage.values)
        const store = mapfilter(this.storage.entries, (x) => {
            return x[1] == longest && x[0]
        })
        return coerceToNullIf(store.length > 1, store[0])
    }

    lowest(threshold = null) {
        const values = this.storage.values
        const lowest = threshold
            ? values.some((x) => x == threshold) && threshold
            : Math.min(...values)
        if (!lowest) return null
        const entry = this.storage.entries.find((x) => {
            return x[1] == lowest && x[0]
        })
        return entry && entry[0]
    }
}
function coerceToNullIf(condition, value) {
    if (condition) return null
    return value
}
function tally(arr, mode = Object) {
    const storage = new Storage({ _mode: Number })
    for (let item of arr) {
        storage.add(item)
    }
    if (mode == Array) return Object.entries(storage.value)
    return mode == Object ? storage.value : storage
}


class Spellcheck {
    static spellcheck(s, dict) {
        const spell = new Spellcheck('oneToExclam', 'dedent')
        spell.load(dict)

        s =  s.replace(/([a-zA-Z])1(?= |$|\n)/g, '$1!')
        const p = spell.spellcheck(s)
        //console.log(p); throw '';
        return p
    }
    load(dict) {
        if (dict) {
            this.dict = dict
        }
        if (!this.dict) {
            this.dict = require(this.file)
        }
        if (!this.regex) {
            this.regex = reWrap(this.dict, 'pgr')
        }
    }
    run(s) {
        this.load()

        for (let parser of this.parsers) {
            s = parser(s)
        }
        return s
    }
    constructor(...keys) {
        this.file = '/home/kdog3682/JSONS/words.json'
        this.parsers = [trim, this.spellcheck.bind(this)]

        for (let key of keys) {
            this.parsers.push(this[key])
        }
    }
    save(s) {
        let r = /^(\w+) (\w+) *$|^(\w+ \w+) (.+) *$/gm
        let m = findall(r, s)
        let dict = m.reduce((acc, [a,b,c,d], i) => {
            if (a) {
                if (a in this.dict) {
                     console.log('has it', a)
                     return acc
                }
                acc[a] = b
            }

            else if (c) {
                if (c in this.dict) {
                     console.log('has it', c)
                     return acc
                }
                acc[c] = d
            }
            return acc
        }, {})

        write(this.file, merge(this.dict, dict))
    }
    spellcheck(s) {
        return s.replace(this.regex, (x, offset, o) => {
            if (/[.\'\"]/.test(o.charAt(offset - 1))) {
                return x
            }
            return this.dict[x] || x
        })
    }
    oneToExclam(s) {
        return s.replace(/([a-zA-Z])1/g, '$1!')
    }
    dedent(s) {
        return s.replace(/^ */gm, '')
    }

}
function spellcheck(s) {
    let dict = require('/home/kdog3682/JSONS/words.json')
    let regex = reWrap(dict, 'pgr')
    return trim(s).replace(regex, (x, offset, o) => {
        if (/[.\'\"]/.test(o.charAt(offset - 1))) {
            return x
        }
        return dict[x] || x
    })
}

function spellcheckf(dict) {
    if (!dict && isNode()) {
        dict = require('/home/kdog3682/pmwb.json')
    }
    let regex = RegExp(`\\b${reWrap(dict)}(?![\'\"\\w])`, 'g')
    return function spellcheck(s) {
        return trim(s).replace(regex, (x, offset, o) => {
            if (/[.\'\"]/.test(o.charAt(offset - 1))) {
                return x
            }
            return dict[x] || x
        })
    }
}

function isNestedArray(x) {
    return isArray(x) && isArray(x[0])
}

function changeDollars(s, replacement = '') {
    return s.replace(/\$(?=[a-zA-Z])/g, replacement)
}

function removeEs6(s) {
    return s.replace(/^import.+\n*|^export /gm, '')
}

function isLink(s) {
    return getExtension(s) == 'css'
}

function regexElongation(s) {
    return `(?:${s})+`
}

function getBindings(s) {
    const bindingRE =
        /^(?:def|class|const|var|(?:async )?function) (\w+)/g
    return findall(bindingRE, s)
}

function getBindingName(s) {
    const bindingRE =
        /^(?:def|class|const|var|(?:async )?function) (\w+)/
    return search(bindingRE, s)
}

function getFunctionNames(s, key) {
    const value = unique(findall(functionNameRE, s))
    return key ? value.filter(testf('^' + key)) : value
}
function getFunctionName(s) {
    if (isFunction(s)) return s.name
    return search(
        /^(?:def|class|const|var|(?:async )?function) (\w+)/,
        s
    )
}

function isFunction(x) {
    return typeof x === 'function'
}

function isPlural(s) {
    return test(/[^s]s$/, s)
}

function toSpaces(n = 4, tabs = 0) {
    if (!n) {
        return ''
    }
    if (tabs)
        return isNumber(n)
            ? '\t'.repeat(n / 4)
            : '\t'.repeat(n.length / 4)
    return isNumber(n) ? ' '.repeat(n) : n
}

function replace(regex, replacement, s, flags = 'gm') {
    return s.replace(prepareRegex(regex, flags), replacement)
}

class Watcher {
    constructor(fn) {
        this.fn = fn || identity
        this.seen = new Set()
        this.count = 0
        this.lambdaCount = 0
    }
    wrap(fn, transform) {
        const self = this
        function lambdaWatcherWrap(...args) {
            //console.log(fn, args)
            const value = fn(...args)
            const freshValue = valueTransform(value, transform)
            if (self.isFresh(freshValue)) {
                return value
            } else {
                console.log('DO IT AGAIN!!!!')
                throw ''
                this.lambdaCount++
                if (this.lambdaCount > 50) {
                    console.log(args)
                    throw ''
                }
                return lambdaWatcherWrap(...args)
            }
        }
        return lambdaWatcherWrap
    }
    filter(items) {
        return items.filter((item, i) => {
            return this.isFresh(item)
        })
    }
    isFresh(key, rev) {
        let value = this.fn(key)
        //console.log(value, key)
        if (this.seen.has(value)) {
            this.count += 1
            return false
        }
        this.seen.add(value)
        if (rev) {
            //console.log(value, 'rev')
            this.seen.add(reverse(value))
        }
        this.count = 0
        return true
    }
    has(key) {
        return this.seen.has(key)
    }
}

function isHtmlFile(s) {
    return /\.html$/.test(s)
}

function isCssFile(s) {
    return /\.css$/.test(s)
}

function isJavascriptFile(s) {
    return /\.js$/.test(s)
}

function getQuotes(s) {
    return findallStrings(s)
    //
}

function findKeyFactory(mode, index = 0) {
    const method = mode == 'single' ? 'find' : 'filter'
    return function findKeyRunner(x, kt, vt) {
        const value = Object.entries(x)[method]((x) => {
            if (kt) return kt(x[0])
            if (vt) return vt(x[1])
        })

        if (mode == 'single') {
            return value && value[index]
        }

        if (mode == 'multiple') {
            return value.map((x) => x[index])
        }
    }
}

function getShortestLongest(mode) {
    const compare =
        mode == 'longest' ? (a, b) => a > b : (a, b) => a < b
    const mathFn = mode == 'longest' ? Math.max : Math.min
    const defaultMode = null
    //const defaultMode = mode == 'longest' ? Number : null

    return function getter(
        arr,
        measure = len,
        mode = defaultMode
    ) {
        let asObject
        let keys
        if (isObject(arr)) {
            keys = Object.keys(arr)
            arr = Object.values(arr)
            asObject = true
        }
        if (arr.every(isNumber)) {
        }

        const value = arr.reduce(
            (acc, item, i) => {
                if (!item) return acc
                const itemLength = measure(item, i)
                if (mode == Number)
                    return mathFn(itemLength, acc)
                const accLength = isNumber(acc)
                    ? acc
                    : measure(acc, i)
                return compare(accLength, itemLength)
                    ? acc
                    : item
            },
            mode == Number ? 0 : arr[0]
        )
        if (asObject) {
            let index = arr.indexOf(value)
            console.log(index)
            return keys[index]
        }
        return value
    }
}

function findCaller(target, offset = 0) {
    const stack = getStackTrace()
    console.log(stack, target)
    console.log()
    throw ''
    const index =
        stack.findIndex((x) => test(target, x[0])) + offset
    const [name, line] = index
    return { name, line }
}

function hasSymbol(s) {
    return test(/[^\sa-zA-Z]/, s)
}

function toArray(val) {
    if (isPrimitive(val)) return [val]
    if (isFunction(val)) {
        return [val]
    }
    return Array.from(val)
}
function looksLikeRegex(s) {
    return test(/^\//, s)
    return test(/^\/.*?\/\w*$/, s)
}

function prepareRegex(r, flags) {
    if (!isString(r)) return r
    if (looksLikeRegex(r)) {
        return RegExp(...search(/^\/(.*?)\/(\w*)$/, r))
    }
    return RegExp(r, flags || '')
}

function wordToNumber(s) {
    return numberWords.indexOf(s.toLowerCase())
}

function toStringDictionaryEntry(k, v) {
    return singlequote(k) + ': ' + singlequote(v) + ','
}

function comment(s, lang) {
    return `/* ${s} */`
    return '// ' + s
}

function hasSelector(s) {
    return test(/^[.#]/, s)
}

function isUndefined(x) {
    return x == undefined
}

function isSelector(s) {
    return test(/^[.#][\w-]{1,30}$/, s)
}

function boundary(s) {
    if (isArray(s)) {
        s = ncgRunner(s)
    } else if (isNumber(s)) s = s.toString()

    if (!s.includes('|')) return `\\b${s}\\b`
    return s.startsWith('(')
        ? wrap(s, '\\b')
        : wrap(`(?:${s})`, '\\b')
}

function getVueErrorInfo(e) {
    return e.stack
        .replace(/file.*?(?=\w+\.js)|at invo[^]+/g, '')
        .trim()
    let s = e.stack.replace(/vue.js.+/s)

    let [name, message] = search(/(\w+): *(.*)/, s)
    let regex = /^ *at (\S+) \((.*?):(\d+):(\d+)/gm
    let stack = findall(regex, s)
    let result = stack.map(([caller, file, line, ch], i) => {
        line = Number(line)
        ch = Number(ch)
        if (caller.includes('.')) {
            let [className, method] = caller.split('.')
            return {
                class: className,
                method,
                file,
                line: Number(),
                ch,
            }
        }
        return { caller, file, line }
        return { caller, file, line, ch }
    })
    result[0].message = message
    return result
    return result[0]
}

function hasSpaces(s) {
    return s.includes(' ')
}

function isNull(x) {
    return x == null
}
function toCallableArg(x) {
    return JSON.stringify(x)
    let f = JSON.stringify(x)
    console.log(f)
    if (x === null) return 'null'
    if (x === '') return '""'
    if (isNumber(x)) {
        return x
    }
    if (isString(x)) {
        return quotify(x)
    }
    return stringify(x)
}
function toStringCallable(name, ...args) {
    let argString = args.map(partial(JSON.stringify)).join(', ')
    return name + parens(argString)
}

function uncapitalize(s) {
    return s.replace(/\w/, (x) => x.toLowerCase())
}

function insertBelow(s, key, payload) {
    const regex = '^.*?' + key + '.*'
    return replace(
        regex,
        (x) => {
            const indentation = getIndent(x) + 4
            return x + '\n' + indent(payload, indentation)
        },
        s,
        'm'
    )
}

function linebreak(s) {
    return wrap('-'.repeat(20))
}

function hasNewline(s) {
    return s.trim().includes('\n')
}

function toNumber(val) {
    return isNumber(val) ? Number(val) : val
    if (isString(val) && test(/[\/ ]/, val)) return val
    var n = parseFloat(val)
    return isStringMathExpression(val) || isNaN(n) ? val : n
}

function removeQuotes(s) {
    if (test(/^[\'\"]/, s)) {
        return s.slice(1, -1)
    }
    return s
}

function blockComment(s) {
    return `/* ${s} */`
}

function modularIncrementNumber(current, increment, min, max) {
    if (arguments.length == 2) {
        max = increment - 1
        increment = 1
        min = 0
    }
    if (!current) current = 0
    if (current + increment > max) {
        if (current == max) return min
        return max
    }
    if (current + increment < min) {
        if (current == min) return max
        return min
    }
    return current + increment
}

function unique(a, b) {
    if (isNestedArray(a)) {
        const seen = []
        const store = a.filter((x) => {
            if (seen.includes(x[0])) return false
            seen.push(x[0])
            return true
        })
        return store
    }

    if (b) {
        return Array.from(
            new Set(
                a.filter(
                    (item) => !Array.from(b).includes(item)
                )
            )
        )
    }
    return isArray(a) && a.length > 1
        ? Array.from(new Set(a))
        : a
}

function numbered(text) {
    if (!text) return ''
    let count = 0

    if (isArray(text)) {
        return text
            .map((item, i) => 1 + i + '  ' + item)
            .join('\n')
    }

    function parser(s) {
        return ++count + '  ' + s
    }

    return replace('^', parser, text, 'gm')
}

function getLast(arr, n = -1) {
    return arr[arr.length + n]
}

function find(items, fn, reverse) {
    if (reverse) {
        for (let i = items.length - 1; i >= 0; i--) {
            if (ftest(fn, items[i])) {
                return items[i]
            }
        }
    } else {
        return items.find(fn)
    }
}
function matchall(regex, s) {
    regex = addGFlag(regex)
    let match
    let store = []
    while (exists((match = regex.exec(s)))) {
        store.push(match)
    }
    return store
}

function toggleFunction(a, b, duration) {
    a()
    setTimeout(() => {
        b()
    }, duration)
}

class ErrorWatcher {
    constructor() {
        this.threshold = 20
        this.count = 0
    }
    watch() {
        if (this.count++ > this.threshold) {
            throw new Error('surpasses threshold')
        }
    }
}

function getClassString(x) {
    if (!x) {
        return ''
    }
    let s = x.toString()
    if (s == '[object Object]') {
        return x.constructor.toString()
    }
    return s
}

function getClassMethods(s) {
    return unique(
        findall(/^    (?:async |def )?(\w+)\(/gm, s.toString()),
        ['constructor']
    )
}
function hasSharedKeys(a, b) {
    return (
        intersection(Object.keys(a), Object.keys(b)).length > 0
    )
}
function isPublic(s) {
    return test(/^\w+$/, s)
}

function getClassPropertiesFromString(s) {
    const matches = findall(
        /^    (?:(async|get|set) )?(\w+) *\(/gm,
        s.toString()
    )
    return matches.map(([a, name]) => {
        let type = 'method'
        if (a == 'get') type = 'getter'
        else if (a == 'set') type = 'setter'
        return { type, name }
    })
}
function readableProperties(obj) {
    function runner(obj) {
        if (isFunction(obj)) {
            return obj.nam
        }
        if (
            isSet(obj) ||
            isFunction(obj) ||
            isArray(obj) ||
            isPrimitive(obj)
        )
            return obj
        let keys = Object.keys(obj)
            //let keys = Object.getOwnPropertyNames(obj)
            .filter(isPublic)

        //console.log(keys)
        return keys.reduce((acc, key, i) => {
            const value = obj[key]
            //console.log(value)
            //console.log(key)
            acc[key] = runner(value)
            return acc
        }, {})
    }
    return runner(obj)
}
function getClassProperties(obj) {
    const props = reduce(
        Object.getOwnPropertyNames(obj).filter(isPublic),
        (x) => [x, obj[x]]
    )
    const methods = Object.getOwnPropertyNames(
        Object.getPrototypeOf(obj)
    )
    pop(methods, 'constructor')
    return { name: obj.constructor.name, methods, ...props }

    return Object.getOwnPropertyNames(s)
    console.log(s)
    let match
    let regex =
        /^ *(?:this\.(\w+) *= *(\w+)?|(?:async )?(\w+)\(|get (\w+))/gm
    //let s = vars()
    const storage = new Storage({ unique: 1 })
    while ((match = regex.exec(s))) {
        if (match[3]) {
            storage.add('methods', match[3])
        } else if (match[1]) {
            storage.add('properties', match[1])
        } else if (match[4]) {
            storage.add('properties', match[4])
        }
    }
    storage.pop('methods', 'constructor')
    //console.log(storage.value); throw ''
    return storage.value
}

function findall(regex, s, flags = 'g', filtered = false) {
    if (isString(regex)) regex = RegExp(regex, flags)
    regex = addGFlag(regex, flags)

    let store = []
    let match
    s = s.trim()

    while (exists((match = regex.exec(s)))) {
        //console.log(match)
        if (match.length == 1) {
            store.push(match[0])
        } else if (filtered) {
            store.push(smallify(match.slice(1).filter(exists)))
        } else if (match.length == 2) {
            store.push(match[1])
        } else {
            store.push(match.slice(1))
        }
    }
    return store
}

function smallify(x) {
    return x.length == 0 ? null : x.length == 1 ? x[0] : x
}

function deletef(r) {
    return (s) => {
        return s.replace(r, '')
    }
}
function functiongetter(x) {
    if (isFunction(x)) {
        return x
    }
    if (window.hasOwnProperty(x)) {
        return window[x]
    }
    return eval(parens(x))
}

function removeAllComments(s) {
    /* 
        hi // bye
                // bye
                // hi
    */
    return s.replace(
        /^ *([#]|<!--[^]*?-->|\/\/|\/\*[^]*?\*\/).*\n*/gm,
        ''
    )
}

function getLastWord(x) {
    return search('\\w+$', x)
}

function getSecondWord(x) {
    return search('\\w+ (\\w+)', x)
}

function getFirstWord(x) {
    return search('\\w+', x)
}

function getFirst(x, mode = '') {
    if (isObject(x)) {
        return Object[mode || 'keys'](x)[0]
    }
    if (mode == String) {
        return search(/^\S+/, x)
    }
    if (isString(x)) {
        return search('\\w+', x)
    }

    if (isArray(x)) {
        return x[0]
    }
}

function xsplit(s) {
    if (isArray(s)) {
        return s
    }
    return split(s, ' ')
    return split(s, / +|([,\.])/)
}

function removeAllJavascriptComments(s, mode) {
    return s.replace(/^ *(?:\/\/|\/\*[^]*?\*\/).*\n*/gm, '')
}

function removeJavascriptComments(s, mode) {
    return s
        .replace(/^ *(?:\/\/|\/\*[^]*?\*\/).*\n*/gm, '')
        .trim()
}

function removeComments(s, mode) {
    return s
        .replace(/^ *(\/\/|\/\*[^]*?\*\/).*\n*/gm, '')
        .trim()
    if (mode == 'js')
        return s.replace(/^ *\/\/|\/\*[^]*?\*\/.*\n*/gm, '')
    return s.replace(
        /^ *([#]|<!--[^]*?-->|\/\/|\/\*[^]*?\*\/).*\n*/gm,
        ''
    )
}

function search(regex, s, flags = '') {
    if (isString(regex)) regex = RegExp(regex, flags)

    const match = s.match(regex)
    return matchgetter(match)
}

function matchgetter(match) {
    return !match
        ? null
        : match.length == 1
        ? match[0]
        : match.length == 2
        ? match[1] || match[0]
        : match.slice(1).filter(isDefined)
}

function prepareIterable(data, mode) {
    if (!data) {
        return []
    }
    if (isStorage(data)) {
        return data.store
    }

    if (isNumber(data)) {
        return range(1, data)
    }
    if (isString(data)) {
        return [data]
    }
    if (isClass(data)) {
        return Array.from(data)
    }

    if (isObject(data)) {
        if (mode == Array) mode == 'values'
        else if (mode == Object) mode == 'entries'
        else if (!mode) {
            mode = 'values'
        }
        return Object[mode](data)
    }

    return data

    //if (data.constructor.name == 'IndexedMap')
}

function indent(s, n = 4, tabs = 0) {
    if (!s) return ''
    if (!n) return s
    if (!s.includes('\n')) return toSpaces(n, tabs) + s
    if (isArray(s)) return s.map((x) => indent(x, n))
    return replace('^', toSpaces(n, tabs), s, 'gm')
}

function joined(arr) {
    if (arguments.length > 1) {
        let delimiter = '\n'
        arr = flat(Array.from(arguments))
            .filter(exists)
            .map(String)
        if (test(/^[, .] *$/, getLast(arr))) {
            delimiter = arr.pop()
            return arr.join(delimiter)
        }
    }

    let s = '\n'
    for (let item of arr) {
        s += item
        s += item.includes('\n') ? '\n\n' : '\n'
    }
    return s
}

function getYear(date) {
    if (!date) date = new Date()
    return date.getFullYear()
}

function difference(a, b) {
    a = prepareIterable(a, 'keys')
    b = prepareIterable(b, 'keys')
    return a.filter((x) => !b.includes(x))
}

function errorWrap(fn) {
    return (...args) => {
        try {
            let value = fn(args[0])
            return { value }
        } catch (e) {
            return {
                error: e.stack,
                input: smallify(args),
            }
        }
    }
}

function insertText(s, regex, payload, moreSpaces) {
    regex = '^( *).*?' + regex + '.*'
    let extraSpaces = 0
    return replace(
        regex,
        (original, spaces) => {
            if (original.endsWith('{')) {
                extraSpaces = '    '
            }
            if (moreSpaces) spaces += '    '
            const value = indent(payload, spaces + extraSpaces)
            return original + '\n' + value
        },
        s,
        'm'
    )
}

function isIterable(x) {
    if (!x) return
    if (isString(x)) {
        return false
    }
    return typeof x[Symbol.iterator] === 'function'
    //return isArray(x) || isSet(x)
}

function isVeryDefined(x) {
    return x != null && x != ''
}

function isDefined(x) {
    return x != null
}

function isBoolean(x) {
    return x === true || x === false
}

function addGFlag(regex, flags = '') {
    if (isString(regex)) {
        if (!flags.includes('g')) flags += 'g'
        return new RegExp(regex, flags)
    }
    if (!regex.flags.includes('g')) {
        regex = new RegExp(regex, regex.flags + 'g')
    }
    return regex
}

function isFirst(key, state = $$) {
    if (!state[key]) {
        state[key] = true
        return true
    }
    return false
}

function isWordFragment(s) {
    return test(/^(?:[-a-zA-Z]+)(?: [-a-zA-Z]+)*$/, s)
}

function isWord(s) {
    return test(/^[a-zA-Z]+$/, s)
}

function isPromise(x) {
    return x.constructor.name == 'Promise'
}

function isJsonParsable(s) {
    return /^[{\[]/.test(s)
}

function isRegExp(x) {
    return x.constructor.name == 'RegExp'
}

function isFalse(x) {
    return x === false
}

function isTrue(x) {
    return x === true
}

function isClassObject(x) {
    if (isFunction(x)) {
        return false
    }
    if (isObject(x)) {
        return true
    }
}

function isClass(x) {
    const natives = [
        'String',
        'Function',
        'Number',
        'Object',
        'Array',
        'Set',
        'Promise',
    ]
    return x && !natives.includes(x.constructor.name)
}

function isNode() {
    return typeof window === 'undefined' || window.isNodeWindow
}

function isJson(x) {
    return x.endsWith('.json')
}

function isElement(s) {
    return s.constructor.name.startsWith('HTML')
}

function isInteger(n) {
    console.log(n, 'h')
    return Number.isInteger(Number(n))
}

function isCapitalized(s) {
    return /^[A-Z]/.test(s)
}

function isYesterday(date) {
    return changeDate(datestamp(), -1) == date
}

function isDate(s) {
    return test(/^\d{1,2}[-/]\d{1,2}[-/](?:\d{2}|\d{4})$/, s)
}
function isToday(date) {
    return datestamp() == date
}

function zeroPad(x) {
    return String(x).length == 1 ? '0' + x : x
}

function backspace(s) {
    return s ? s.slice(0, -1) : ''
}

function backspaced(s) {
    return s ? s.slice(0, -1) : ''
}

function indexgetter(arr, index) {
    if (!index) return 0
    if (!isNumber(index)) index = arr.indexOf(index)
    return index
}

function insert(arr, item, index) {
    index = indexgetter(arr, index)
    arr.splice(index, 0, item)
    return arr
}

function getTabs(s) {
    return (search(/^[\t ]*/, s) || '').replace(/    /g, '\t')
}

function getSpaces(s) {
    return search(/^ */, s) || ''
}

function rescape(s, delimiters) {
    const rescapeRE = isString(delimiters)
        ? RegExp(
              `[${delimiters.replace(/[\[\]]/g, '\\$&')}]`,
              'g'
          )
        : /[.\\[*+?()|^${}\[\]]/g
    return s.replace(rescapeRE, '\\$&')
}

function replaceTemplaterHelper(s, ref) {
    if (!s.includes('$')) return s
    let regex = /\$(\d)/g
    return s.replace(regex, (_, x) => {
        return ref[Number(x)]
    })
}

function spicyReplace(regex, rep, s) {
    const parser = (...args) => {
        return spicyTemplater(rep, args.slice(1, -2))
    }
    console.log(prepareRegex(regex))
    return s.replace(prepareRegex(regex), parser)
}

function templaterWithBackup(s, ref, backup, functionArgs) {
    if (!s.includes('$')) return s
    let regex = /\$(\d+(?:\|[a-zA-Z]+)?|\{.*?\})/g
    return runner(s)

    function runner(s, fn) {
        return s.replace(regex, (_, x) => {
            if (x == 'c') {
                return '$c'
            }
            if (x == 0) return s
            if (test(/^{/, x)) {
                x = x.slice(1, -1)
                x = runner(x, quotify)
                x = eval(x)
                return x
            }

            let [n, other] = search(/^(\d+)\|?(\w*)/, x)
            let value = ref[Number(n) - 1]
            if (value == null && other) {
                value = backup[other]
                if (value == null) value = other
            }
            if (isFunction(value)) {
                value = value(...functionArgs)
            }

            return fn ? fn(value) : value
        })
    }
}

function spicyTemplater(s, ref, ...args) {
    if (!s.includes('$')) return s
    let regex = /\$(\d+|\w+|\{.*?\})/g
    return runner(s)

    function runner(s, fn) {
        return s.replace(regex, (_, x) => {
            //console.log([x, 'st'])
            if (x == 'c') {
                return '$c'
            }
            if (x == 0) return s
            if (test(/^{/, x)) {
                x = x.slice(1, -1)
                x = runner(x, quotify)
                x = eval(x)
                return x
            }

            let val = isArray(ref) ? ref[Number(x) - 1] : ref[x]
            if (val == null) val = ''
            if (isFunction(val)) {
                val = val(...args)
                //val = val(x, ...args)
            }
            return fn ? fn(val) : val
        })
    }
}

function reverse(s) {
    if (isArray(s)) {
        return s.reverse()
    }
    if (isObject(s)) {
        return zip(Object.values(s), Object.keys(s))
    }
    if (hasEquals(s)) {
        return split(s, /=/).reverse().join(' = ')
    }
    return split(s).reverse().join('')
}

function katexAttributer(a, b, c) {
    return wrap(`\\${a}{${b}}{${c}}`, '{}')
}

function katexColorer(x, color) {
    return katexAttributer('textcolor', color, x)
}
function latexTemplater(s, ref, regex = '\\w+') {
    const ignore = ['left', 'right', 'frac', 'cdot', 'times']
    const ignoreRE = ignore.join('|')
    if (isArray(ref)) {
        regex = RegExp(ignoreRE + '|' + regex, 'g')
        let count = 0
        return s.replace(regex, (x) => {
            if (x.length > 1 && !isNumber(x)) return x
            let item = ref[count++]
            if (item == null) return x
            if (isColor(item)) {
                return katexColorer(x, item)
            }
            return fparse(item, x)
        })
    }
    if (isObject(ref)) {
        return s.replace(ncg(ref), (x) => {
            let item = ref[x]
            if (isColor(item)) {
                return katexColorer(x, item)
            }
            return item || x
        })
    }
}
function simpleTemplater(s, ref) {
    return s.replace(templaterRE, (_, x) => {
        return isString(ref) ? ref : isArray(ref) ? ref[Number(x) - 1] : ref[x]
    })
}
function templater(s, ref, keep) {
    if (!s.includes('$')) {
        if (isObject(ref)) {
            return dreplace2(s, ref)
        }
        return s
    }

    if (!ref)
        return s.replace(/\$\{(.*?)\}/g, (_, x) => eval(x))
    let regex = /\$(\w)/g
    if (isPrimitive(ref)) {
        ref = [ref]
    } else {
        regex = /\$(\w+)/g
    }

    let functionals = []
    let offset = s.includes('$0') ? 0 : 1
    let value = s.replace(regex, (_, x) => {
        if (x == 'c') return '$c'
        let val = isArray(ref)
            ? ref[Number(x) - offset]
            : ref[x]
        if (val == null) {
            return keep ? '$' + x : ''
        }
        if (isFunction(val)) {
            functionals.push(val)
            return '###'
        }
        return val
    })

    if (exists(functionals)) {
        let parts = value.split(/###(?:\(.*?\))?/)
        return (a, b, c) => {
            let s = ''
            for (let i = 0; i < parts.length; i++) {
                let part = parts[i]
                s += part
                if (i < parts.length - 1) {
                    s += functionals[i](a)
                }
            }
            return s
        }
    }
    return value
}

function hasCaptureGroup(s) {
    return test(/[^\\]\((?!\?)/, s)
}

function getIndent(s) {
    if (isNumber(s)) return s
    const match = s.match(/^[\t ]*/g)
    if (!match) return 0
    return match[0].split('').reduce((acc, item, i) => {
        return (acc += item == '\t' ? 4 : 1)
    }, 0)
}

function identity(...args) {
    return args.length == 1 ? args[0] : args
}

function identity(s) {
    return s
}

function trim(s) {
    return s.trim()
    if (s.trim().length == '') return s
}
class AssertionErrorHandler {
    constructor(fn) {
        try {
            fn()
        } catch (e) {
            console.log([e.name, e.line])
        }
    }
}
class AssertionError extends Error {
    constructor(x) {
        super()
        const { name, line } = getCaller('assert')
        this.name = name
        this.line = line
    }
}

function parens(s) {
    return '(' + s + ')'
}

function len(x) {
    if (!exists(x)) {
        return 0
    }
    if (isNumber(x))
        return x.toString().replace(/0?[-.]/g, '').length
    return x.length || Object.keys(x).length || 0
}

function hasNumber(x) {
    return (
        (isString(x) && test(/\d/, x)) || typeof x == 'number'
    )
}

function sum(items, fn) {
    if (isString(items)) {
        return items + fn
    }
    if (isArray(items)) {
        return items.reduce(
            (acc, item, i) => (acc += fn ? fn(item, i) : item),
            0
        )
    }
}

function recursiveFlat(...args) {
    const store = []
    function runner(args) {
        for (let arg of args) {
            if (isArray(arg)) {
                runner(arg)
            } else {
                store.push(arg)
            }
        }
    }
    runner(args)
    return store
}
function flat(arr) {
    const store = []
    for (let item of arr) {
        push(store, item)
    }
    return store
}

function doublequote(s) {
    return '"' + s + '"'
}

function delta(a, b) {
    return Math.abs(a - b)
}

function toVariable(name, value, lang, prefix = 'var ') {
    if (arguments.length == 1) {
        value = name
        lang = 'js'
        switch (type(value)) {
            case 'String':
                name = 's'
                break

            case 'Array':
                name = 'arr'
                break

            case 'Object':
                name = 'obj'
                break

            case 'Number':
                name = 'n'
                break
        }
    }
    //console.log(value)
    const payload = isString(value)
        ? isJsonParsable(value)
            ? value
            : quotify(
                  value
                      .replace(/\`/g, '\\`')
                      .replace(/\$\{/g, '\\$\\{')
              )
        : toStringArgument(value)

    return prefix + name + ' = ' + payload
}

function quotify(s, mode = '`') {
    if (mode == '`') return '`' + s + '`'
    if (mode == "'") return "'" + s + "'"
    if (mode == '"') return '"' + s + '"'
    return '"' + s + '"'
}

function tail(s) {
    return getLast(s.split('/')).replace(/^\W+/, '')
}

function bindObject(state, object, key) {
    if (!exists(object)) {
        return
    }

    if (key) {
        if (isFunction(object)) {
            store[key] = object.bind(state)
        }
        const store = {}
        for (let [k, v] of Object.entries(object)) {
            store[k] = v.bind(state)
        }
        return
    }

    /* hmm ... this is for the comment part */
    for (let [k, v] of Object.entries(object)) {
        if (isFunction(v)) {
            state[k] = v.bind(state)
        } else {
            state[k] = v
        }
    }
}

function initializeStateVariable(state, key, value) {
    if (!state.hasOwnProperty(key)) {
        state[key] =
            arguments.length == 4
                ? {}
                : key.endsWith('s')
                ? []
                : null
    }
    const f = type(state[key])
    switch (f) {
        case 'Set':
            return state[key].add(value)
        case 'Array':
            return state[key].push(value)
        case 'Object':
            return (state[key][arguments[2]] = arguments[3])
        default:
            state[key] = value
    }
}

function bind(state, key, arg) {
    if (arguments.length == 3) {
        if (!arg) return
        if (isFunction(arg)) {
            state[key] = arg.bind(state)
        }

        state[key] = map(arg, (x) => x.bind(State))
    }
    return state[key].bind(state)
}
function fparse(x, ...args) {
    if (!x) return
    const value = isFunction(x) ? x(...args) : x
    if (value === null) {
        return args[0] || x
    }
    return value
}
class Cacheold extends StandardObject {
    constructor() {
        super()
    }

    get(key, fallback) {
        if (!this.has(key)) {
            this.store[key] = fparse(fallback, key)
        }
        return this.store[key]
    }

    set(key, value) {
        if (isObject(key)) {
            this.store = key
        } else {
            this.store[key] = value
            return value
        }
    }

    clear() {
        this.store = {}
    }
}

function getLongest(arr, measure = len, mode = Number) {
    let currentLength = 0
    let currentItem = null
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i]
        let length = parseFloat(measure(item))
        if (length > currentLength) {
            currentLength = length
            currentItem = item
        }
    }
    if (mode == Number) {
        return currentLength
    } else {
        return currentItem
    }
}

function splitSpellcheck(s, dict) {
    if (isNumber(s)) {
        return s
    }
    return split(s)
        .map((x) => dict[x] || x)
        .join(' ')
}
function dreplacef(a, b) {
    if (isObject(a)) {
        let dict = Object.assign({}, ...arguments)

        const symbols = ['*', '[', ']', '{', '}', '. ', ' = ?']
        const filter = (x) => symbols.includes(x)
        const [a, b] = partition(Object.keys(dict), filter)
        const rA = exists(a)
            ? `(?:${a.map((x) => '\\' + x).join('|')})|`
            : ''
        const rB = `\\b(?:${b.join('|')})\\b`
        const _regex = rA + rB
        const regex = RegExp(_regex, 'g')

        return (s) =>
            s.replace(regex, (x, offset, s) => {
                if (/[@$]/.test(s[offset - 1])) return x
                return dict[x]
            })
    }
    return (s) => s.replace(a, (_, x) => b[x] || x)
}
function dreplace(
    s,
    dict,
    regexTemplate = '\\b(?:$1)\\b',
    flags = 'g'
) {
    let escape
    if (regexTemplate === null) {
        regexTemplate = '(?:$1)'
    } else if (regexTemplate == 'ge') {
        flags = regexTemplate
        regexTemplate = '(?:$1)'
    } else if (regexTemplate == 'ge') {
        flags = regexTemplate
        regexTemplate = '(?:$1)'
    } else if (regexTemplate.length < 5) {
        flags = regexTemplate
        regexTemplate = '\\b(?:$1)\b'
    }
    if (flags.includes('e')) {
        escape = true
        flags = flags.replace('e', '')
    }

    if (flags.includes('b')) {
        flags = flags.replace('b', '')
        regexTemplate = '\\b(?:$1)\\b'
    }

    const regex = ncg(regexTemplate, dict, true)

    function fixB(x) {
        if (isCapitalized(x)) {
            value = dict[x.toLowerCase()]
            return capitalize(value)
        }
        return dict[x]
    }
    const parser = hasCaptureGroup(regexTemplate)
        ? (_, x) => fixB(x)
        : (x) => fixB(x)

    return replace(regex, parser, s, flags)
}

function ncg(template, ref, escape) {
    if (typeof template == 'object' && !ref) {
        return regexTemplater(/\b(?:$1)\b/g, template)
    }

    if (template == boundary) {
        return regexTemplater(/\b(?:$1)\b/g, ref)
    }

    if (isRegExp(template)) {
        return regexTemplater(template, ref)
    }
    if (template === '') template = '(?:$1)'
    if (arguments.length == 1) {
        return '(?:' + ncgRunner(template) + ')'
    }

    if (!ref && isIterable(template)) {
        return '\\b(?:' + ncgRunner(template, escape) + ')\\b'
    } else if (
        !isPrimitive(ref) &&
        ref[0] &&
        !isPrimitive(ref[0])
    ) {
        let value = templater(
            template,
            ref.map((el) => ncgRunner(el, escape))
        )
        if (escape) return RegExp(value, escape)
        return value
    } else {
        return templater(template, ncgRunner(ref, escape))
    }
}

function ncgRunner(ref, escape) {
    return isBoolean(escape)
        ? prepareIterable(ref, 'keys').map(rescape).join('|')
        : prepareIterable(ref, 'keys').join('|')
}

function filterObjectHelper(items, fn) {
    if (isFunction(fn)) {
        if (getParameters(fn).length == 2) {
            return Object.entries(items).filter(([a, b]) => {
                return fn(a, b)
            })
        } else {
            return Object.entries(items).filter(([a, b]) => {
                return fn(b)
            })
        }
    } else if (isArray(fn)) {
        return Object.entries(items).filter(([a, b]) => {
            return fn.includes(a)
        })
    }
}

function filter(items, fn, mode) {
    if (isObject(items)) {
        const value = filterObjectHelper(items, fn)

        return mode == 'keys'
            ? value.map((x) => x[0])
            : mode == 'values'
            ? value.map((x) => x[1])
            : mode == Array
            ? value
            : toDictionary(value)
    }
    if (isArray(items)) {
        if (isIterable(fn)) {
            fn = prepareIterable(fn, 'keys')
            return items.filter((x) => fn.includes(x))
        } else if (!fn) {
            fn = exists
        } else if (!isFunction(fn)) {
            if (fn == 'skip') {
                fn = (x) => !x.hasOwnProperty('skip')
            } else {
                fn = testf(fn)
            }
        }
        return items.filter(fn)
    }
}

function filterObject(items, fn, mode) {
    const value = Object.entries(items).filter((x) => fn(...x))
    if (mode == 'keys') return value.map((x) => x[0])
    if (mode == 'values') return value.map((x) => x[1])
    return value.reduce(
        (acc, [a, b]) => ({ ...acc, [a]: b }),
        {}
    )
}

function oldfilterObject(items, fn) {
    function reducer(items, gn) {
        const store = {}
        for (let [a, b] of prepareIterable(items, 'entries')) {
            const value = gn(a, b)
            if (exists(value)) {
                if (value.length == 2 && isArray(value)) {
                    store[value[0]] = value[1]
                } else {
                    store[a] = value
                }
            }
        }
        return store
    }
    return getParameters(fn).length == 1
        ? reducer(items, (k, v) => (fn(v) ? v : null))
        : reducer(items, (k, v) => (fn(k, v) ? v : null))
}

function filtered(items, fn) {
    if (isObject(items)) {
        return reduce(items, (k, v) => (fn(k, v) ? v : null))
    }

    items = Array.from(items)
    if (isString(fn))
        return items.filter(
            (x) => exists(x) && test(fn, x, 'i')
        )
    if (isFunction(fn)) return items.filter(fn)
    if (isArray(fn)) return items.filter((x) => !fn.includes(x))
}

function getIndentAndLine(s) {
    if (isNewLine(s)) {
        return [null, null, s.length]
    }
    return [roundToFour(getIndent(s)), s.trim()]
}

function capitalize(s) {
    return s.replace(/^['"]?[a-zA-Z]/, (x) => x.toUpperCase())
}

function singlequote(s) {
    return "'" + s + "'"
}

function ftestFactory(x) {
    assert(x)
    if (!x) return
    if (isFunction(x)) {
        return x
    }
    if (isRegExp(x)) {
        return testf(x)
    }
}

function ftest(x, s, flags = 'i') {
    if (isArray(x)) {
        for (let item of x) {
            if (ftest(item, s, flags)) {
                return true
            }
        }
    }

    if (isFunction(x)) {
        return x(s)
    }

    if (s === x) {
        return true
    }

    if (s == '' && x.toString() == '/^$/') {
        return true
    }

    return test(x, s, flags)
}

function mapObject(a, b) {
    if (isObject(b)) {
        return reduce(a, (k, v) => {
            return b[k] ? [k, b[k]] : null
        })
    }
}
function mapConditional(a, b, c) {
    return (x, i, arr) => {
        if (isRegExp(a)) {
            let match = x.match(a)
            if (match) {
                if (match.length == 2) {
                    if (isString(b)) {
                        return templater(b, match[1])
                    }
                    return b(match[1], i)
                } else {
                    if (isString(b)) {
                        return templater(b, x)
                    }
                    return b(x, i)
                }
            } else if (c) {
                if (isString(c)) {
                    return templater(c, x)
                }
                return c(x, i, arr)
            } else {
                return x
            }
        }

        if (isFunction(a)) {
            if (a(x)) {
                if (isString(b)) {
                    return templater(b, x)
                }
                return b(x)
            } else if (c) {
                if (isString(c)) {
                    return templater(c, x)
                }
                return c(x, i, arr)
            } else {
                return x
            }
        }

        if (isString(a)) {
            throw new Error(
                'must be regex or function for mapconditional'
            )
        }
    }
}

function merge(a, b) {
    if (!b) return a
    if (!a) return b
    if (isObject(a)) {
        return Object.assign({}, ...arguments)
    }
    if (isArray(a)) {
        const store = []
        map(arguments, (x) => push(store, x, true))
        return store
        return push(a, b, true)
    }
    if (isString(a)) {
        return a + b
    }
    return b
}
function mergeAll(...args) {
    args = args.filter(exists)
    let first = args[0]

    if (args.length == 1) {
        return args[0]
    }

    if (isObject(first)) {
        const store = {}
        for (let arg of args) {
            Object.assign(store, arg)
        }
        return store
    }

    if (isArray(first)) {
        for (let arg of args) {
            if (arg)
                isArray(arg)
                    ? first.push(...arg)
                    : first.push(arg)
        }
        return first
    }

    if (isString(first)) {
        if (first.includes('\n')) return args.join('\n')
        if (first.includes(' ')) return args.join(' ')
        return args.join('\n')
    }

    if (isNumber(first)) {
        return sum(args.map(Number))
    }
}

function tryval(s, ...args) {
    try {
        if (isFunction(s)) {
            return {
                value: s(...args),
                input: smallify(args),
            }
        }
        return {
            input: smallify(s),
            value: eval(s),
        }
    } catch (e) {
        return {
            input: smallify(s),
            error: getDetailedErrorInfo(e),
        }
    }
}

function shuffle(arr, copyIt) {
    const ref = isTrue(copyIt) ? copy(arr) : Array.from(arr)
    let m = arr.length
    while (m) {
        let i = ~~(Math.random() * m--)
        let t = ref[m]
        ref[m] = ref[i]
        ref[i] = t
    }
    return ref
}
class Clock {
    finish() {
        this._stop = true
        clearTimeout(this.timerID)
        this.onEnd()
    }
    constructor(options) {
        this.increment = 1000
        this.speed = 1
        this.onTick = console.log
        const kt = (x) => {
            if (x == 'end' || x == 'start' || x == 'tick') {
                return 'on' + capitalize(x)
            }
            return x
        }
        Object.assign(this, edit(options, kt))
        this.delta = this.increment / this.speed
        if (this.duration <= 100) this.duration *= 1000
        assert(this.duration)
        if (options.autoStart) this.start()
    }
    pause() {
        this._pause = true
    }
    async start() {
        if (this._pause) {
            this._pause = false
            this.count += 1
        } else {
            this.count = 0
            this._stop = false
        }
        return await this.runner()
    }

    stop() {
        this._stop = true
    }
    async resume() {
        this._stop = false
        await this.runner()
    }

    runner() {
        if (this._onStart) {
            this._onStart()
            this._onTick()
        } else {
            this._onTick()
        }

        return new Promise((resolve, reject) => {
            const runner = () => {
                if (this.isDone()) {
                    clearTimeout(this.timerID)
                    if (this._onEnd) {
                        this._onEnd()
                    }
                    resolve()
                } else if (this._pause) {
                    clearTimeout(this.timerID)
                    resolve()
                } else {
                    this.count += 1
                    this.timerID = setTimeout(() => {
                        if (this._onTick) this._onTick()
                        runner()
                    }, this.delta)
                }
            }

            runner()
        })
    }

    at(n, fn) {
        let current = this._onTick
        this._onTick = () => {
            this.count == n ? this.handle(fn(this)) : current()
        }
    }

    set onTick(fn) {
        this._onTick = () => this.handle(fn(this.timeLeft))
        //this._onTick = () => this.handle(fn(this.count, this.timeLeft, this.duration))
    }
    set onStart(fn) {
        this._onStart = () => fn(this.timeLeft)
    }

    set onEnd(fn) {
        this._onEnd = () => fn(this.timeLeft)
    }
    get onEnd() {
        return this._onEnd
    }

    isDone() {
        return this.count >= this._duration || this._stop
    }
    get elapsed() {
        return this.count
    }
    get timeLeft() {
        return this._duration - this.count
    }
    get _duration() {
        return Math.floor(this.duration / 1000)
    }

    handle(result) {
        if (result === 'DONE') {
            this._stop = true
        } else if (isNumber(result)) {
            this.duration += result * 1000
        }
    }
}

function addExtension(file, ext = 'js') {
    if (getExtension(file)) {
        return file
    }
    return file + '.' + ext
}

function getExtension(file) {
    return search(/\.(\w+)$/, file)
}

function sortf(fn) {
    return function runner(a, b) {
        if (reverse) return Number(fn(b)) - Number(fn(a))
        return Number(fn(a)) - Number(fn(b))
    }
}
function sorted(items, fn, reverse = 0, implicitSecond = 0) {
    const defaultObjectSort = (s) => s[1]
    const defaultNumberSort = (s) => s
    let asObject = false

    if (items.store) {
        items = Object.entries(items.store)
        asObject = true
    } else if (isObject(items)) {
        items = Object.entries(items)
        asObject = true
    }

    if (!fn) {
        fn = isDoubleIterable(items)
            ? defaultObjectSort
            : isNumber(items[0])
            ? defaultNumberSort
            : char2n
    } else if (implicitSecond && asObject) {
        fn = ([k, v]) => fn(v)
    }

    function runner(a, b) {
        if (reverse) return Number(fn(b)) - Number(fn(a))
        return Number(fn(a)) - Number(fn(b))
    }

    items.sort(runner)
    return asObject ? reduce(items) : items
}

function n2char(n) {
    return String.fromCharCode(n + 97)
}
function char2n(ch) {
    return ch.charCodeAt(0) - 97
}

function newlineIndent(s, n = 4) {
    if (!s) {
        return ''
    }
    s = isArray(s) ? s.join('\n') : s
    return wrap(indent(s.replace(/^\n+/, '').trimEnd(), n))
}

class Storage {
    [Symbol.iterator]() {
        this.items = this.entries
        this.index = 0
        return this
    }
    init(names) {
        for (let name of names) {
            this.add(name)
        }
    }
    next() {
        const value = this.items[this.index++]
        const done = this.index > this.items.length
        return {
            value,
            done,
        }
    }
    constructor() {
        this.store = {}
        this.watcher = new Watcher()
        const options = {
            _mode: Array,
            unique: false,
            delimiter: '\n',
            mergeArray: true,
        }
        Object.assign(this, options)
        if (arguments.length == 2) {
            this.store = arguments[0]
            Object.assign(this, arguments[1])
        } else if (arguments.length == 0) {
            Object.assign(this, options)
        } else if (arguments.length == 1) {
            if (hasSharedKeys(arguments[0], options)) {
                Object.assign(this, arguments[0])
            } else if (arguments[0] == Number) {
                this._mode = Number
            } else {
                this.store = arguments[0]
            }
        }
        //console.log(this)
    }

    delete(k) {
        delete this.store[k]
    }
    get value() {
        return this.store
    }
    get keys() {
        return Object.keys(this.store)
    }
    get values() {
        return Object.values(this.store)
    }
    get entries() {
        return Object.entries(this.store)
    }

    get(k) {
        if (arguments.length > 1) {
            return (
                (this.store[arguments[0]] &&
                    this.store[arguments[0]][arguments[1]]) ||
                ''
            )
        }
        return this.store[k] || this.fallback
    }

    get fallback() {
        switch (this._mode) {
            case Array:
                return []
            case Number:
                return 0
            case String:
                return ''
            case Object:
                return {}
        }
    }

    has(k) {
        return this.store.hasOwnProperty(k)
    }
    forEach(fn) {
        return Object.entries(this.store).forEach(([k, v]) =>
            fn(k, v)
        )
    }
    reset(k) {
        if (!k) {
            this.store = {}
            return
        }

        switch (this._mode) {
            case Array:
                this.store[k] = []
                break
            case Number:
                this.store[k] = 0
                break
            case String:
                this.store[k] = ''
                break
            case Object:
                this.store[k] = {}
                break
            case null:
                this.store[k] = null
                break
        }
    }

    pop(k, v) {
        if (v) {
            return pop(this.store[k], v)
        } else {
            return pop(this.store, k)
        }
    }

    map(k, fn) {
        this.store[k] = this.get(k).map(fn)
    }

    set(k, v) {
        this.store[k] = v || null
    }

    toString() {
        return stringify(this.store)
    }
    add(k, v) {
        if (k == null) return
        if (arguments.length == 3) {
            this.addObject(...Array.from(arguments))
            return
        }

        switch (this._mode) {
            case Array:
                this.addArray(k, v)
                break
            case Object:
                this.addObject(...Array.from(arguments))
                break
            case String:
                this.addString(k, v)
                break
            case Number:
                return this.addNumber(k, v)
                break
            default:
                this.set(k, v)
                break
        }

        return this.get(k)
    }

    addNumber(k, v) {
        v = v == null ? 1 : Number(v)
        return this.store.hasOwnProperty(k)
            ? (this.store[k] += v)
            : (this.store[k] = v)
    }

    addString(k, v) {
        if (!exists(v)) {
            return
        }
        this.store[k]
            ? (this.store[k] += this.delimiter + v)
            : (this.store[k] = v)
    }

    addArray(k, v) {
        if (!exists(v)) {
            return
        }
        if (this.unique && this.get(k).includes(v)) {
            return
        }

        if (isArray(v) && this.mergeArray) {
            this.store[k]
                ? this.store[k].push(...v)
                : (this.store[k] = v)
        } else {
            this.store[k]
                ? this.store[k].push(v)
                : (this.store[k] = [v])
        }
    }

    addObject(parent, child, value) {
        if (!exists(value)) {
            return
        }
        if (!this.store[parent]) this.store[parent] = {}
        this.store[parent][child] = value
    }
}

function modularIncrement(arr, item, increment = 1) {
    if (isNumber(arr)) {
        return modularIncrementNumber(
            item,
            increment,
            arguments[3] || 0,
            Number(arr) - 1
        )

        return modularIncrementNumber(
            Number(arr),
            item,
            increment,
            arguments[3] || 9
        )
    }
    if (isFunction(increment)) {
        return modularIncrementFn(arr, item, increment)
    }
    if (increment == '+') increment = 1
    else if (increment == '-') increment = -1

    if (isObject(arr)) {
        arr = Object.keys(arr)
    }

    if (!item) {
        return arr[0]
    }
    const i = arr.indexOf(item)
    if (i < 0) return arr[0]

    let newIndex

    if (i + increment < 0) {
        newIndex = arr.length - 1
    } else {
        newIndex = (i + increment) % arr.length
    }

    const p = arr[newIndex]
    return p
}

function modularIncrementFn(arr, index, dir = 1) {
    index = indexgetter(arr, index)

    if (dir > 0) {
        for (let i = index; i < arr.length; i++) {
            let item = arr[i]
            if (fn(item)) return item
        }

        for (let i = 0; i < index; i++) {
            let item = arr[i]
            if (fn(item)) return item
        }
    } else {
        for (let i = index; i > 0; i--) {
            let item = arr[i]
            if (fn(item)) return item
        }

        for (let i = items.length - 1; i > index; i--) {
            let item = arr[i]
            if (fn(item)) return item
        }
    }

    return null
}

function mreplaceObject(o) {}
function mreplace(
    regex,
    replacement,
    s,
    flags = 'g',
    singular = false
) {
    if (arguments.length == 1) {
        return mreplaceObject(regex)
    }

    if (arguments.length == 2) {
        replacement = ''
        s = arguments[1]
    }

    if (arguments.length == 3 && arguments[2] == true) {
        replacement = ''
        s = arguments[1]
        singular = arguments[2]
    }

    if (!regex.flags || !flags.includes('g')) singular = true

    const store = []
    const sliceBy = hasCaptureGroup(regex) ? 1 : 0

    function parser(...args) {
        args = args.slice(sliceBy, -2).filter((x) => x != null)
        store.push(smallify(args))
        return isString(replacement)
            ? replacement
            : replacement(...args)
    }

    const text = replace(regex, parser, s, flags)
        .replace(/^\n+/, '')
        .trimEnd()

    if (singular) return [text, smallify(store)]
    return [text, store]
}
//console.log(mreplace(/hi/, 'hi tom'))

function sleep(delay = 3000) {
    delay = toMilliseconds(delay)
    return new Promise((resolve) => setTimeout(resolve, delay))
}

function parseJSON(s, functionStringRevive) {
    if (/^[\d/]+$/.test(s)) {
        return Number(s)
    }
    return isJsonParsable(s)
        ? JSON.parse(s, functionStringRevive)
        : s
}

function splitonce(s, delimiter = '\\s+') {
    if (!s) {
        return ['', '']
    }
    if (isArray(s)) return [s[0], s.slice(1)]
    if (isRegExp(delimiter)) {
        delimiter = delimiter.source
    } else {
        delimiter = wrap(delimiter, ' *')
    }

    let regex = '^(.*?)' + delimiter + '([^]+)$'
    return search(regex, s) || [s, '']
}

function pop(arr, key, fallback) {
    if (isObject(arr)) {
        if (!key in arr) return fallback
        let value = arr[key]
        delete arr[key]
        return value
    }

    if (isArray(arr)) {
        const index = isFunction(key)
            ? arr.findIndex(key)
            : isNumber(key)
            ? key
            : arr.indexOf(key)
        if (index < 0) {
            if (fallback) {
                return pop(arr, fallback)
            } else {
                return
            }
        } else {
            return arr.splice(index, 1)
        }
    }
}

function fill(arr, n) {
    while (arr.length <= n) {
        arr.push(null)
        counter()
    }
}

function splitOnceReverse(s, deli) {
    if (isArray(s)) {
        return [s.slice(0, -1), getLast(s)]
    }
    const items = s.split(deli)
    return [items.slice(0, -1), getLast(items)]
}
function split(s, regex = / +/, flags = '') {
    if (regex == '') return s.trim().split('')
    if (isNumber(s) && arguments.length == 1) {
        return s.toString().split('').map(Number)
    }

    if (isArray(s)) {
        let temp = []
        let big = []
        for (let i = 0; i < s.length; i++) {
            let item = s[i]
            if (test(regex, item)) {
                big.push(temp)
                temp = []
                //return [s.slice(0, i), s.slice(i + 1)]
            } else {
                temp.push(item)
            }
            //if (i == s.length - 1) {
            //return [s, null]
            //}
        }
        if (exists(temp)) {
            big.push(temp)
        }
        return big
    }
    if (isNumber(regex))
        return [s.slice(0, regex), s.slice(regex)]
    regex = isString(regex) ? regex : regexed(regex, flags)
    return s.trim().split(regex).filter(exists).map(trim)
}

function regexed(regex, flags = '') {
    if (regex == '.') return regex
    const addMultiLine = (x) =>
        /^.?\^/.test(regex) ? x + 'm' : x
    return isString(regex)
        ? RegExp(regex, addMultiLine(flags))
        : regex
}
function paired(list, mode = Array) {
    const store = mode == Object ? {} : []
    const start = list[0] == '' ? 1 : 0
    for (let i = start; i < list.length - 1; i += 2) {
        if (mode == Object) store[list[i]] = list[i + 1]
        else {
            store.push([list[i], list[i + 1]])
        }
    }
    return store
}

function toUpperCase(s) {
    return s.toUpperCase()
}

function depluralize(s) {
    return s.replace(/s$/, '')
}

function intersects(a, b) {
    a = prepareIterable(a, 'keys')
    b = prepareIterable(b, 'keys')
    return b.some((x) => a.includes(x))
}

function intersection(a, b) {
    return (
        a.filter((x) => b.includes(x)) ||
        b.filter((x) => a.includes(x))
    )
}

function shared(a, b) {
    return a.filter((x) => b.includes(x))
}

function changeDate(s, increment) {
    if (!increment) return s
    return s.replace(
        /-\d+/,
        (x) => '-' + zeroPad(Number(x.slice(1)) + increment)
    )
}

function sortByDependencies(items, reducer, ref) {
    const dependencies = items.reduce((acc, item, i) => {
        acc[item] = isFunction(reducer)
            ? reducer(item)
            : findall(reducer, item)
        return acc
    }, {})

    const keys = Object.keys(dependencies)
    const seen = new Set()
    const result = []
    let i
    let item
    let length

    do {
        length = keys.length
        i = 0
        while (i < keys.length) {
            if (
                dependencies[keys[i]].every(
                    Set.prototype.has,
                    seen
                )
            ) {
                item = keys.splice(i, 1)[0]
                result.push(item)
                seen.add(item)
                continue
            }
            i++
        }
    } while (keys.length && keys.length !== length)

    return ref ? result.map((key) => ref[key]) : result
}

function copy(x) {
    // what could go wrong with this?
    return JSON.parse(JSON.stringify(x))
}

function toDashCase(s, ...args) {
    if (!s) return
    let prefix = ''
    if (/^[A-Z]{2}/.test(s)) {
        prefix = s[0] + '-'
        s = s.slice(1)
    }
    return [
        prefix +
            s.replace(/[a-z][A-Z]|\W/g, (x) => {
                return x.length == 1 ? '-' : x[0] + '-' + x[1]
            }),
        ...args,
    ]
        .join('-')
        .toLowerCase()
}

function toSnakeCase(s) {
    if (s.includes(' ')) {
        return s.replace(/ /g, '-').toLowerCase()
    }
    return s
        .replace(/[a-z][A-Z]/g, (x) => x[0] + '-' + x[1])
        .toLowerCase()
}

function toStringObject(x, quotes) {
    function parseObj(obj) {
        let s = '{\n'
        for (let [k, v] of Object.entries(obj)) {
            s += indent(k + ': ' + parse(v)) + ',\n'
        }
        s += '}'
        return s
    }

    function parseArr(arr) {
        let s = '[\n'
        for (let item of arr) {
            s += indent(parse(item)) + ',\n'
        }
        s += ']'
        return s
    }

    function parsePrimitive(s) {
        if (s == '') return "''"
        const known = []
        if (isNumber(s)) {
            return s
        }
        if (quotes) {
            return singlequote(s)
        }
        if (known.includes(s)) return s
        return s.toString()
    }

    function parse(s) {
        if (isObject(s)) {
            return parseObj(s)
        }

        if (isArray(s)) {
            return parseArr(s)
        }

        if (s == null) return 'null'

        return parsePrimitive(s)
    }

    return parse(x)
}

function toArgument(s) {
    if (!isString(s)) return s
    s = s.trim()

    if (s == "''") return ''
    if (isQuote(s)) {
        return s.slice(1, -1)
    }
    if (s == '0') return 0
    if (isNumber(s)) return Number(s)
    if (s == 'false') return false
    if (s == 'true') return true
    if (s == 'null') return null
    if (s == 'Number') return Number
    if (s == 'String') return String
    if (isJsonParsable(s)) {
        return eval(s)
    }
    return s
}

function toString(x) {
    if (isObject(x)) return JSON.stringify(x, null, 2)
    if (isArray(x)) return join(x)
    if (isRegExp(x)) return x.source
    return x.toString()
}

function toAttr(a, b) {
    return a + '=' + doublequote(b)
}
function toPascal(s) {
    return capitalize(toCamelCase(s))
}

var allCapitals = testf(/^[A-Z]+$/)
function toCamelCase(s) {
    if (hasCamelCase(s)) return s
    let f = (x) => x.slice(1).toUpperCase()
    s = s.trim().replace(/[- ]\w/g, f)
    if (/^[A-Z]+$/.test(s)) {
        return s
    }
    return uncapitalize(s)
}

function toggleVue(state, key, value, duration = 1000) {
    let from = state[key]
    let to = value
    toggle(state, key, from, to, duration)
}
function toggle(state, key, from, to, duration = 750) {
    let value
    if (arguments.length == 2) {
        value = opposite(state[key])
        state[key] = value
        return value
    }

    if (arguments.length == 3) {
        if (isFunction(state)) {
            return toggleFunction(...arguments)
        }
        if (isBoolean(state[key])) {
            from = state[key]
            to = !state[key]
            duration = arguments[2]
        } else {
            to = from
            from = state[key]
        }
    }

    state[key] = to
    setTimeout(() => {
        state[key] = from
    }, duration)
}

function toDictionary(items, kt, vt) {
    if (!exists(items)) {
        if (kt === null) {
            return null
        }
        return {}
    }
    if (!isNestedArray(items)) items = partition(items)
    return reduce(items, (k, v) => [
        kt ? kt(k) : k,
        vt ? vt(v) : v,
    ])
}

function toLiteralArray(s) {
    return s.slice(1, -1).split(',')
}

function toInteger(x) {
    return Math.round(x)
}

const roygbiv = [
    'red',
    'orange',
    'yellow',
    'green',
    'blue',
    'indigo',
    'violet',
    'white',
    'black',
    'purple',
    'pink',
]

function numberWord(n) {
    return numberWords[n]
}

function numberToWord(n) {
    return numberWords[n]
}

function hasComma(s) {
    return s.includes(',')
}

function hasLetter(s) {
    return test(/[a-zA-Z]/, s)
}

function hasWord(s) {
    return /[a-zA-Z]{3,}/.test(s)
}

function hasLookBehind(s) {
    return test(/\(\?\</, s.toString())
}

function hasLookAround(s) {
    return test(/\(\?\</, s.toString())
}

function endsWithWord(s) {
    return test(/\w$/, s)
}
function endsWithNumber(s) {
    return test(/\d+$/, s)
}

function wordToNumber(s) {
    return numberWords.indexOf(s.toLowerCase())
}

function stringcall(fn, ...args) {
    if (isFunction(fn)) {
        fn = fn.name
    }
    function f(s) {
        if (isNumber(s)) {
            return s
        }
        if (hasNewline(s)) {
            return quotify(s)
        }
        return s
    }
    return (
        fn +
        parens(
            map(gatherArgs(args).filter(exists), f).join(', ')
        )
    )
}

function dedent(s, unit) {
    if (unit) {
        return replace('^' + unit, '', s)
    }
    s = s.trimEnd().replace(/^\n+/, '')
    const spaces = getSpaces(s)
    return replace('^' + spaces, '', s)
}

function getWords(
    s,
    { mode = 's', min = 3, max = 50, ignore = 0 } = {}
) {
    let numbers = ''
    let extra = ''

    if (mode == 'css') {
        extra += '-'
    }
    let rString = `[a-zA-Z${extra}]{${min},${max}}${numbers}`
    if (mode == 'code') {
        rString = '[a-zA-Z]\\w+'
    }

    const regex = RegExp(rString, 'g')
    const value = unique(s.match(regex) || [])
    return ignore ? filter(value, ignoref(ignore)) : value
}
function ignoref(x) {
    if (isArray(x)) {
        return function lambda(s) {
            return !x.includes(s)
        }
    }

    if (isString(x)) {
        return function lambda(s) {
            return !test(x, s)
        }
    }

    return function lambda(item, i) {
        return !x.test(item)
    }
}

function unzip(a) {
    return a.reduce(
        (acc, [x, y], i) => {
            acc[0].push(x)
            acc[1].push(y)
            return acc
        },
        [[], []]
    )
}
function zip(a, b = null, mode) {
    if (isNestedArray(a)) {
        b = a[1]
        a = a[0]
    }

    if (mode == Array) {
        const store = []
        for (let i = 0; i < a.length; i++) {
            store.push([a[i], b[i]])
        }
        return store
    }
    const store = {}
    for (let i = 0; i < a.length; i++) {
        store[a[i]] = b[i]
    }
    return store
}

function cartesianProduct(arr, f) {
    return arr.reduce(
        function (a, b) {
            return a
                .map(function (x) {
                    return b.map(function (y) {
                        if (f) return f(x, y)
                        return x.concat([y])
                    })
                })
                .reduce(function (a, b) {
                    if (f) return f(b, a)
                    return a.concat(b)
                }, [])
        },
        [[]]
    )
}

const magicSquares = {
    3: [
        [
            [4, 9, 2],
            [3, 5, 7],
            [8, 1, 6],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [2, 7, 6],
            [9, 5, 1],
            [4, 3, 8],
        ],
        [
            [4, 9, 2],
            [3, 5, 7],
            [8, 1, 6],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [6, 1, 8],
            [7, 5, 3],
            [2, 9, 4],
        ],
        [
            [2, 7, 6],
            [9, 5, 1],
            [4, 3, 8],
        ],
        [
            [4, 3, 8],
            [9, 5, 1],
            [2, 7, 6],
        ],
        [
            [2, 9, 4],
            [7, 5, 3],
            [6, 1, 8],
        ],
        [
            [4, 9, 2],
            [3, 5, 7],
            [8, 1, 6],
        ],
        [
            [8, 3, 4],
            [1, 5, 9],
            [6, 7, 2],
        ],
        [
            [6, 7, 2],
            [1, 5, 9],
            [8, 3, 4],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [6, 1, 8],
            [7, 5, 3],
            [2, 9, 4],
        ],
        [
            [6, 1, 8],
            [7, 5, 3],
            [2, 9, 4],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [2, 9, 4],
            [7, 5, 3],
            [6, 1, 8],
        ],
        [
            [8, 1, 6],
            [3, 5, 7],
            [4, 9, 2],
        ],
        [
            [17, 89, 71],
            [113, 59, 5],
            [47, 29, 101],
        ],
    ],
    4: [
        [
            [2, 16, 13, 3],
            [11, 5, 8, 10],
            [7, 9, 12, 6],
            [14, 4, 1, 15],
        ],
        [
            [2, 3, 5, 8],
            [5, 8, 2, 3],
            [4, 1, 7, 6],
            [7, 6, 4, 1],
        ],
        [
            [10, 3, 13, 8],
            [5, 16, 2, 11],
            [4, 9, 7, 14],
            [15, 6, 12, 1],
        ],
        [
            [30, 16, 18, 36],
            [10, 44, 22, 24],
            [32, 14, 20, 34],
            [28, 26, 40, 6],
        ],
        [
            [7, 1, 4, 6],
            [2, 8, 5, 3],
            [5, 3, 2, 8],
            [4, 6, 7, 1],
        ],
        [
            [1, 14, 4, 15],
            [8, 11, 5, 10],
            [13, 2, 16, 3],
            [12, 7, 9, 6],
        ],
        [
            [4, 14, 15, 1],
            [9, 7, 6, 12],
            [5, 11, 10, 8],
            [16, 2, 3, 13],
        ],
        [
            [4, 14, 15, 1],
            [9, 7, 6, 12],
            [5, 11, 10, 8],
            [16, 2, 3, 13],
        ],
        [
            [7, 12, 1, 14],
            [2, 13, 8, 11],
            [16, 3, 10, 5],
            [9, 6, 15, 4],
        ],
        [
            [16, 3, 2, 13],
            [5, 10, 11, 8],
            [9, 6, 7, 12],
            [4, 15, 14, 1],
        ],
        [
            [1, 14, 14, 4],
            [11, 7, 6, 9],
            [8, 10, 10, 5],
            [13, 2, 3, 15],
        ],
        [
            [10, 3, 13, 8],
            [5, 16, 2, 11],
            [4, 9, 7, 14],
            [15, 6, 12, 1],
        ],
        [
            [7, 14, 4, 9],
            [12, 1, 15, 6],
            [13, 8, 10, 3],
            [2, 11, 5, 16],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [16, 3, 2, 13],
            [9, 6, 7, 12],
            [5, 10, 11, 8],
            [4, 15, 14, 1],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [12, 6, 7, 9],
            [1, 15, 14, 4],
            [13, 3, 2, 16],
            [8, 10, 11, 5],
        ],
        [
            [6, 12, 9, 7],
            [15, 1, 4, 14],
            [3, 13, 16, 2],
            [10, 8, 5, 11],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [11, 5, 8, 10],
            [2, 16, 13, 3],
            [14, 4, 1, 15],
            [7, 9, 12, 6],
        ],
        [
            [16, 3, 2, 13],
            [9, 6, 7, 12],
            [5, 10, 11, 8],
            [4, 15, 14, 1],
        ],
        [
            [16, 3, 2, 13],
            [5, 10, 11, 8],
            [9, 6, 7, 12],
            [4, 15, 14, 1],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [12, 6, 7, 9],
            [1, 15, 14, 4],
            [13, 3, 2, 16],
            [8, 10, 11, 5],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [1, 17, 16, 4],
            [14, 6, 7, 11],
            [8, 12, 13, 5],
            [15, 3, 2, 18],
        ],
        [
            [10, 3, 13, 8],
            [5, 16, 2, 11],
            [4, 9, 7, 14],
            [15, 6, 12, 1],
        ],
        [
            [5, 16, 2, 11],
            [4, 9, 7, 14],
            [15, 6, 12, 1],
            [10, 3, 13, 8],
        ],
        [
            [2, 11, 5, 16],
            [7, 14, 4, 9],
            [12, 1, 15, 6],
            [13, 8, 10, 3],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [1, 0, 0, 1],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [1, 0, 0, 1],
        ],
        [
            [1, 15, 14, 4],
            [12, 6, 7, 9],
            [8, 10, 11, 5],
            [13, 3, 2, 16],
        ],
        [
            [1, 6, 11, 16],
            [12, 15, 2, 5],
            [14, 9, 8, 3],
            [7, 4, 13, 10],
        ],
        [
            [10, 2, 93, 19],
            [94, 18, 12, 0],
            [17, 90, 4, 13],
            [3, 14, 15, 92],
        ],
        [
            [1, 12, 8, 13],
            [15, 6, 10, 3],
            [14, 7, 11, 2],
            [4, 9, 5, 16],
        ],
        [
            [1, 8, 13, 12],
            [14, 11, 2, 7],
            [4, 5, 16, 9],
            [15, 10, 3, 6],
        ],
        [
            [1, 14, 11, 8],
            [12, 7, 2, 13],
            [6, 9, 16, 3],
            [15, 4, 5, 10],
        ],
        [
            [0, 1, 3, 2],
            [2, 3, 1, 0],
            [3, 2, 0, 1],
            [1, 0, 2, 3],
        ],
        [
            [0, 1, 2, 3],
            [3, 2, 1, 0],
            [1, 0, 3, 2],
            [2, 3, 0, 1],
        ],
        [
            [0, 2, 3, 1],
            [3, 1, 0, 2],
            [0, 2, 3, 1],
            [3, 1, 0, 2],
        ],
        [
            [1, 14, 4, 15],
            [8, 11, 5, 10],
            [13, 2, 16, 3],
            [12, 7, 9, 6],
        ],
        [
            [1, 14, 4, 15],
            [8, 11, 5, 10],
            [13, 2, 16, 3],
            [12, 7, 9, 6],
        ],
        [
            [96, 11, 89, 68],
            [88, 69, 91, 16],
            [61, 86, 18, 99],
            [19, 98, 66, 81],
        ],
    ],
    5: [
        [
            [1, 23, 16, 4, 21],
            [15, 14, 7, 18, 11],
            [24, 17, 13, 9, 2],
            [20, 8, 19, 12, 6],
            [5, 3, 10, 22, 25],
        ],
        [
            [16, 14, 7, 30, 23],
            [24, 17, 10, 8, 31],
            [32, 25, 18, 11, 4],
            [5, 28, 26, 19, 12],
            [13, 6, 29, 22, 20],
        ],
        [
            [21, 3, 4, 12, 25],
            [15, 17, 6, 19, 8],
            [10, 24, 13, 2, 16],
            [18, 7, 20, 9, 11],
            [1, 14, 22, 23, 5],
        ],
        [
            [11, 24, 7, 20, 3],
            [4, 12, 25, 8, 16],
            [17, 5, 13, 21, 9],
            [10, 18, 1, 14, 22],
            [23, 6, 19, 2, 15],
        ],
        [
            [17, 24, 1, 8, 15],
            [23, 5, 7, 14, 16],
            [4, 6, 13, 20, 22],
            [10, 12, 19, 21, 3],
            [11, 18, 25, 2, 9],
        ],
        [
            [21, 3, 19, 10, 12],
            [2, 9, 25, 11, 18],
            [20, 22, 13, 4, 6],
            [8, 15, 1, 17, 24],
            [14, 16, 7, 23, 5],
        ],
        [
            [11, 10, 4, 23, 17],
            [18, 12, 6, 5, 24],
            [25, 19, 13, 7, 1],
            [2, 21, 20, 14, 8],
            [9, 3, 22, 16, 15],
        ],
        [
            [16, 14, 7, 30, 23],
            [24, 17, 10, 8, 31],
            [32, 25, 18, 11, 4],
            [5, 28, 26, 19, 12],
            [13, 6, 29, 22, 20],
        ],
        [
            [1, 23, 16, 4, 21],
            [15, 14, 7, 18, 11],
            [24, 17, 13, 9, 2],
            [20, 8, 19, 12, 6],
            [5, 3, 10, 22, 25],
        ],
        [
            [1, 16, 23, 4, 21],
            [15, 14, 7, 18, 11],
            [24, 17, 13, 9, 2],
            [20, 8, 19, 12, 6],
            [5, 10, 3, 22, 25],
        ],
        [
            [1, 23, 16, 4, 21],
            [15, 14, 7, 18, 11],
            [24, 17, 13, 9, 2],
            [20, 8, 19, 12, 6],
            [5, 3, 10, 22, 25],
        ],
        [
            [21, 11, 2, 6, 25],
            [4, 14, 7, 18, 22],
            [16, 17, 13, 9, 10],
            [23, 8, 19, 12, 3],
            [1, 15, 24, 20, 5],
        ],
        [
            [17, 24, 1, 8, 15],
            [23, 5, 7, 14, 16],
            [4, 6, 13, 20, 22],
            [10, 12, 19, 21, 3],
            [11, 18, 25, 2, 9],
        ],
        [
            [10, 15, 20, 0, 5],
            [5, 10, 15, 20, 0],
            [0, 5, 10, 15, 20],
            [20, 0, 5, 10, 15],
            [15, 20, 0, 5, 10],
        ],
        [
            [2, 1, 5, 4, 3],
            [1, 5, 4, 3, 2],
            [5, 4, 3, 2, 1],
            [4, 3, 2, 1, 5],
            [3, 2, 1, 5, 4],
        ],
        [
            [10, 0, 15, 5, 20],
            [20, 10, 0, 15, 5],
            [5, 20, 10, 0, 15],
            [15, 5, 20, 10, 0],
            [0, 15, 5, 20, 10],
        ],
        [
            [1, 4, 2, 5, 3],
            [4, 2, 5, 3, 1],
            [2, 5, 3, 1, 4],
            [5, 3, 1, 4, 2],
            [3, 1, 4, 2, 5],
        ],
        [
            [11, 4, 17, 10, 23],
            [24, 12, 5, 18, 6],
            [7, 25, 13, 1, 19],
            [20, 8, 21, 14, 2],
            [3, 16, 9, 22, 15],
        ],
        [
            [10, 15, 20, 0, 5],
            [0, 5, 10, 15, 20],
            [15, 20, 0, 5, 10],
            [5, 10, 15, 20, 0],
            [20, 0, 5, 10, 15],
        ],
        [
            [3, 1, 4, 2, 5],
            [4, 2, 5, 3, 1],
            [5, 3, 1, 4, 2],
            [1, 4, 2, 5, 3],
            [2, 5, 3, 1, 4],
        ],
        [
            [13, 16, 24, 2, 10],
            [4, 7, 15, 18, 21],
            [20, 23, 1, 9, 12],
            [6, 14, 17, 25, 3],
            [22, 5, 8, 11, 19],
        ],
        [
            [15, 20, 0, 5, 10],
            [20, 0, 5, 10, 15],
            [0, 5, 10, 15, 20],
            [5, 10, 15, 20, 0],
            [10, 15, 20, 0, 5],
        ],
        [
            [2, 4, 1, 3, 5],
            [3, 5, 2, 4, 1],
            [4, 1, 3, 5, 2],
            [5, 2, 4, 1, 3],
            [1, 3, 5, 2, 4],
        ],
        [
            [17, 24, 1, 8, 15],
            [23, 5, 7, 14, 16],
            [4, 6, 13, 20, 22],
            [10, 12, 19, 21, 3],
            [11, 18, 25, 2, 9],
        ],
        [
            [17, 24, 1, 8, 15],
            [23, 5, 7, 14, 16],
            [4, 6, 13, 20, 22],
            [10, 12, 19, 21, 3],
            [11, 18, 25, 2, 9],
        ],
    ],
    6: [
        [
            [13, 22, 18, 27, 11, 20],
            [31, 4, 36, 9, 29, 2],
            [12, 21, 14, 23, 16, 25],
            [30, 3, 5, 32, 34, 7],
            [17, 26, 10, 19, 15, 24],
            [8, 35, 28, 1, 6, 33],
        ],
        [
            [1, 35, 4, 33, 32, 6],
            [25, 11, 9, 28, 8, 30],
            [24, 14, 18, 16, 17, 22],
            [13, 23, 19, 21, 20, 15],
            [12, 26, 27, 10, 29, 7],
            [36, 2, 34, 3, 5, 31],
        ],
        [
            [11, 22, 32, 5, 23, 18],
            [25, 16, 7, 30, 13, 20],
            [27, 6, 35, 36, 4, 3],
            [10, 31, 1, 2, 33, 34],
            [14, 19, 8, 29, 26, 15],
            [24, 17, 28, 9, 12, 21],
        ],
        [
            [6, 32, 3, 34, 35, 1],
            [7, 11, 27, 28, 8, 30],
            [19, 14, 16, 15, 23, 24],
            [18, 20, 22, 21, 17, 13],
            [25, 29, 10, 9, 26, 12],
            [36, 5, 33, 4, 2, 31],
        ],
        [
            [1, 32, 33, 4, 35, 6],
            [30, 8, 27, 28, 11, 7],
            [13, 23, 22, 21, 14, 18],
            [24, 17, 16, 15, 20, 19],
            [12, 26, 10, 9, 29, 25],
            [31, 5, 3, 34, 2, 36],
        ],
        [
            [29, 9, 25, 12, 10, 26],
            [20, 15, 19, 24, 16, 17],
            [2, 34, 36, 31, 3, 5],
            [35, 4, 6, 1, 33, 32],
            [14, 21, 18, 13, 22, 23],
            [11, 28, 7, 30, 27, 8],
        ],
        [
            [0, 24, 18, 12, 6, 30],
            [30, 6, 12, 18, 24, 0],
            [0, 24, 12, 18, 6, 30],
            [30, 24, 12, 18, 6, 0],
            [30, 6, 18, 12, 24, 0],
            [0, 6, 18, 12, 24, 30],
        ],
        [
            [1, 6, 1, 6, 6, 1],
            [5, 2, 5, 5, 2, 2],
            [4, 3, 3, 3, 4, 4],
            [3, 4, 4, 4, 3, 3],
            [2, 5, 2, 2, 5, 5],
            [6, 1, 6, 1, 1, 6],
        ],
        [
            [1, 30, 19, 18, 12, 31],
            [35, 8, 17, 23, 26, 2],
            [4, 27, 15, 21, 10, 34],
            [33, 28, 16, 22, 9, 3],
            [32, 11, 20, 14, 29, 5],
            [6, 7, 24, 13, 25, 36],
        ],
        [
            [6, 30, 12, 18, 0, 24],
            [24, 0, 12, 18, 30, 6],
            [24, 0, 18, 12, 30, 6],
            [6, 30, 18, 12, 0, 24],
            [24, 0, 18, 12, 30, 6],
            [6, 30, 12, 18, 0, 24],
        ],
        [
            [2, 5, 5, 2, 5, 2],
            [6, 1, 1, 6, 1, 6],
            [3, 3, 4, 4, 4, 3],
            [4, 4, 3, 3, 3, 4],
            [1, 6, 6, 1, 6, 1],
            [5, 2, 2, 5, 2, 5],
        ],
        [
            [8, 35, 17, 20, 5, 26],
            [30, 1, 13, 24, 31, 12],
            [27, 3, 22, 16, 34, 9],
            [10, 34, 21, 15, 3, 28],
            [25, 6, 24, 13, 36, 7],
            [11, 32, 14, 23, 2, 29],
        ],
        [
            [6, 30, 12, 24, 18, 0],
            [6, 0, 18, 24, 12, 30],
            [24, 0, 12, 6, 18, 30],
            [6, 30, 18, 24, 12, 0],
            [24, 30, 12, 6, 18, 0],
            [24, 0, 18, 6, 12, 30],
        ],
        [
            [2, 2, 5, 2, 5, 5],
            [6, 1, 1, 6, 6, 1],
            [3, 4, 3, 4, 3, 4],
            [5, 5, 2, 5, 2, 2],
            [4, 3, 4, 3, 4, 3],
            [1, 6, 6, 1, 1, 6],
        ],
        [
            [8, 32, 17, 26, 23, 5],
            [12, 1, 19, 30, 18, 31],
            [27, 4, 15, 10, 21, 34],
            [11, 35, 20, 29, 14, 2],
            [28, 33, 16, 9, 22, 3],
            [25, 6, 24, 7, 13, 36],
        ],
        [
            [2, 3, 0, 2, 0, 2],
            [1, 0, 3, 1, 3, 1],
            [3, 1, 1, 2, 2, 0],
            [0, 2, 0, 3, 3, 1],
            [3, 2, 2, 0, 0, 2],
            [0, 1, 3, 1, 1, 3],
        ],
        [
            [0, 3, 0, 1, 3, 2],
            [2, 1, 2, 3, 1, 0],
            [3, 0, 3, 2, 0, 1],
            [2, 1, 1, 0, 2, 3],
            [0, 1, 3, 1, 3, 1],
            [2, 3, 0, 2, 0, 2],
        ],
        [
            [0, 1, 0, 3, 3, 2],
            [2, 3, 2, 1, 1, 0],
            [3, 1, 0, 1, 3, 1],
            [0, 2, 2, 3, 0, 2],
            [3, 2, 3, 0, 0, 1],
            [1, 0, 2, 1, 2, 3],
        ],
        [
            [2, 3, 0, 2, 0, 2],
            [1, 0, 3, 1, 3, 1],
            [3, 1, 1, 2, 2, 0],
            [0, 2, 0, 3, 3, 1],
            [3, 2, 2, 0, 0, 2],
            [0, 1, 3, 1, 1, 3],
        ],
        [
            [26, 35, 1, 19, 6, 24],
            [17, 8, 28, 10, 33, 15],
            [30, 12, 14, 23, 25, 7],
            [3, 21, 5, 32, 34, 16],
            [31, 22, 27, 9, 2, 20],
            [4, 13, 36, 18, 11, 29],
        ],
    ],
    7: [
        [
            [46, 8, 16, 20, 29, 7, 49],
            [3, 40, 35, 36, 18, 41, 2],
            [44, 12, 33, 23, 19, 38, 6],
            [28, 26, 11, 25, 39, 24, 22],
            [5, 37, 31, 27, 17, 13, 45],
            [48, 9, 15, 14, 32, 10, 47],
            [1, 43, 34, 30, 21, 42, 4],
        ],
        [
            [35, 26, 17, 1, 62, 53, 44],
            [46, 37, 21, 12, 3, 64, 55],
            [57, 41, 32, 23, 14, 5, 66],
            [61, 52, 43, 34, 25, 16, 7],
            [2, 63, 54, 45, 36, 27, 11],
            [13, 4, 65, 56, 47, 31, 22],
            [24, 15, 6, 67, 51, 42, 33],
        ],
        [
            [47, 11, 8, 9, 6, 45, 49],
            [4, 37, 20, 17, 16, 35, 46],
            [2, 18, 26, 21, 28, 32, 48],
            [43, 19, 27, 25, 23, 31, 7],
            [38, 36, 22, 29, 24, 14, 12],
            [40, 15, 30, 33, 34, 13, 10],
            [1, 39, 42, 41, 44, 5, 3],
        ],
        [
            [22, 47, 16, 41, 10, 35, 4],
            [5, 23, 48, 17, 42, 11, 29],
            [30, 6, 24, 49, 18, 36, 12],
            [13, 31, 7, 25, 43, 19, 37],
            [38, 14, 32, 1, 26, 44, 20],
            [21, 39, 8, 33, 2, 27, 45],
            [46, 15, 40, 9, 34, 3, 28],
        ],
    ],
    8: [
        [
            [61, 3, 2, 64, 57, 7, 6, 60],
            [12, 54, 55, 9, 16, 50, 51, 13],
            [20, 46, 47, 17, 24, 42, 43, 21],
            [37, 27, 26, 40, 33, 31, 30, 36],
            [29, 35, 34, 32, 25, 39, 38, 28],
            [44, 22, 23, 41, 48, 18, 19, 45],
            [52, 14, 15, 49, 56, 10, 11, 53],
            [5, 59, 58, 8, 1, 63, 62, 4],
        ],
        [
            [60, 53, 44, 37, 4, 13, 20, 29],
            [3, 14, 19, 30, 59, 54, 43, 38],
            [58, 55, 42, 39, 2, 15, 18, 31],
            [1, 16, 17, 32, 57, 56, 41, 40],
            [61, 52, 45, 36, 5, 12, 21, 28],
            [6, 11, 22, 27, 62, 51, 46, 35],
            [63, 50, 47, 34, 7, 10, 23, 26],
            [8, 9, 24, 25, 64, 49, 48, 33],
        ],
        [
            [8, 58, 59, 5, 4, 62, 63, 1],
            [49, 15, 14, 52, 53, 11, 10, 56],
            [41, 23, 22, 44, 45, 19, 18, 48],
            [32, 34, 35, 29, 28, 38, 39, 25],
            [40, 26, 27, 37, 36, 30, 31, 33],
            [17, 47, 46, 20, 21, 43, 42, 24],
            [9, 55, 54, 12, 13, 51, 50, 16],
            [64, 2, 3, 61, 60, 6, 7, 57],
        ],
        [
            [1, 0, 0, 1, 1, 0, 0, 1],
            [0, 1, 1, 0, 0, 1, 1, 0],
            [0, 1, 1, 0, 0, 1, 1, 0],
            [1, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 1],
            [0, 1, 1, 0, 0, 1, 1, 0],
            [0, 1, 1, 0, 0, 1, 1, 0],
            [1, 0, 0, 1, 1, 0, 0, 1],
        ],
        [
            [1, 63, 62, 4, 5, 59, 58, 8],
            [56, 10, 11, 53, 52, 14, 15, 49],
            [48, 18, 19, 45, 44, 22, 23, 41],
            [25, 39, 38, 28, 29, 35, 34, 32],
            [33, 31, 30, 36, 37, 27, 26, 40],
            [24, 42, 43, 21, 20, 46, 47, 17],
            [16, 50, 51, 13, 12, 54, 55, 9],
            [57, 7, 6, 60, 61, 3, 2, 64],
        ],
        [
            [0, 8, 16, 24, 32, 40, 48, 56],
            [24, 16, 8, 0, 56, 48, 40, 32],
            [48, 56, 32, 40, 16, 24, 0, 8],
            [40, 32, 56, 48, 8, 0, 24, 16],
            [56, 48, 40, 32, 24, 16, 8, 0],
            [32, 40, 48, 56, 0, 8, 16, 24],
            [8, 0, 24, 16, 40, 32, 56, 48],
            [16, 24, 0, 8, 48, 56, 32, 40],
        ],
        [
            [1, 2, 3, 4, 5, 6, 7, 8],
            [3, 4, 1, 2, 7, 8, 5, 6],
            [5, 6, 7, 8, 1, 2, 3, 4],
            [7, 8, 5, 6, 3, 4, 1, 2],
            [4, 3, 2, 1, 8, 7, 6, 5],
            [2, 1, 4, 3, 6, 5, 8, 7],
            [8, 7, 6, 5, 4, 3, 2, 1],
            [6, 5, 8, 7, 2, 1, 4, 3],
        ],
        [
            [1, 10, 19, 28, 37, 46, 55, 64],
            [27, 20, 9, 2, 63, 56, 45, 38],
            [53, 62, 39, 48, 17, 26, 3, 12],
            [47, 40, 61, 54, 11, 4, 25, 18],
            [60, 51, 42, 33, 32, 23, 14, 5],
            [34, 41, 52, 59, 6, 13, 24, 31],
            [16, 7, 30, 21, 44, 35, 58, 49],
            [22, 29, 8, 15, 50, 57, 36, 43],
        ],
        [
            [0, 48, 16, 32, 24, 40, 8, 56],
            [56, 8, 40, 24, 32, 16, 48, 0],
            [0, 48, 16, 32, 24, 40, 8, 56],
            [56, 8, 40, 24, 32, 16, 48, 0],
            [56, 8, 40, 24, 32, 16, 48, 0],
            [0, 48, 16, 32, 24, 40, 8, 56],
            [56, 8, 40, 24, 32, 16, 48, 0],
            [0, 48, 16, 32, 24, 40, 8, 56],
        ],
        [
            [1, 8, 1, 8, 8, 1, 8, 1],
            [7, 2, 7, 2, 2, 7, 2, 7],
            [3, 6, 3, 6, 6, 3, 6, 3],
            [5, 4, 5, 4, 4, 5, 4, 5],
            [4, 5, 4, 5, 5, 4, 5, 4],
            [6, 3, 6, 3, 3, 6, 3, 6],
            [2, 7, 2, 7, 7, 2, 7, 2],
            [8, 1, 8, 1, 1, 8, 1, 8],
        ],
        [
            [1, 56, 17, 40, 32, 41, 16, 57],
            [63, 10, 47, 26, 34, 23, 50, 7],
            [3, 54, 19, 38, 30, 43, 14, 59],
            [61, 12, 45, 28, 36, 21, 42, 5],
            [60, 13, 44, 29, 37, 20, 53, 4],
            [6, 51, 22, 35, 27, 46, 11, 62],
            [58, 15, 42, 31, 39, 18, 55, 2],
            [8, 47, 24, 33, 25, 48, 9, 64],
        ],
        [
            [0, 48, 56, 8, 16, 32, 40, 24],
            [56, 8, 0, 48, 40, 24, 16, 32],
            [0, 48, 56, 8, 16, 32, 40, 24],
            [56, 8, 0, 48, 40, 24, 16, 32],
            [48, 0, 8, 56, 32, 16, 24, 40],
            [8, 56, 48, 0, 24, 40, 32, 16],
            [48, 0, 8, 56, 32, 16, 24, 40],
            [8, 56, 48, 0, 24, 40, 32, 16],
        ],
        [
            [1, 8, 1, 8, 7, 2, 7, 2],
            [7, 2, 7, 2, 1, 8, 1, 8],
            [8, 1, 8, 1, 2, 7, 2, 7],
            [2, 7, 2, 7, 8, 1, 8, 1],
            [3, 6, 3, 6, 5, 4, 5, 4],
            [5, 4, 5, 4, 3, 6, 3, 6],
            [6, 3, 6, 3, 4, 5, 4, 5],
            [4, 5, 4, 5, 6, 3, 6, 3],
        ],
        [
            [1, 56, 57, 16, 23, 34, 47, 26],
            [63, 10, 7, 50, 41, 32, 17, 40],
            [8, 49, 64, 9, 18, 39, 42, 31],
            [58, 15, 2, 55, 48, 25, 24, 33],
            [51, 6, 11, 62, 37, 20, 29, 44],
            [13, 60, 53, 4, 27, 46, 35, 22],
            [54, 3, 14, 59, 36, 21, 28, 45],
            [12, 61, 52, 5, 30, 43, 38, 19],
        ],
        [
            [0, 1, 3, 2, 0, 1, 3, 2],
            [2, 3, 1, 0, 2, 3, 1, 0],
            [3, 2, 0, 1, 3, 2, 0, 1],
            [1, 0, 2, 3, 1, 0, 2, 3],
            [0, 1, 3, 2, 0, 1, 3, 2],
            [2, 3, 1, 0, 2, 3, 1, 0],
            [3, 2, 0, 1, 3, 2, 0, 1],
            [1, 0, 2, 3, 1, 0, 2, 3],
        ],
        [
            [1, 17, 62, 46, 4, 20, 63, 47],
            [33, 49, 30, 14, 36, 52, 31, 15],
            [56, 40, 11, 27, 53, 37, 10, 26],
            [24, 8, 43, 59, 21, 5, 42, 58],
            [13, 29, 50, 34, 16, 32, 51, 35],
            [45, 61, 18, 2, 48, 64, 19, 3],
            [60, 44, 7, 23, 57, 41, 6, 22],
            [28, 12, 39, 55, 25, 9, 38, 54],
        ],
        [
            [0, 1, 0, 1, 2, 3, 3, 2],
            [2, 3, 3, 2, 1, 0, 1, 0],
            [0, 3, 0, 2, 3, 1, 0, 3],
            [1, 2, 3, 1, 0, 2, 1, 2],
            [2, 1, 0, 2, 3, 1, 2, 1],
            [3, 0, 3, 1, 0, 2, 3, 0],
            [3, 2, 0, 1, 2, 3, 0, 1],
            [1, 0, 3, 2, 1, 0, 2, 3],
        ],
        [
            [1, 17, 14, 30, 36, 52, 63, 47],
            [33, 49, 62, 46, 20, 4, 31, 15],
            [8, 56, 11, 43, 53, 21, 10, 58],
            [24, 40, 59, 27, 5, 37, 26, 42],
            [45, 29, 2, 34, 64, 32, 35, 19],
            [61, 13, 50, 18, 16, 48, 51, 3],
            [60, 44, 7, 23, 41, 57, 6, 22],
            [28, 12, 55, 39, 25, 9, 38, 54],
        ],
    ],
    9: [
        [
            [31, 76, 13, 36, 81, 18, 29, 74, 11],
            [22, 40, 58, 27, 45, 63, 20, 38, 56],
            [67, 4, 49, 72, 9, 54, 65, 2, 47],
            [30, 75, 12, 32, 77, 14, 34, 79, 16],
            [21, 39, 57, 23, 41, 59, 25, 43, 61],
            [66, 3, 48, 68, 5, 50, 70, 7, 52],
            [35, 80, 17, 28, 73, 10, 33, 78, 15],
            [26, 44, 62, 19, 37, 55, 24, 42, 60],
            [71, 8, 53, 64, 1, 46, 69, 6, 51],
        ],
        [
            [37, 78, 29, 70, 21, 62, 13, 54, 5],
            [6, 38, 79, 30, 71, 22, 63, 14, 46],
            [47, 7, 39, 80, 31, 72, 23, 55, 15],
            [16, 48, 8, 40, 81, 32, 64, 24, 56],
            [57, 17, 49, 9, 41, 73, 33, 65, 25],
            [26, 58, 18, 50, 1, 42, 74, 34, 66],
            [67, 27, 59, 10, 51, 2, 43, 75, 35],
            [36, 68, 19, 60, 11, 52, 3, 44, 76],
            [77, 28, 69, 20, 61, 12, 53, 4, 45],
        ],
        [
            [47, 58, 69, 80, 1, 12, 23, 34, 45],
            [57, 68, 79, 9, 11, 22, 33, 44, 46],
            [67, 78, 8, 10, 21, 32, 43, 54, 56],
            [77, 7, 18, 20, 31, 42, 53, 55, 66],
            [6, 17, 19, 30, 41, 52, 63, 65, 76],
            [16, 27, 29, 40, 51, 62, 64, 75, 5],
            [26, 28, 39, 50, 61, 72, 74, 4, 15],
            [36, 38, 49, 60, 71, 73, 3, 14, 25],
            [37, 48, 59, 70, 81, 2, 13, 24, 35],
        ],
        [
            [8, 80, 78, 76, 75, 12, 14, 16, 10],
            [67, 22, 64, 62, 61, 26, 28, 24, 15],
            [69, 55, 32, 52, 51, 36, 34, 27, 13],
            [71, 57, 47, 38, 45, 40, 35, 25, 11],
            [73, 59, 49, 43, 41, 39, 33, 23, 9],
            [5, 19, 29, 42, 37, 44, 53, 63, 77],
            [3, 17, 48, 30, 31, 46, 50, 65, 79],
            [1, 58, 18, 20, 21, 56, 54, 60, 81],
            [72, 2, 4, 6, 7, 70, 68, 66, 74],
        ],
        [
            [63, 63, 63, 0, 0, 0, 45, 45, 45],
            [63, 63, 63, 0, 0, 0, 45, 45, 45],
            [63, 63, 63, 0, 0, 0, 45, 45, 45],
            [18, 18, 18, 36, 36, 36, 54, 54, 54],
            [18, 18, 18, 36, 36, 36, 54, 54, 54],
            [18, 18, 18, 36, 36, 36, 54, 54, 54],
            [27, 27, 27, 72, 72, 72, 9, 9, 9],
            [27, 27, 27, 72, 72, 72, 9, 9, 9],
            [27, 27, 27, 72, 72, 72, 9, 9, 9],
        ],
        [
            [71, 64, 69, 8, 1, 6, 53, 46, 51],
            [66, 68, 70, 3, 5, 7, 48, 50, 52],
            [67, 72, 65, 4, 9, 2, 49, 54, 47],
            [26, 19, 24, 44, 37, 42, 62, 55, 60],
            [21, 23, 25, 39, 41, 43, 57, 59, 61],
            [22, 27, 20, 40, 45, 38, 58, 63, 56],
            [35, 28, 33, 80, 73, 78, 17, 10, 15],
            [30, 32, 34, 75, 77, 79, 12, 14, 16],
            [31, 36, 29, 76, 81, 74, 13, 18, 11],
        ],
    ],
    10: [
        [
            [0, 1, 3, 1, 0, 1, 3, 1, 3, 2],
            [2, 3, 0, 2, 2, 3, 0, 2, 1, 0],
            [3, 0, 2, 3, 0, 2, 0, 2, 1, 2],
            [1, 2, 1, 0, 3, 1, 3, 1, 3, 0],
            [0, 2, 3, 1, 1, 2, 2, 0, 1, 3],
            [1, 3, 0, 2, 0, 3, 3, 1, 0, 2],
            [3, 0, 3, 2, 2, 0, 0, 2, 1, 2],
            [1, 2, 0, 1, 3, 1, 1, 3, 3, 0],
            [3, 2, 1, 3, 1, 0, 1, 3, 0, 1],
            [1, 0, 2, 0, 3, 2, 2, 0, 2, 3],
        ],
        [
            [17, 42, 99, 49, 1, 26, 83, 33, 90, 65],
            [67, 92, 24, 74, 51, 76, 8, 58, 40, 15],
            [98, 23, 55, 80, 7, 57, 14, 64, 41, 66],
            [48, 73, 30, 5, 82, 32, 89, 39, 91, 16],
            [4, 54, 81, 31, 38, 63, 70, 20, 47, 97],
            [29, 79, 6, 56, 13, 88, 95, 45, 22, 72],
            [85, 10, 87, 62, 69, 19, 21, 71, 28, 53],
            [35, 60, 12, 37, 94, 44, 46, 96, 78, 3],
            [86, 61, 43, 93, 100, 25, 27, 77, 9, 34],
            [36, 11, 68, 18, 95, 75, 52, 2, 59, 84],
        ],
    ],
    12: [
        [
            [2, 9, 4, 119, 126, 121, 92, 99, 94, 65, 72, 67],
            [7, 5, 3, 124, 122, 120, 97, 95, 93, 70, 68, 66],
            [6, 1, 8, 123, 118, 125, 96, 91, 98, 69, 64, 71],
            [
                101, 108, 103, 56, 63, 58, 11, 18, 13, 110, 117,
                112,
            ],
            [
                106, 104, 102, 61, 59, 57, 16, 14, 12, 115, 113,
                111,
            ],
            [
                105, 100, 107, 60, 55, 62, 15, 10, 17, 114, 109,
                116,
            ],
            [47, 54, 49, 74, 81, 76, 137, 144, 139, 20, 27, 22],
            [52, 50, 48, 79, 77, 75, 142, 140, 138, 25, 23, 21],
            [51, 46, 53, 78, 73, 80, 141, 136, 143, 24, 19, 26],
            [128, 135, 130, 29, 36, 31, 38, 45, 40, 83, 90, 85],
            [133, 131, 129, 34, 32, 30, 43, 41, 39, 88, 86, 84],
            [132, 127, 134, 33, 28, 35, 42, 37, 44, 87, 82, 89],
        ],
        [
            [
                17, 30, 27, 24, 129, 142, 139, 136, 49, 62, 59,
                56,
            ],
            [
                28, 23, 18, 29, 140, 135, 130, 141, 60, 55, 50,
                61,
            ],
            [
                22, 25, 32, 19, 134, 137, 144, 131, 54, 57, 64,
                51,
            ],
            [
                31, 20, 21, 26, 143, 132, 133, 138, 63, 52, 53,
                58,
            ],
            [97, 110, 107, 104, 65, 78, 75, 72, 33, 46, 43, 40],
            [108, 103, 98, 109, 76, 71, 66, 77, 44, 39, 34, 45],
            [102, 105, 112, 99, 70, 73, 80, 67, 38, 41, 48, 35],
            [
                111, 100, 101, 106, 79, 68, 69, 74, 47, 36, 37,
                42,
            ],
            [81, 94, 91, 88, 1, 14, 11, 8, 113, 126, 123, 120],
            [92, 87, 82, 93, 12, 7, 2, 13, 124, 119, 114, 125],
            [86, 89, 96, 83, 6, 9, 16, 3, 118, 121, 128, 115],
            [95, 84, 85, 90, 15, 4, 5, 10, 127, 116, 117, 122],
        ],
        [
            [1, 142, 139, 8, 9, 134, 131, 16, 17, 126, 123, 24],
            [
                140, 7, 2, 141, 132, 15, 10, 133, 124, 23, 18,
                125,
            ],
            [
                6, 137, 144, 3, 14, 129, 136, 11, 22, 121, 128,
                19,
            ],
            [
                143, 4, 5, 138, 135, 12, 13, 130, 127, 20, 21,
                122,
            ],
            [
                25, 118, 115, 32, 33, 110, 107, 40, 41, 102, 99,
                48,
            ],
            [
                116, 31, 26, 117, 108, 39, 34, 109, 100, 47, 42,
                101,
            ],
            [
                30, 113, 120, 27, 38, 105, 112, 35, 46, 97, 104,
                43,
            ],
            [
                119, 28, 29, 114, 111, 36, 37, 106, 103, 44, 45,
                98,
            ],
            [49, 94, 91, 56, 57, 86, 83, 64, 65, 78, 75, 72],
            [92, 55, 50, 93, 84, 63, 58, 85, 76, 71, 66, 77],
            [54, 89, 96, 51, 62, 81, 88, 59, 70, 73, 80, 67],
            [95, 52, 53, 90, 87, 60, 61, 82, 79, 68, 69, 74],
        ],
        [
            [69, 74, 79, 68, 29, 114, 119, 28, 61, 82, 87, 60],
            [75, 72, 65, 78, 115, 32, 25, 118, 83, 64, 57, 86],
            [66, 77, 76, 71, 26, 117, 116, 31, 58, 85, 84, 63],
            [80, 67, 70, 73, 120, 27, 30, 113, 88, 59, 62, 81],
            [
                21, 122, 127, 20, 53, 90, 95, 52, 13, 130, 135,
                12,
            ],
            [123, 24, 17, 126, 91, 56, 49, 94, 131, 16, 9, 134],
            [
                18, 125, 124, 23, 50, 93, 92, 55, 10, 133, 132,
                15,
            ],
            [
                128, 19, 22, 121, 96, 51, 54, 89, 136, 11, 14,
                129,
            ],
            [45, 98, 103, 44, 5, 138, 143, 4, 37, 106, 111, 36],
            [99, 48, 41, 102, 139, 8, 1, 142, 107, 40, 33, 110],
            [
                42, 101, 100, 47, 2, 141, 140, 7, 34, 109, 108,
                39,
            ],
            [104, 43, 46, 97, 144, 3, 6, 137, 112, 35, 38, 105],
        ],
        [
            [60, 82, 88, 56, 90, 59, 24, 118, 124, 20, 126, 23],
            [64, 69, 74, 79, 68, 81, 28, 33, 110, 115, 32, 117],
            [83, 75, 72, 65, 78, 62, 119, 111, 36, 29, 114, 26],
            [84, 66, 77, 76, 71, 61, 120, 30, 113, 112, 35, 25],
            [58, 80, 67, 70, 73, 87, 22, 116, 31, 34, 109, 123],
            [86, 63, 57, 89, 55, 85, 122, 27, 21, 125, 19, 121],
            [6, 136, 142, 2, 144, 5, 42, 100, 106, 38, 108, 41],
            [10, 15, 128, 133, 14, 135, 46, 51, 92, 97, 50, 99],
            [137, 129, 18, 11, 132, 8, 101, 93, 54, 47, 96, 44],
            [138, 12, 131, 130, 17, 7, 102, 48, 95, 94, 53, 43],
            [4, 134, 13, 16, 127, 141, 40, 98, 49, 52, 91, 105],
            [140, 9, 3, 143, 1, 139, 104, 45, 39, 107, 37, 103],
        ],
    ],
}

function curry(fn, ...kwargs) {
    return (...args) => {
        let count = 0
        for (let i = 0; i < kwargs.length; i++) {
            let kwarg = kwargs[i]
            if (kwarg === null) kwargs[i] = args[count++]
        }
        return fn(...kwargs)
    }
}

function force(x, n = 2, fallback = '') {
    if (x == null) x = []
    while (x.length < n) {
        x.push(fallback)
    }
    return x
}

function isStorage(x) {
    return test(/Storage/, x.constructor.name)
}

function isNewLine(s) {
    return /^\n+$/.test(s)
}

function colorToHex(color) {
    const dict = {
        black: '000000',
    }
    return '#' + dict[color] || dict.black
}

function iter(items, fn, ...args) {
    if (isNumber(items)) {
        const store = []
        for (let i = 0; i < items; i++) {
            store.push(fn(i, ...args))
        }
        return store
    }

    if (isObject(fn)) {
        for (let item of items) {
            if (fn[item]) {
                if (isFunction(fn[item])) {
                    fn[item](...args)
                }
            }
        }
    }

    return toArray(items).map((item, i) => {
        return fn(item, i, ...args)
    })
}

const StringMixins = {
    trim() {
        this.s = this.s.trim()
    },
    mreplace(regex) {
        const [s, match] = mget(regex, this.s)
        this.s = s.trim()
        return match
    },
}

function mixin(state, mixin, ...keys) {
    if (keys.length == 0) keys = Object.keys(mixin)
    for (let key of gatherArgs(keys)) {
        const value = mixin[key]
        if (isObject(value)) {
            Object.defineProperty(state, key, value)
        } else {
            state[key] = value.bind(state)
        }
    }
}

function eat(s, regex) {
    let m = search(regex, s.trim())
    if (m) return [s.slice(m.length).trim(), m]
    return [s, null]
}
class Eater {
    static eatStart(regex, s) {
        let m = search('^' + regex, s.trim())
        s = s.trim()
        if (m) return [s.slice(m), m]
        return [s, null]
    }

    constructor(regex) {
        this.regex = regex
        this.store = []
        mixin(this, StringMixins, 'trim', 'mreplace')
    }
    eatStart(regex) {
        const [s, match] = Eater.eatStart(regex, s)
        if (!match) return 1
        this.store.push(match)
    }

    eat(regex) {
        const match = this.mreplace(regex || this.regex)
        if (!match) return 1
        this.store.push(match)
    }

    run(s) {
        this.s = s.trim()
        while (true) {
            const done = this.eat()
            this.trim()
            if (done) break
        }
        return [this.s, this.store]
    }
}

function notNull(s) {
    return s !== null
}

function trimSpaces(s) {
    return s.replace(/^ +| +$/g, '')
}

class Matrix {
    iterate(fn) {
        let count = 0
        let linebreak
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                let value = this.get(x, y)
                if (value == null) continue
                count++
                fn(value, x, y, count, linebreak)
                linebreak = false
            }
            linebreak = true
        }
    }
    constructor(x, width) {
        if (isNumber(arguments[0]) && isNumber(arguments[1])) {
            this.width = arguments[0]
            this.height = arguments[1]
            this.store = []
        } else if (isNestedArray(x)) {
            this.store = flat(x)
            this.width = x[0].length
            this.height = x.length
        } else if (isArray(x)) {
            if (!width) width = 3
            if (isObject(width)) {
                width = width.width
            }

            this.store = x
            this.width = width
            this.height = Math.ceil(
                this.store.length / this.width
            )
        }
    }

    [Symbol.iterator]() {
        this.index = 0
        return this
    }

    get(x, y) {
        return this.store[y * this.width + x]
    }

    set(x, y, value) {
        this.store[y * this.width + x] = value
    }

    getColumn(n) {
        const store = []
        let y = 0
        while (y < this.height) {
            store.push(this.get(n, y))
            y += 1
        }
        return store
    }

    getRow(n) {
        const store = []
        let x = 0
        while (x < this.width) {
            store.push(this.get(x, n))
            x += 1
        }
        return store
    }

    getColumns() {
        return iter(this.width, (i) => this.getColumn(i))
    }

    getRows() {
        return iter(this.height, (i) => this.getRow(i))
    }
}

function getStrings(s) {
    return findall(/\'.*?\'|\".*?\"/g, s).map((x) =>
        x.slice(1, -1)
    )
}

function normalizeSpaces(s) {
    return s.replace(/^ +/gm, (x) => {
        return ' '.repeat(fixSpaceLength(x.length))
    })

    function fixSpaceLength(n) {
        switch (n) {
            case 1:
                return 0
            case 2:
                return 4
            case 3:
                return 4
            case 4:
                return 4
            case 5:
                return 4
            case 6:
                return 8
            case 7:
                return 8
            case 8:
                return 8
            case 10:
                return 12
            case 11:
                return 12
            default:
                return n
        }
    }
}

function partial(fn, ...args) {
    return function (arg) {
        return fn(arg, ...args)
    }
}

function toStringArgument(x, quotes) {
    function parseObj(obj) {
        let s = '{\n'
        for (let [k, v] of Object.entries(obj)) {
            s +=
                indent(singlequote(k) + ': ' + parse(v)) + ',\n'
        }
        s += '}'
        return s
    }

    function parseArr(arr) {
        let s = '[\n'
        for (let item of arr) {
            s += indent(parse(item)) + ',\n'
        }
        s += ']'
        return s
    }

    function parseString(s) {
        if (test(/^[a-z].*?[A-Z]/, s)) return s
        return singlequote(s.toString())
        if (quotes) return s.toString()
        if (test(/^\+\(/, s)) return s
        if (s.includes(' ')) return singlequote(s)
        if (test(/[a-z]\.[a-z]/, s)) return s
    }

    function parse(s) {
        if (isObject(s)) {
            return parseObj(s)
        }

        if (isFunction(s)) {
            return s.toString()
        }

        if (isArray(s)) {
            return parseArr(s)
        }

        if (s == null) return 'null'
        if (s == undefined) return 'undefined'
        if (s == '') return "''"

        if (isNumber(s)) {
            return s
        }

        return parseString(s)
    }

    return parse(x)
}

function createVariable(a, b, quotes = true, prefix = 'const') {
    if (prefix) prefix += ' '
    switch (b) {
        case '':
            b = 'go'
    }

    let value = stringify(b)
    if (isArray(a)) {
        a = `[${a.join(', ')}]`
    }
    return `${prefix}${a} = ${value}`
}

function splitmapfilter(s, regex, fn, ...args) {
    const runner = (x, i, arr) => fn(x, ...args, i)
    return split(s, regex).map(runner).filter(exists)
}
function capitalizeName(s) {
    let fn = capitalize
    return splitMapJoin(s, ' ', fn)
}
function splitMapJoin(s, delimiter, fn, joinDelimiter) {
    if (!fn) {
        fn = delimiter
        delimiter = ' '
    }
    if (arguments.length < 4) {
        joinDelimiter = delimiter
    }
    return split(s, delimiter).map(fn).join(joinDelimiter)
}

function argsplit(s, ref, regex = '($1)(\\w+)') {
    let match = search(ncg(regex, ref), s)
    return match ? match : [null, null]
}

function isOnlyWords(s) {
    return test(/^[a-zA-Z](?: [a-zA-Z]+)*$/, s)
}
function warn(s) {
    console.log('warn'.repeat(20))
    console.log(s)
    console.log(getCaller())
    console.log('---------------------------')
}
function getSingleAndDoubleAttrs(s, mode) {
    const [text, doubles] = mreplace(
        /(\S+?) *= *('.*?'|".*?"|\S+)/g,
        s
    )
    const singles = split(text)
    if (mode == Object) {
        const store = {}
        for (let single of singles) {
            store[single] = true
        }

        for (let [a, b] of doubles) {
            store[a] = b
        }
        return store
    }
    return [singles, doubles]
}
function getOptions(s, mode) {
    if (mode == Object) {
        const [text, doubleAttrs] = mreplace(
            /(\S+?) *= *(\S+)/g,
            s
        )
        return [
            text,
            toDictionary(doubleAttrs, null, toArgument),
        ]
    }
    function runner(s) {
        if (isOnlyWords(s)) {
            return ['', reduce(split(s), (x) => [x, true])]
        }
        if (test(/:\w/, s)) {
            let [a, b] = mreplace(/:(\w+)/g, '', s)
            return [a, reduce(b, (x) => [x, true])]
        }

        if (test(/=/, s)) {
            let [a, b] = mreplace(/(\w+)=(\w+)/g, '', s)
            const p = [a, reduce(b, (k, v) => [k, v])]
            return p
        } else {
            let [a, b] = mreplace(/[;@](\w+)/g, '', s)
            return [a, reduce(b, (x) => [x, true])]
        }
    }

    let [a, b] = runner(s)
    if (exists(b)) {
        b = mapObject(b, dict)
    }
    return [a, b]
}

function aggregate(s, regex, kt, vt) {
    const storage = new Storage()
    const matches = isString(s) ? findall(regex, s) : s

    for (let [a, b] of matches) {
        if (kt) a = kt(a)
        if (vt) b = vt(b)
        storage.add(a, b)
    }
    return storage.value
}

function pipe(...a) {
    if (isArray(a[0])) a = a[0]
    if (isFunction(a)) return a
    return (...args) =>
        a
            .filter((x) => x)
            .reduce(
                (y, f) => (isArray(y) ? f(...y) : f(y)),
                args
            )
}

function createError() {
    try {
        throw new Error()
    } catch (e) {
        return e
    }
}

function replaceFromIndex(s, index, original, replacement) {
    let length = isNumber(original) ? original : original.length
    let before = s.slice(0, index)
    let after = s.slice(index + length)
    return before + replacement + after
}

function freplace(regex, replacement, s, flags = '') {
    if (isFunction(regex)) {
        return regex(s)
    }

    const parser = (...args) => {
        return isFunction(replacement)
            ? replacement(...args)
            : replaceTemplaterHelper(replacement, args)
        //: templater([getLast(args), ...args])
    }

    return replace(regex, parser, s, flags)
}

class Table extends Matrix {
    constructor(items, width) {
        super(items, width)

        this.simulate()
    }
    simulate() {
        const widths = this.getWidthes()
        const heights = this.getHeights()
        console.log(widths)
    }

    getWidthes() {
        return this.getColumns().map((item, i) => {
            return getLongest(item, len, null)
        })
    }

    getHeights() {
        return this.getRows().map((item, i) => {
            return getLongest(item)
        })
    }
}

function regexgetter(template, dict) {
    assert(template.startsWith('/'))
    let [regex, flags] = search(/\/(.*?)\/(\w+)$/, template)
    let keys = isObject(dict) ? Object.keys(dict) : dict
    let boundary = false

    if (flags.includes('e')) {
        keys = keys.map(mapConditional(/^\W+$/, rescape))
        flags = flags.replace('e', '')
    }

    if (flags.includes('b')) {
        boundary = true
        flags = flags.replace('b', '')
    }

    regex = regex.replace(/\$1/g, keys.join('|'))
    if (boundary) regex = '\\b' + regex + '\\b'
    return RegExp(regex, flags)
}

function hasGFlag(r) {
    return r.flags.includes('g')
}

function regexStartsWithSpaces(r) {
    return /^\^?    /.test(r.source ? r.source : r)
}
function inferlang(s) {
    if (!s) return 'js'
    let match = getExtension(s)
    if (match) {
        if (match == 'vimrc') return 'vim'
        if (match == 'bash_aliases') return 'bash'
        if (match == 'bashrc') return 'bashrc'
        return match
    }

    const dict = {
        '<': 'html',
        function: 'js',
        var: 'js',
        const: 'js',
        let: 'js',
        def: 'py',
        '.': 'css',
    }

    match = s.match(regexgetter('/^($1)/me', dict))
    if (!match)
        match = s.match(regexgetter('/^ *($1)/me', dict))
    return dict[match[0]]
}

function isAllCaps(s) {
    return /^[A-Z]+$/.test(s)
}

function abbreviate(s, mode) {
    s = s.replace(/^\W+/, '')
    if (s.length <= 3 || (isWord(s) && s == s.toLowerCase()))
        return s.toLowerCase()
    const regex = /[ \._-]|(\d+|[A-Z]+[a-z]*)/
    const letters = split(s, regex).map((x) => x[0])
    return mode == Array
        ? letters
        : letters.join('').toLowerCase()
}
class TextTokenizer {
    constructor(key) {
        const dictRE = ncg('^($1) *(.+)', dict)
        const splitRE =
            /(\n+|    +|bold \S+|bte.*|@.+|#\w+?(?:e .*?(?:\$|$)| \w+))/
        const items = split(s, splitRE)
        const store = []
        this.run
    }
    run(s) {
        this.s = s
        this.items = split(this.s, this.regex)
        console.log(this.items)
    }
    //new TextTokenizer('reddit')
}

function hasCode(s) {
    let r = /^(?:var|const|class|(?:async )?function)/m
    return r.test(s)
}

function removeSpaces(s) {
    return s.replace(/ /g, '')
}

function smallify(x) {
    if (isString(x)) {
        x = x.trim()
        if (lineCount(x) > 3) {
            return getFirstLine(x) + '\n...\n' + getLastLine(x)
        }
        return x
    }
    return x.length == 0 ? null : x.length == 1 ? x[0] : x
}

function spaceToCamel(s) {
    if (isNumber(s)) {
        return Number(s)
    }
    //return s.join('')
    let cap
    let lower
    return listgetter(s, ' ')
        .map((item, i, arr) => {
            if (i == arr.length - 1 && item == 'to') {
                return 2
            }

            if (item == 'new') {
                cap = true
                return 'new'
            }

            if (item == 'lowercase') {
                lower = true
                return ''
            }

            if (item == 'cap' || item == 'capitalize') {
                cap = true
                return ''
            }
            if (cap) {
                if (lower) {
                    lower = false
                } else {
                    item = capitalize(item)
                }
                cap = false
            }

            return item.length == 1 ||
                i == 0 ||
                arr[i - 1].endsWith('.')
                ? item
                : capitalize(item)
        })
        .join('')
}

function listgetter(x, regex) {
    if (isArray(x)) {
        return x
    }
    return split(x, regex)
}

function spaceToSnake(s) {
    return listgetter(s, ' ').join('_')
}

function createConfig(s, presets) {
    if (arguments.length > 1) {
        return reduce(partition(Array.from(arguments)))
    }
    if (!s) return {}
    if (isWord(s)) {
        if (presets && presets.hasOwnProperty(s)) {
            return presets[s]
        }
        return { [s.trim()]: true }
    }
    if (isObject(s)) {
        return s
    }
    s = s.trim()
    //if(/\w+ *= *\w/.test(s)) {
    //return split(s, /=/)
    //}
    let regex = /\w+ *= *\w/.test(s)
        ? /(\w+) *= *(.*?)(?=\w+ *=|$)/g
        : /  /.test(s)
        ? /(\w+) (.*?)(?=  \w+ |$)/g
        : test(/^\w+ \w+$/, s)
        ? /(\w+) (\w+)/g
        : test(/  /, s)
        ? /(\S.*?) (\S.*?)(?=  |$)/g
        : /(.*?) *[:=] *(.*?)(?:$|, ?|  )/g
    return reduce(findall(regex, s), (k, v) => {
        return [k.trim(), v ? toArgument(v) : true]
    })
}

function jspy(lang, key, ...args) {
    function commentCSS(s) {
        if (hasNewline(s)) {
            return '/*\n' + s + '\n*/'
        }
        return `/* ${s} */`
    }

    function commentJS(s) {
        if (hasNewline(s)) {
            return '/*' + newlineIndent(s) + '*/'
        }
        return '// ' + s
    }

    function commentPY(s) {
        if (hasNewline(s)) {
            return '"""' + newlineIndent(s) + '"""'
        }
        return '# ' + s
    }

    const indexes = ['js', 'py', 'vim', 'bash', 'css', 'html']
    const ref = {
        compiler: ['node', 'python3', 'bash'],
        runtime: ['node', 'python3', 'bash'],
        const: ['const ', '', 'let'],
        name: [spaceToCamel, spaceToSnake],
        params: [spaceToCamel, spaceToSnake],
        comment: [
            commentJS,
            commentPY,
            (x) => `" ${x}`,
            (x) => `# ${x}`,
            commentCSS,
            (x) => `<!-- ${x} -->`,
        ],
        //'variablefn': [variablejs, variablepy]
    }

    if (key == lang) {
        let index = indexes.indexOf(lang)
        return reduce(ref, (k, v) => [k, v[index]])
    }
    const value = ref[key][indexes.indexOf(lang)]
    return isFunction(value) && exists(args)
        ? value(...args)
        : value
}
function stateCurryEnd(state, key, ...kwargs) {
    return function stateCurry(...args) {
        state[key](...args, ...kwargs)
    }
}

function stateCurryStart(state, key, ...kwargs) {
    return function stateCurry(...args) {
        return state[key](...kwargs, ...args)
    }
}

function curryEnd(...kwargs) {
    const fn = kwargs.shift()
    return function (...args) {
        fn(...args, ...kwargs)
    }
}

function timestamp(date) {
    let [h, m, s, ms, ampm] = getHMSM(date)
    //h = zeroPad(h)
    m = zeroPad(m)
    s = zeroPad(s)
    return `${h}:${m}${ampm}`
    return `${h}:${m}:${s}${ampm} ms: ${ms}`
}

function wordCount(s) {
    return split(s).length
}

function exporter(State, ...args) {
    const state = isClassObject(State)
        ? State
        : new State(...args)

    const keys = [
        'getValue',
        'parse',
        'run',
        'build',
        'calculate',
        'toJSON',
        'toString',
    ]

    const key = keys.find((x) => x in state)
    return state[key].bind(state)
}

function stateTrace(state, fnKey) {
    state[fnKey] = trace(state[fnKey].bind(state))
}
class CodeLibrary {
    constructor(s) {
        const functions = getfunctions(s.toString())
        this.store = mapfilter(functions, getFunctionInfo)
    }
    get lib() {
        if (!this._lib) {
            this._lib = reduce(this.store, (x) => {
                return [x.name, x.body]
            })
        }
        return this._lib
    }

    get(key) {
        if (isNumber(key)) {
            const value = this.store[key - 1]
            return value || {}
        }
        if (isArray(key)) {
            return key.map((x) => this.lib[x]).filter(exists)
        }
        const item = this.find(key)
        return item
    }
    find(name) {
        let item = this.store.find((x) => x.name == name)
        if (!item) item = this.store.find((x) => test(name, x))
        if (!item) item = {}
        return item
    }
}

function getfunctions(s, mode = 'js') {
    return split(
        s,
        /\n+(?=export \w+|const|async|class|(@.+\n)*function|var|let)/
    ).map(trim)
}

function mapfilter(items, fn, filter) {
    //console.log([items])
    const store = []
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        if (!item) continue
        let value = fn(item, i)
        if (value) {
            if (filter && !filter(value)) continue
            store.push(value)
        }
    }
    return store
}

function getParamInfo(s) {
    const params = getParameters(s)
    let length = params.length
    if (params.includes('...')) {
        length += 99
    }
    return { params, length }
}
function countParameters(v) {
    if (!v) return 0
    if (getFirstLine(v.toString()).includes('...')) {
        return 100
    }
    return getParameters(v).length
}
function getParameters(s) {
    let r1 = /^function \w+ *\((.*?(?:} = {[^]+?)?)\) {/
    let r2 = /^\w+ *\((.*?(?:} = {[^]+?)?)\) {/
    let r3 = /^.*?=>/
    let m = itersearch(s.toString(), r1, r2, r3)
    //console.log(m)
    if (!m) return []
    return findall(/(?:\.\.\.)?(\w+)(?:,|$| *=>|\))/g, m)
}

function scopedEval(expr, context) {
    if (!exists(context)) {
        return eval(expr)
    }
    const evaluator = Function.call(
        null,
        ...Object.keys(context),
        'expr',
        "return eval('expr = undefined;' + expr)"
    )
    return evaluator.call(null, ...Object.values(context), expr)
}

function timegetter(message) {
    let time = Date.now()
    return time
    console.log(timestamp(), message || '')
    return time
}
function getErrorInfo(e, options = {}) {
    if (isString(e)) {
        return console.log({ myError: e })
    }

    let s = e.stack
    let match = search(/<anonymous>:(\d+):(\d+)/, s)
    if (!match) {
        return
    }
    match = match.map(Number)
    if (options.offset) {
        match = match.map((x, i) => x - options.offset[i])
    }

    let [name, message] = search(/(\w+): *(.*)/, s)
    let value
    let proposedFixFn
    let template
    if (name == 'ReferenceError') {
        value = search(/[\w.]+/, message)
    }

    if (name == 'SyntaxError') {
        value = search(/[\w.]+/, message)
        //template = `let ${value} = ''\n$1`
        //proposedFixFn = templateToFunction(template)
        //console.log(proposedFixFn.toString(), 'fixfn')
    }
    return {
        line: match[0],
        ch: match[1],
        name,
        message,
        value,
        proposedFixFn,
    }
}

function getDetailedErrorInfo(e) {
    let s = e.stack.slice(0, -465)
    let [name, message] = search(/(\w+): *(.*)/, s)

    let regex = /^ *at (\S+) \((.*?):(\d+):(\d+)/gm
    let stack = findall(regex, s).map(
        ([caller, file, line, ch], i) => {
            line = Number(line)
            ch = Number(ch)
            if (caller.includes('.')) {
                let [className, method] = caller.split('.')
                return {
                    class: className,
                    method,
                    file,
                    line: Number(),
                    ch,
                }
            }
            return { caller, file, line, ch }
        }
    )
    return {
        name,
        message,
        stack,
    }
}

class ItemIter {
    constructor(items) {
        this.load(items)
    }
    next() {
        if (this.index > this.items.length - 1) return false
        this.value = this.items[this.index++]
        return true
    }
    load(s) {
        if (!s) return
        const items = xsplit(s)
        this.items = items
        this.index = 0
        this.ei = 0
        this.value = this.items[this.index++]
        return items
    }
}

function forEach(items, fn, options) {
    const iter = new Iter(items)
    const clock = new Clock(iter.size)
    clock.setOptions(options)
    clock.onTick = () => {
        fn(iter.value)
        iter.next()
    }
    return clock.start()
}

function getTrace() {
    let f = (x) => {
        return !test(/anony|assert|Module|proxy|invoke/i, x[0])
    }
    return getStackTrace().slice(3).filter(f)
}

function getCaller(target, simple = true, error = null) {
    let stack = getStackTrace(error)
        .slice(3)
        .filter(([a, b]) => {
            return !test(/proxy|invoke/i, a)
        })

    if (simple) stack = stack.map((x) => x[0])
    switch (target) {
        case '':
        case null:
        case undefined:
        case 0:
            return stack[0]
        case -1:
        case -2:
        case -3:
        case 1:
            return stack[Math.abs(target)]
        case 2:
            return stack[2] + '-' + stack[1]
        case 3:
            return stack[3] + '-' + stack[2] + '-' + stack[1]
        default:
            return stack.find(testf(target))
    }
}

function vars(obj) {
    let s
    let name
    let _type
    if (!obj.prototype) {
        s = obj.constructor.toString()
        name = obj.constructor.name
        _type = 'class'
    } else if (obj.name) {
        name = obj.name
        s = obj.toString()
        _type = type(obj)
    }
    const info = { name, type: _type }

    let props = getClassProperties(s)
    if (!exists(props)) {
        props = Object.getOwnPropertyNames(props)
    }

    return { props, ...info }
}

function trywrap(fn, handler) {
    return (...args) => {
        try {
            return fn(...args)
        } catch (e) {
            return handler(e)
        }
    }
}
function stringIIFEWrap(s) {
    const value = parens(brackify('() =>', s)) + '()'
    //console.log(value)
    //console.log(value); throw ''
    return value
}
function stringTryWrap(s) {
    const fix = `return getErrorInfo(e, {offset: [3, 9]})`
    return stringIIFEWrap(
        brackify('try', s) + ' ' + brackify('catch(e)', fix)
    )
}

function getLoggableProperties(x) {
    let value = isClass(x)
        ? getClassProperties(x)
        : stringify(x)
    return value
}

function removeStrings(s) {
    return s.replace(/\'.*?\'|\".*?\"|\`[^]*?\`/g, '')
}

function addf(s) {
    return (x) => x + s
}

function lineCount(s) {
    return count('\n', s.trim()) + 1
}

function saybye(s = '') {
    return 'bye ' + s
}

function sayhi(x = '', greeting = 'Hello') {
    const message = `${greeting} from ${x}`
    console.log(message)
    return message
}

function captureRegex(regex, flags) {
    if (isString(regex)) {
        return RegExp(parens(regex, flags))
    } else {
        return RegExp(parens(regex.source), regex.flags)
    }
}

function splitLast(s, regex, flags) {
    const items = s.split(captureRegex(regex, flags))
    let a = items[0]
    let b = ''
    //console.log(items)
    for (let i = 1; i < items.length - 1; i += 2) {
        let item = items[i]
        let next = items[i + 1]

        if (i == items.length - 2) {
            b += item
            b += next
            return [a, b]
        } else {
            a += item
            a += next
        }
    }
}
function replaceLast(regex, replacement, s) {
    let match
    let lastMatch
    regex = addGFlag(regex)
    while (exists((match = regex.exec(s)))) {
        lastMatch = match
    }
    let index = lastMatch.index
    let length = lastMatch[0].length
    return (
        s.slice(0, index) +
        replacement +
        s.slice(index + length)
    )
}
function bringFunctionToLife(s) {
    let [text, isAsync] = mreplace(/^async /, s)
    if (isStringObjectFunction(text)) {
        text = 'function ' + text
    }

    if (isAsync) text = 'async ' + text
    const fnString = parens(fixMultiplication(text))
    return tryval2(fnString)
}

function bringToLife(s, context) {
    try {
        if (!isString(s)) return s
        if (context) return scopedEval(s, context)
        if (isStringFunction(s)) {
            return bringFunctionToLife(s)
        }
        if (isCodeWord(s)) {
            return eval(s)
        }
        let template = `(${getVariables(s).join(', ')}) => ${s}`
        return bringFunctionToLife(template)
    } catch (e) {
        return null
    }
}

function getVariable(s) {
    const regex = /\b[abcdexyzsir]\b/g
    return search(regex, s)
}

function addNestedProperty(base, ...args) {
    let ref = base
    if (args[0].includes('.')) {
        args.unshift(...args.shift().split('.'))
    }
    for (let i = 0; i < args.length; i++) {
        let arg = args[i]

        if (i == args.length - 2) {
            ref[args[i]] = args[i + 1]
            break
        } else {
            if (!ref.hasOwnProperty(arg)) {
                ref[arg] = {}
            }
            ref = ref[arg]
        }
    }
    return base
}
function addDeepKey(ref, key, value) {
    let [keys, last] = splitOnceReverse(key, '.')
    keys.forEach((item, i) => {
        if (!ref.hasOwnProperty(item)) {
            ref[item] = {}
        }
        ref = ref[item]
    })
    ref[last] = toArgument(value)
    return ref
}

function collectObjectFromString(s) {
    split(s, deli)
}
function isProse(s) {
    if (/\\/.test(s)) return false
    const p = test(/^(?:[\.\,] )?[a-zA-Z]{2,}/, s)
    return p
}

function looksLikeProse(s) {
    if (/\\/.test(s)) return false
    const p = test(/^(?:[\.\,] )?[a-zA-Z]{2,}/, s)
    return p
}

function getFirstParameter(fn) {
    return search(/\((\w+)/, String(fn))
}
function isStandardHtml(s) {
    const natives = [
        //'html',
        //'main',
        'body',
        'div',
        'p',
        'a',
        'section',
        'iframe',
        'ul',
        'li',
        'header',
        'footer',
    ]
    return natives.includes(s)
}

function fixUrl(s) {
    if (s.includes('kdog3682')) return 'file:///' + s
    s = s.replace(/view-source:/, '')
    if (!test('^http', s)) s = 'https://' + s
    if (!s.includes('.')) s += '.com'
    return s
}

function isSymbol(s) {
    return test(/^[\W\s]\W*$/, s)
}

//function consoleThrow(...args) {
//console.log(...args)
//}

function getChunks(s, regex) {
    if (!regex) regex = /\n+(?=[\w.#])/
    return s.trim().split(regex).map(trim)
}

function pluralize(word, amount) {
    //console.log({word, amount})
    if (amount !== undefined && amount === 1) {
        return word
    }
    const plural = {
        '(quiz)$': '$1zes',
        '^(ox)$': '$1en',
        '([m|l])ouse$': '$1ice',
        '(matr|vert|ind)ix|ex$': '$1ices',
        '(x|ch|ss|sh)$': '$1es',
        '([^aeiouy]|qu)y$': '$1ies',
        '(hive)$': '$1s',
        '(?:([^f])fe|([lr])f)$': '$1$2ves',
        '(shea|lea|loa|thie)f$': '$1ves',
        sis$: 'ses',
        '([ti])um$': '$1a',
        '(tomat|potat|ech|her|vet)o$': '$1oes',
        '(bu)s$': '$1ses',
        '(alias)$': '$1es',
        '(octop)us$': '$1i',
        '(ax|test)is$': '$1es',
        '(us)$': '$1es',
        '([^s]+)$': '$1s',
    }
    const irregular = {
        move: 'moves',
        foot: 'feet',
        goose: 'geese',
        sex: 'sexes',
        child: 'children',
        man: 'men',
        tooth: 'teeth',
        person: 'people',
    }
    const uncountable = [
        'sheep',
        'fish',
        'deer',
        'moose',
        'series',
        'species',
        'money',
        'rice',
        'information',
        'equipment',
        'bison',
        'cod',
        'offspring',
        'pike',
        'salmon',
        'shrimp',
        'swine',
        'trout',
        'aircraft',
        'hovercraft',
        'spacecraft',
        'sugar',
        'tuna',
        'you',
        'wood',
    ]
    if (uncountable.indexOf(word.toLowerCase()) >= 0) {
        return word
    }
    for (const w in irregular) {
        const pattern = new RegExp(`${w}$`, 'i')
        const replace = irregular[w]
        if (pattern.test(word)) {
            return word.replace(pattern, replace)
        }
    }

    for (const reg in plural) {
        const pattern = new RegExp(reg, 'i')
        if (pattern.test(word)) {
            return word.replace(pattern, plural[reg])
        }
    }
    return word
}

function depluralize(word, amount) {
    if (amount !== undefined && amount !== 1) {
        return word
    }
    const singular = {
        '(quiz)zes$': '$1',
        '(matr)ices$': '$1ix',
        '(vert|ind)ices$': '$1ex',
        '^(ox)en$': '$1',
        '(alias)es$': '$1',
        '(octop|vir)i$': '$1us',
        '(cris|ax|test)es$': '$1is',
        '(shoe)s$': '$1',
        '(o)es$': '$1',
        '(bus)es$': '$1',
        '([m|l])ice$': '$1ouse',
        '(x|ch|ss|sh)es$': '$1',
        '(m)ovies$': '$1ovie',
        '(s)eries$': '$1eries',
        '([^aeiouy]|qu)ies$': '$1y',
        '([lr])ves$': '$1f',
        '(tive)s$': '$1',
        '(hive)s$': '$1',
        '(li|wi|kni)ves$': '$1fe',
        '(shea|loa|lea|thie)ves$': '$1f',
        '(^analy)ses$': '$1sis',
        '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$':
            '$1$2sis',
        '([ti])a$': '$1um',
        '(n)ews$': '$1ews',
        '(h|bl)ouses$': '$1ouse',
        '(corpse)s$': '$1',
        '(us)es$': '$1',
        s$: '',
    }
    const irregular = {
        move: 'moves',
        foot: 'feet',
        goose: 'geese',
        sex: 'sexes',
        child: 'children',
        man: 'men',
        tooth: 'teeth',
        person: 'people',
    }
    const uncountable = [
        'sheep',
        'fish',
        'deer',
        'moose',
        'series',
        'species',
        'money',
        'rice',
        'information',
        'equipment',
        'bison',
        'cod',
        'offspring',
        'pike',
        'salmon',
        'shrimp',
        'swine',
        'trout',
        'aircraft',
        'hovercraft',
        'spacecraft',
        'sugar',
        'tuna',
        'you',
        'wood',
    ]
    // save some time in the case that singular and plural are the same
    if (uncountable.indexOf(word.toLowerCase()) >= 0) {
        return word
    }
    // check for irregular forms
    for (const w in irregular) {
        const pattern = new RegExp(`${irregular[w]}$`, 'i')
        const replace = w
        if (pattern.test(word)) {
            return word.replace(pattern, replace)
        }
    }
    // check for matches using regular expressions
    for (const reg in singular) {
        const pattern = new RegExp(reg, 'i')
        if (pattern.test(word)) {
            return word.replace(pattern, singular[reg])
        }
    }
    return word
}

function findallStrings(s) {
    return findall(/\'.*?\'|\".*?\"/g, s).map((x) =>
        x.slice(1, -1)
    )
}

function isStandardCss(s) {
    if (test(/^.*?{/, s)) return true
}
function isDoubleIterable(x) {
    return isArray(x[0]) && x[0].length == 2
}
function reduceToString(iterable, fn, options = 'entries') {
    const outputter = (runner, m = 'entries', d = '\n\n') => {
        let a = prepareIterable(iterable, m)
        return join(filter(map(a, runner)), d)
    }

    const params = getParameters(fn)

    switch (params.length) {
        case 0:
            throw 'no params'
        case 1:
            switch (params[0]) {
                case 'v':
                case 'items':
                    return outputter(fn, 'values')
                default:
                    return outputter(fn, 'keys')
            }
        case 2:
            return outputter(fn, 'entries')
    }
}

function wrap(s, delimiter = '\n') {
    if (isArray(delimiter)) return `[${s}]`
    if (delimiter == '[]') return `[${s}]`
    if (delimiter == '{}') return `{${s}}`
    if (delimiter == '()') return `(${s})`
    return delimiter + s + delimiter
}

function hasOwn(obj, key) {
    return obj.hasOwnProperty(key)
}

function startsWithSymbol(s) {
    const startsWithSymbolRE = /^[^\w\s]/
    return test(startsWithSymbolRE, s)
}

function splitOnceSymbolOrWord(s) {
    const value = startsWithSymbol(s)
        ? search(/^([^\w\s]+)(.*)/, s)
        : search(/^(\w+) (\w.*)/, s)

    if (!value) return [null, null]
    if (value.length == 1) return [value, null]
    return value
}

class IndexError extends Error {
    constructor(...args) {
        super(...args)
    }
}

function mergeProps(...args) {
    const store = {}

    function childRunner(store, k, v) {
        let current = store[k]
        if (isObject(v)) {
            runner(v, current)
        } else if (isArray(v)) {
            for (let item of v) {
                if (!current.includes(item)) {
                    store[k].push(item)
                }
            }
        } else if (isFunction(v)) {
            store[k] = mergeFunction(current, v)
        }
    }
    function runner(arg, store) {
        if (!arg) return
        for (let [k, v] of Object.entries(arg)) {
            if (store.hasOwnProperty(k)) {
                childRunner(store, k, v)
            } else {
                store[k] = v
            }
        }
    }

    for (let arg of args) {
        runner(arg, store)
    }
    return store
}

function mergeFunction(current, next) {
    return function mergedFunction(...args) {
        let a = current(...args)
        let b = next(...args)
    }
}
function compose(...functions) {
    return function lambda(...args) {
        for (let i = functions.length - 1; i >= 0; i--) {
            let f = functions[i]
            if (i == functions.length - 1) {
                val = f(...args)
            } else {
                val = f(val)
            }
        }
        return val
    }
}

function coerceToArray(x) {
    if (x == null) return []
    if (isString(x)) {
        return split(x)
    }
    return [x]
}

function coerceToString(x) {
    return x.toString()
}

function coerceToNumber(x) {
    //console.log([x])
    if (isNumber(x)) {
        return Number(x)
    }
    if (isString(x)) {
        let y = wordToNumber(x)
        if (y > -1) return x
        return Number(x.replace(/\D+/g, ''))
    }
}

function startsWithPeriod(s) {
    return test(/^\./, s)
}

function splitOptionalComma(s) {
    return s.trim().split(/,? +/)
}

function brackify(name, value) {
    return (
        (name ? name + ' ' : '') +
        '{' +
        newlineIndent(value) +
        '}'
    )
}

function hasColon(s) {
    return test(/:/, s)
}

function curryEnd(fn, ...args) {
    return (...bargs) => fn(...bargs, ...args)
}

function curryStart(fn, ...args) {
    if (!isFunction(fn)) {
        return stateCurryStart(fn, ...args)
    }
    return (...bargs) => fn(...args, ...bargs)
}

function hasDash(s) {
    return test(/-/, s)
}
function getFirstLine(s) {
    return s.match(/^.*/)[0]
}

function removeStartingSpaces(s) {
    return s.toString().replace(/^\n*/, '').trimEnd()
}

function toFunctionRegex(s, flags = 'm') {
    const ignore = ['run']
    if (s.length <= 2 && !ignore.includes(s)) {
        s = toAbbreviationRegex(s)
    }
    return RegExp(
        '^(?:(?:async )?function|class|const|var) ' +
            s +
            '\\b[\\w\\W]*?\\n}',
        flags
    )
}

function getSpacesFromOffset(offset, original) {
    let ch
    let s = ''
    let a = offset
    while (a > 0 && ch != '\n') {
        ch = original.charAt(a--)
        s += ch
    }
    let spaces = search(/ +(?=\n)/, s)
    return (spaces && spaces.length) || 0
}

function countParentheses(s) {
    return count(/[()]/, s)
    //return (match(/(?:[^\\]|^)\((?![\?])/g) || []).length
}

function countCaptureGroups(regex) {
    let s = regex.source || regex
    return (s.match(/(?:[^\\]|^)\((?![\?])/g) || []).length
}

function getLastLine(s) {
    return s.match(/.*?$/)[0]
}

function iterSearch(s, regexes, mode = 'match') {
    for (let regex of regexes) {
        let value =
            mode == 'search' ? search(regex, s) : s.match(regex)

        if (value) {
            return value
        }
    }
    return null
}

function itersearch(s, ...regexes) {
    if (!s) return
    s = s.trim()
    for (let regex of regexes) {
        let value = search(regex, s)
        if (value) {
            return value
        }
    }
    return null
}

function findError(s) {
    const chunks = getChunks(s)
    const store = []

    for (let chunk of chunks) {
        try {
            eval(chunk)
        } catch (e) {
            if (e.constructor.name == 'ReferenceError') {
                continue
            }
            store.push([e.toString(), chunk])
        }
    }
    console.log(store)
    console.log(store.length)
    return store
}

function hasCamelCase(s) {
    return test(/[a-z][A-Z]/, s)
}

function lbreplace(regex, replacement, s, flags) {
    let lbRegex
    let newRegex

    if (isRegExp(regex)) {
        regex = regex.toString()
        flags = regex.match(/\/(\w+)$/)
        flags = (flags && flags[1]) || ''
        regex = regex.slice(1).replace(/\/\w*$/, '')
        //console.log(regex)
    }

    if (test(/\?<=/, regex)) {
        let temp = ''
        let index = 0
        let close = 0
        let open = 0
        while (true) {
            let prev = regex[index - 1]
            let char = regex[index++]
            if (prev != '\\') {
                if (char == '(') {
                    open += 1
                } else if (char == ')') {
                    close += 1
                }
            }
            temp += char
            if (open == close) {
                break
            }
        }

        newRegex = regex.replace(/\?<=/, '?:')
        lbRegex = temp.replace(/\?<=/, '?:')
        return replace(newRegex, parser, s, flags)
    } else {
        return replace(regex, replacement, s, flags)
    }

    function parser(...args) {
        let x = args[0]
        //console.log(lbRegex); throw ''
        //console.log(x); throw ''
        let [text, lb] = mreplace(
            lbRegex,
            '',
            x,
            flags.replace('g', '')
        )
        //console.log([text, lb]); throw ''
        let value = isFunction(replacement)
            ? replacement(text, ...args.slice(1))
            : replacement
        return lb + value
    }
}

function sreplace(s, r, f, flags = 'g') {
    r = rescape(r).replace(/\\\$1/g, '(\\w+)')
    return s.replace(RegExp(r, flags), (_, x) => {
        return eval(f.replace(/\$1/, singlequote(x)))
    })
}

function toRequireString(s) {
    return `const ${removeExtension(s)} = require('${s}')`
}

function removeFunctionPrefix(s) {
    return s.replace(/function /, '')
}
function removeExtension(s) {
    return s.replace(/\.\w+$/, '')
}

function getStackTrace(e) {
    if (!e) e = createError()
    const s = isString(e) ? e : e.stack
    const r =
        /at (?:new |Object\.)?([<>a-zA-Z0-9\.]+) .*?(\d+):\d+\)/g
    return findall(r, s)
}

function isCss(s) {
    return test(/^\./, s)
}
class IndexedMap {
    combine(...args) {
        const map = new IndexedMap()
        map.keys = this.keys
        map.values = this.values

        for (let arg of args) {
            map.set(...arg)
        }
        return map
    }

    [Symbol.iterator]() {
        this.index = 0
        return this
    }
    next() {
        const value = this.values[this.index++]
        const done = this.index > this.values.length
        return { value, done }
    }

    constructor() {
        this.index = 0
        this.values = []
        this.keys = []
    }
    has(k) {
        return this.keys.includes(k)
    }
    set(k, v) {
        if (this.has(k)) {
            const index = this.keys.indexOf(k)
            this.values[index] = v
        } else {
            this.keys.push(k)
            this.values.push(v)
        }
    }
    get size() {
        return this.keys.length
    }
    getValue(key) {
        try {
            return this.get(key)[1]
        } catch (e) {
            return null
        }
    }
    get(key, update = true) {
        let index = this.index
        if (!key) {
            index = 0
        } else if (key == 1 || key == -1) {
            index += key
            if (index == this.size) index = 0
            else if (index == -1) index = this.size - 1
        } else if (isNumber(key)) {
            index = Number(key)
            if (index >= this.size) index = this.size - 1
            if (index < 0) index = 0
        } else if (isString(key)) {
            key = fuzzyMatch(key, this.keys)
            if (key) {
                index = this.keys.indexOf(key)
            } else {
                return [null, null]
            }
        }
        if (update) {
            this.index = index
            this.key = this.keys[this.index]
            this.value = this.values[this.index]
            return [this.key, this.value]
        } else {
            return [this.keys[index], this.values[index]]
        }
    }
}

function isSingleCssProperty(s) {
    return test(/^.*?{\n.+\n}/, s)
}

function smartDedent(s) {
    s = removeComments(s)
    s = replace(/^\n*|\n$/g, '', s, 'g')
    const spaces = search(/^ *(?=\S)/m, s)
    const secondLineSpaces = search(/\n *(?=\S)/, s)
    if (
        !spaces &&
        secondLineSpaces &&
        secondLineSpaces.length > 4
    ) {
        return replace(
            '^' + secondLineSpaces.slice(5),
            '',
            s,
            'gm'
        ).trim()
    } else {
        s = replace('^' + spaces, '', s, 'gm')
        s = removeComments(s)
        return s.trim()
    }
}

class Iter {
    set parser(fn) {
        this._parser = fn
    }
    get size() {
        return this.items.length
    }
    constructor(x) {
        this.items = xsplit(x)
        this.index = 0
    }
    test(x) {
        return ftest(x, this.value)
    }
    break() {
        this.index--
    }
    peek() {
        return this.items[this.index]
    }
    get remaining() {
        return this.items.slice(this.index)
    }
    replace(x) {
        this.items[this.index] = fparse(x, this.value)
    }
    next() {
        if (this.index > this.items.length - 1) return false
        this.value = this.items[this.index++]
        this.nextValue = this.items[this.index]
        if (this._parser) this.parsed = this._parser(this.value)
        if (this._sets) {
            for (let [k, v] of Object.entries(this._sets)) {
                this[k] = v(this.value)
            }
        }
        return true
    }

    set(key, fn) {
        if (!this._sets) this._sets = {}
        this._sets[key] = fn
    }
}

class LineEdit {
    static LineEdit(s, fn) {
        return s
            .trim()
            .split('\n')
            .map(fn)
            .filter((x) => x != null)
            .join('\n')
    }
    toString() {
        return this.getValue()
    }

    insertLineBelow(index, content) {
        this.getset(index, (line, spaces) => {
            const spacing = isEnterBlock(line) ? 4 : 0
            return indent(content, spacing) + '\n' + line
        })
    }

    insertLineAbove(index, content) {
        this.getset(index, (line, spaces) => {
            return content + '\n' + line
        })
    }

    get(n) {
        return this.lines[n]
    }

    delete(n) {
        this.lines[n] = null
    }

    get prev() {
        return this.lines[this.index - 1]
    }

    get next() {
        let count = this.index + 1
        let line = this.get(count)
        while (!exists(line)) {
            line = this.get(count++)
        }
        return line
    }

    get isLast() {
        return this.index == this.lines.length - 1
    }
    get last() {
        return this.lines[this.lines.length - 1]
    }

    getset(index, fn, ...args) {
        let line = this.get(index)
        let spaces = getSpaces(line)
        let payload = fn(line, spaces.length, ...args)
        this.set(payload)
    }

    find(regex, n = -1) {
        let a = this.index - 1
        let match
        let line
        let count = 0

        do {
            line = this.getLine(a)
            match = search(regex, line)
            a += n
        } while (!match || count++ < 100)
        return match
    }

    peek(x) {
        if (x) {
            let a = this.index + 1
            let next = this.lines[a]
            while (a < this.lines.length && !ftest(x, next)) {
                next = this.lines[a++]
            }
            return next
        }
        return this.lines[this.index + 1]
    }

    getValue() {
        return join(this.store.filter(String))
    }

    deleteRange(range) {
        let [from, to] = range
        for (let i = from; i < to; i++) {
            this.deleteLine(i)
        }
    }

    replaceRange(range, fn) {
        const block = this.getRange(...range)
        this.deleteRange(range)
        const replacement = fn(block)
        this.setLine(range[0], replacement)
        this.lastIndex = range[1]
    }

    getRange(from, to) {
        return this.lines
            .slice(from, to || this.lines.length)
            .join('\n')
    }

    constructor(parser, config) {
        if (parser) this.parser = parser.bind(this)
        this.tabWidth = 4
        this.config = { trim: true }
        Object.assign(this.config, config)
    }

    reset() {
        this.tracker = {}
        this.store = []
        this.index = 0
    }

    run(s) {
        this.reset()
        this.lines = (this.s || s).trim().split('\n')

        for (let i = 0; i < this.lines.length; i++) {
            const original = this.lines[i]
            const [indentation, line] =
                getIndentAndLine(original)
            const lineValue = this.config.trim ? line : original

            this.spaces = indentation
            this.index = i
            this.parser(lineValue, indentation, i)
        }
        return this
    }

    insert(index, value) {
        let [spaces, line] = getSpacesAndLine(this.get(index))
        const payload =
            spaces + (isFunction(value) ? value(line) : value)
        insert(this.lines, payload, index)
    }

    set(value, spaces) {
        const payload = indent(
            value,
            spaces == null ? this.spaces : spaces
        )
        if (isArray(payload)) {
            this.store.push(...payload)
        } else {
            this.store.push(payload)
        }
    }
}

function isEnterBlock(s) {
    return /[:{(\[] *$/.test(s)
}

function fixSpaceLength(n) {
    switch (n) {
        case 1:
            return 0
        case 2:
            return 4
        case 3:
            return 4
        case 4:
            return 4
        case 5:
            return 4
        case 6:
            return 8
        case 7:
            return 8
        case 8:
            return 8
        case 10:
            return 12
        case 11:
            return 12
    }
    return n
}

function isHtml(s) {
    if (!isString(s)) return false
    if (test(/<\w/, s)) {
        return true
    }
}

function isHtmlAttr(s) {
    if (test(/^\.|foo/, s)) {
        return true
    }
}

class EventEmitter {
    constructor() {
        this.events = {}
    }
    on(e, listener) {
        if (isObject(e)) {
            for (let [k, v] of Object.entries(e)) {
                this.on(k, v)
            }
            return
        }

        if (typeof this.events[e] !== 'object') {
            this.events[e] = []
        }
        this.events[e].push(listener)
        return () => this.removeListener(e, listener)
    }
    removeListener(e, listener) {
        if (typeof this.events[e] === 'object') {
            const index = this.events[e].indexOf(listener)
            if (index > -1) {
                this.events[e].splice(index, 1)
            }
        }
    }
    emit(e, ...args) {
        if (typeof this.events[e] === 'object') {
            this.events[e].forEach((listener) => {
                listener.apply(this, args)
            })
        }
    }
    once(e, listener) {
        const remove = this.on(e, (...args) => {
            remove()
            listener.apply(this, args)
        })
    }
}

function testf(regex, flags = '') {
    if (isFunction(regex)) {
        return regex
    }

    if (isString(regex)) {
        if (isWord(regex)) {
            regex = RegExp(boundary(regex), flags + 'i')
        } else {
            regex = RegExp(regex)
        }
    }
    return function lambdaTest(s) {
        if (flags == -1) {
            return !regex.test(s)
        }
        return regex.test(s)
    }
}

const vmap = {
    'v-bind': 'v-bind',
    style: ':style',
    enter: '@keydown.enter',
    tc: 'textContent',
    t: 'textContent',
    ih: 'innerHTML',
    bind: 'v-bind',
    ref: 'ref',
    show: 'v-show',
    click: '@click',
    tg: 'transition-group',
    if: 'v-if',
    elif: 'v-else-if',
    else: 'v-else',
    key: ':key',
    for: 'v-for',
    fori: 'v-for',
    vfor: 'v-for',
    html: 'v-html',
    model: 'v-model',
}

function atObject(o) {
    if (isObject(o)) {
        return (x) => {
            for (let [k, v] of Object.entries(o)) {
                x[k] = v(x[k])
            }
            return x
        }
    }
    return (x) => {
        return {
            [o]: arguments[1] ? arguments[1](x) : x,
        }
    }
}

function atFirst(fn, ...args) {
    return (x) => [fn(x[0], ...args), x[1]]
}

function filterFirst(fn, ...args) {
    return (x) => fn(x[1])
}

function filterSecond(fn, ...args) {
    return (x) => fn(x[1])
}

function log(s) {
    return `console.log(${s})`
}
function logger(x) {
    //dumb
    if (isClassObject(x)) {
        return x
    } else if (isPrimitive(x)) {
        return x
    } else {
        return stringify(x)
    }
}

function run(State, ...args) {
    try {
        const state = new State()
        const value = state.run(...args)
        console.log(value)
        //console.log(logger(value))
        return
    } catch (e) {
        console.log(e)
        //const value = State(...args)
        //console.log(logger(value))
        //l e
    }
}

class IncrementalBuilder {
    constructor() {}
}

function getUniqueLetters(s) {
    return unique(findall(/\w/g, s))
}

function isAllEqual(x) {
    return x.every((item) => item == item[0])
}

function fillTo(items, item, amount) {
    if (arguments.length == 2) {
        amount = item
        item = getLast(items)
    }

    while (items.length < amount) {
        items.push(item)
    }
    return items
}
class Builder {
    constructor() {
        this.start = []
        this.end = []
    }
    append(x) {
        this.end.push(x)
    }
    prepend(x) {
        this.start.push(x)
    }
    toString() {
        const lines = [...this.start.reverse(), ...this.end]
        return join(lines)
    }
}

function getVariablesFromString(s) {
    const regex =
        /\w+\(|\b(?:if|else|while|for|do)\b|\/.*?\/\w*|'.*?'|".*?"/g
    return getWords(s.replace(regex, ''))
}

function toStringFunction(
    name,
    params,
    body,
    {
        form = 'function',
        lambda = false,
        private = false,
        mode = String,
    } = {}
) {
    if (arguments.length == 1) {
        return toStringFunction('hi', 'hi', arguments[0], {
            mode: Function,
            lambda: true,
        })
    }
    if (isArray(params)) {
        params = params.join(', ')
    }
    params = params ? params : ''

    let fn
    if (lambda) {
        fn = brackify(`(${params}) =>`, body)
        return mode == String ? fn : bringToLife(fn)
    }
    name = name.trim()
    if (private) name = '__' + name
    fn = brackify(`function ${name}(${params})`, body)
    let p = mode == String ? fn : bringToLife(fn)
    if (form == 'dict') p = p.replace('function ', '')
    return p
}

function checkjs(s) {
    s = s.replace(
        /^[\w\.]+\( *(?:\n[^]+?\n\)|\{ *\n[^]+?\n\}\)|.+)/gm,
        ''
    )
    //console.log(s)
    try {
        return true
        eval(s)
    } catch (e) {
        console.log(e)
        return false
    }
}

function toAbbreviationRegex(input, splatLength = 1) {
    let letters = split(input, '')
    let s = ''
    //let m = '\\w'
    let m = '[a-z]'
    //let fg = {${splatLength - 1},}
    for (let i = 0; i < letters.length; i++) {
        let letter = letters[i]
        if (i == 0) {
            s += `[${letter}${capitalize(letter)}]`
            s += `${m}*`
        } else if (i == letters.length - 1) {
            s += `(?:[-_.][${letter}${capitalize(letter)}]`
            s += `|${capitalize(letter)})`
            s += '\\w*'
        } else {
            s += `(?:[-_.][${letter}${capitalize(letter)}]`
            s += `|${capitalize(letter)})`
            s += `${m}*`
        }
    }
    //console.log([s, 'abr'])
    return s
}

function expensiveFuzzyMatch(input, choices, mode) {
    choices = prepareIterable(choices, 'keys')

    const FuzzyMatchTests = [
        (x) => test('^' + input, x, 'i'),
        //(x) => test('^' + toAbbreviationRegex(input) + '$', x),
        (x) =>
            test(
                '^' + toAbbreviationRegex(input) + '$',
                removeExtension(x)
            ),
    ]

    if (choices.includes(input)) {
        return input
    }

    if (hasSymbol(input)) {
        let results = choices.filter(FuzzyMatchTests[0])
        return getLongest(results)
    }

    const [a, b] = FuzzyMatchTests.map((x) => choices.filter(x))
    //console.log([a, b])
    /* a = startswith */
    /* b = abbreviate */

    if (a.length == 0 && b.length == 0) return
    if (a.length != 1 && b.length == 1) {
        return b[0]
    }
    if (b.length != 1 && a.length == 1) {
        return a[0]
    }
    if (a.length == 1 && b.length == 1) {
        return b[0]
    }
    if (mode == Array) return recursiveFlat(a, b)
    return getLongest(getShortest([a, b]))
}

function fuzzyMatch(input, choices) {
    if (!choices || choices.length == 0) return
    if (isObject(choices)) choices = Object.keys(choices)

    if (choices.includes(input)) return input
    /* prelim */

    const cachedRegex = toAbbreviationRegex(input)
    const fuzzyMatchTests = [
        (x) => test('^' + cachedRegex + '$', x),
        (x) => test('^' + input, x, 'i'),
        (x) => test(input, x),
    ]

    let count = 0
    for (let test of fuzzyMatchTests) {
        if (count == 2) {
            return choices.find(test)
            let m = choices.map(test).filter(String)
            return getLongest(m, len, String)
        }

        let r = choices && choices.filter(test)
        if (exists(r)) {
            return getLongest(r, len, String)
        }
        count++
    }
}

function isAllSingleWords(s) {
    return test(/\w+/, s) && !test(/\w+ \w+/, s)
}

function startsWithSingleWord(s) {
    return test(/^(\w+)\n/m, s)
}

function countSpaces(s) {
    return count(/ +/g, s)
}
function count(regex, s, flags = 'g') {
    // error forgetting s
    if (isArray(s)) return s.filter(ftestFactory(regex)).length

    if (isString(regex)) {
        if (!test(/\\/, regex)) {
            regex = rescape(regex)
        }
        if (isWord(regex)) regex = '\\b' + regex + '\\b'
        regex = RegExp(regex, flags)
    }

    regex = addGFlag(regex)
    const matches = s.match(regex)
    return matches ? matches.length : 0
}

function isLogicFunction(s) {
    return test(/^(is|start|end|has)/, s)
}

function isGetFunction(x) {
    return test(/^get/, x)
}

function sortByOccurence(items, source, reverse = true) {
    const store = []
    for (let item of items) {
        store.push([item, count('\\b' + item + '\\(', source)])
    }
    return sorted(store, null, reverse).map((x) => x[0])
}

function toVimVariable(key, items) {
    if (arguments.length == 3) {
        let value = isPrimitive(arguments[2])
            ? doublequote(arguments[2])
            : toStringArgument(arguments[2])
        return `let g:${arguments[0]}[${arguments[1]}] = ${value}`
    }
    let value = isPrimitive(items)
        ? items
        : JSON.stringify(items)
    return `let g:${key} = ${value}`
}

function toConfig(s) {
    return reduce(s, (x) => [x, true])
}

function toVimDict(dict, key, value) {
    if (arguments.length == 4) {
        const [a, b, c, d] = Array.from(arguments)
        return `let g:${a}["${b}"]["${c}"] = "${d}"`
    }
    return `let g:${dict}["${key}"] = "${value}"`
}
function splitparsef(dict, fallback, regex = ' ') {
    return function splitparse(s) {
        let [a, b] = splitonce(s, regex)
        if (a in dict) {
            return dict[a](b)
        }
        return fallback(a, b, s)
    }
    // reminds me of argsplit...
}

function splitCamelCase(x, preserveCase) {
    return x
        .trim()
        .replace(
            /[a-z][A-Z]/g,
            (s) =>
                s[0] +
                ' ' +
                (preserveCase ? s[1] : s[1].toLowerCase())
        )
        .split(' ')
}

function mergeSingleLetters(s) {
    return s.replace(/(?:(?:^| )[a-zA-Z]\b){2,}/g, (x) => {
        let value = removeSpaces(x)
        return ' ' + value
    })
}

function fixPath(s) {
    if (test(/^[\'\"]/, s)) {
        s = s.slice(1, -1)
    }
    return test(/^\w/, s) ? './' + s : s
}
function once(fn, ...args) {
    if (typeof __once__ == 'undefined') {
        let value = fn(...args)
        if (value) {
            __once__ = value
            return value
        }
        return null
    }
    return __once__
}

const randomWords = ['APPLE', 'BANANA', 'CUCUBMBER']
function exciting() {
    if (typeof __once__ == 'undefined') {
        __once__ = copy(randomWords)
    }
    return { exciting: __once__.pop() }
}

function seen(x) {
    if (typeof __seen__ == 'undefined') {
        __seen__ = new Set()
    }
    if (__seen__.has(x)) {
        return true
    }
    __seen__.add(x)
    return false
}

class FunctionBuilder extends Builder {
    constructor() {
        super()
        this.params = []
        this.name = 'hiya'
    }
    setParams(...params) {
        this.params = params
    }
    getValue() {
        const value = parens(this.toString(String))
        //console.log('value of brought to life fn', value)
        return eval(value)
    }
    toString() {
        return toStringFunction(
            this.name,
            this.params,
            super.toString()
        )
        return `function ${this.name}(${this.params.join(
            ', '
        )}) {${newlineIndent(super.toString())}}`
    }
}

function splitNumberBoundary(s) {
    if (isNumber(s)) {
        return [Number(s), '']
    }
    return split(s, /(\d+)/).filter(exists).map(toNumber)
}

function functionProxy(context, method, fn) {
    return function functionProxyRunner(...args) {
        if (fn) fn()
        method.call(context, ...args)
    }
    //console.warn = functionProxy(console, console.warn, vueWarn)
}

s = `

<span class="test1 test2"></span>
<div class="test">
    <div>
        <input class="a" />
        <input class="b" />
    </div>
</div>

<span class="test1 ok test2"></span>
<div class="test fo">
    <div class="const">
        <input class="a" />
        <input class="c" />
    </div>
</div>


`

function isStorageSchema(x) {
    const entries = isObject(x) && Object.entries(x)
    return entries && entries[0] && isArray(entries[0][1])
}

function toStorageSchema(data) {
    const entries = isObject(data) && Object.entries(data)
    if (!exists(entries)) {
        return {}
    }
    const first = entries[0]
    if (isArray(first)) {
        return data
    }
    if (isObject(first)) {
        return reduce(entries, (k, v) => [k, [v]])
    }

    if (isString(first)) {
        console.log('is a stirng')
        return reduce(entries, (k, v) => [k, [v]])
    }
    return data
    //return entries && entries[0] && isArray(entries[0][1])
}

function getModuleExports(s) {
    const r = /^module\.exports\.(\w+)/gm
    return unique(findall(r, s))
}

const catpics = [
    //'dancing.jpg',
    'fist on chin.jpg',
    'flying.jpg',
    'like a boss.jpg',
    'ocean sunset.jpg',
    'pose f.jpg',
]

function regexTemplater(r, dict) {
    let s = r.source.replace(/\$(\w+)/g, (_, x) => {
        if (x == '1')
            return prepareIterable(dict, 'keys').join('|')
    })
    let value = RegExp(s, r.flags)
    return value
}

function dynamicGetterSetter(state, key, callback) {
    const get = () => {
        if (!state['_' + key]) {
            console.log('returning cached value of ', key)
            state['_' + key] = callback(state)
        }
        return state['_' + key]
    }

    const set = (val) => {
        state['_' + key] = val
    }
    Object.defineProperty(state, key, { get, set })
}

function hasReturnValue(s) {
    return test(/return \S/, s.toString())
}

function defineFunctionProperty(state, k, v) {
    if (hasReturnValue(v)) {
        const get = () => {
            const value = v(state)
            return value
        }
        Object.defineProperty(state, k, { get })
    } else {
        state[k] = (...args) => v(state, ...args)
    }
}
function defineProperty(state, k, v) {
    const get = () => {
        const value = v(state)
        return value
    }

    Object.defineProperty(state, k, { get })
}

function toArrayOrObjectList(s, mode) {
    const [a, b] = mode == Array ? ['[', ']'] : ['{', '}']
    return a + newlineIndent(s.join(',\n') + ',') + b
}

function isEven(n) {
    return n % 2 == 0
}

function isOdd(n) {
    return n % 2 == 1
}

function removeStartingSymbols(s) {
    return s.replace(/^\W+/, '')
}
function removeSymbols(s) {
    return s && s.replace(/[^\w-]+/g, '')
}

function edit(x, ...args) {
    /* functions are internal */
    if (isArray(x)) {
        return editArray(x, ...args)
    }

    if (isObject(x)) {
        return editObject(x, ...args)
    }

    function editArray(items, index, value) {
        if (isObject(items[0]) && isString(index)) {
            return copy(items).map((x) => {
                x[index] = fparse(value, x[index])
                return x
            })
        }
        if (isNumber(index) && index < 0) {
            index = items.length + index
        }
        if (isNestedArray(items)) {
            index = items.findIndex((x) => x[0] == index)
            items[index][1] = fparse(value, items[index][1])
        } else {
            items[index] = fparse(value, items[index])
        }
        return items
    }

    function editObjectFunctional(object, kt, vt) {
        return Object.entries(object).reduce((acc, [k, v]) => {
            acc[kt ? kt(k) : k] = vt ? vt(v) : v
            return acc
        }, {})

        return reduce(object, (k, v) => {
            if (kt) k = kt(k)
            if (vt) v = vt(v)
            return [k, v]
        })
    }

    function editObject(obj, key, fn, newObject) {
        if (newObject) {
            const store = {}
            for (let [k, v] of Object.entries(obj)) {
                if (key == k) {
                    store[key] = fn(v)
                } else {
                    store[k] = v
                }
            }
            return store
        }
        if (
            isFunction(arguments[1]) ||
            isFunction(arguments[2])
        ) {
            obj = editObjectFunctional(...arguments)
        } else {
            obj[key] = fn(obj[key])
        }
        return obj
    }

    function editObject2(obj, fn) {
        const value = fn(key, obj[key])

        if (isArray(value) && value.length == 2) {
            obj[value[0]] = value[1]
        } else if (value != null) {
            obj[key] = value
        }
        console.log(obj)
        return obj
        /* not in use */
    }
}

function isWordy(s) {
    const r = /[a-zA-Z\']+ [a-zA-Z\']+ [a-zA-Z\']+/
    //const r = /[a-zA-Z\']{2,} [a-zA-Z\']{2,}/
    return test(r, s)
}

s = `

        #katex-question katex=question
        #math-quill ref @onEnter focusIt
`

s = `


hi
`

function stringify2(x, options) {
    // hard.
    function stringWrapper(s) {
        return h('string', s)
    }

    const checkpoint = isVueElement

    function runner3(x) {
        const type = typeOf(x)
        const value = options[type](x, type)
        return checkpoint(value) ? value : runner3(value)
    }

    function runner(x) {
        const value = runner2(x)
        return options.condition(value) ? value : runner(value)
    }

    function runner2(x) {
        if (isFunction(x)) {
            return options.functionWrapper(x)
        }
        if (isPrimitive(x)) {
            return options.stringWrapper(x)
        }
        if (isArray(x)) {
            return options.arrayWrapper(x.map(runner))
        }
        if (isObject(x)) {
            return options.objectWrapper(
                Object.entries(x).map(atSecond(runner))
            )
        }
    }
    /* this will create a component */
    return runner(x)
}
var anestlist = [
    [1, 2, 3],
    [1, 2, 3],
]
function walk(x, fn, depthLimit = 7) {
    function walker(x, depth, a) {
        if (depth > depthLimit) {
            return evaluator(x)
        }
        if (isArray(x)) {
            return x.map((y) => walker(y, depth + 1))
        }

        if (isObjectLiteral(x)) {
            return Object.entries(x).reduce((acc, [a, b]) => {
                acc[a] = walker(b, depth + 1, a)
                return acc
            }, {})
        }
        return evaluator(x, depth, a)
    }

    function evaluator(x, depth, a) {
        const value = fn(x, depth, a)
        return value == null ? x : value
    }
    return walker(x, 0)
}

function simpleWalk(x, fn) {
    function walker(x) {
        if (isArray(x)) {
            return x.map(walker)
        }

        if (isObjectLiteral(x)) {
            return Object.entries(x).reduce((acc, [a, b]) => {
                acc[a] = walker(b)
                return acc
            }, {})
        }
        return evaluator(x)
    }

    function evaluator(x) {
        const value = fn(x)
        return value == null ? x : value
    }
    return walker(x)
}

function allowIgnoreFilterFactory(allow, ignore, ignoreRE) {
    return function lambda(x) {
        if (allow.includes(x)) return true
        if (ignore.includes(x)) return false
        if (test(ignoreRE, x)) return false
        return true
    }
}

function toHtmlRegex(tag, capture) {
    const content = capture ? '([^]+?)' : '[^]+?'
    return `<${tag}.*?>${content}</${tag}>`
}

function removeHtmlComments(s) {
    return s.replace(/<!--[^]+?--> *\n*/g, '')
}

function stop() {
    throw 'stoping'
}

function assign(state, ref) {
    if (!exists(ref)) return
    for (let [k, v] of Object.entries(ref)) {
        if (v != null) state[k] = v
    }
}

function assignAliases(state, ref, ...keys) {
    for (let key of gatherArgs(keys)) {
        state[key] = ref[key].bind(ref)
    }
}
function assignFresh(to, from, callback) {
    for (let [k, v] of Object.entries(from)) {
        if (!to.hasOwnProperty(k)) {
            if (v != null) to[k] = v
        } else if (callback) {
            callback(k, v)
        }
    }
}
function mergeOnTop(a, b) {
    for (let [k, v] of Object.entries(b)) {
        if (a.hasOwnProperty(k)) {
            a[k] = merge(a[k], v)
        } else {
            a[k] = v
        }
    }
    return a
}

function assignExisting(base, incumbent) {
    for (let k of Object.keys(base)) {
        const v = incumbent[k]
        if (v != null) base[k] = v
    }
}

function rng(min = 1, max = 10) {
    if (min == 0 && max == 0) return 0
    if (!isDefined(min)) {
        min = 1
        max = 10
    } else if (isArray(min)) {
        if (min.length > 2) {
            return randomPick(min)
        }
        max = min[1]
        min = min[0]
    } else if (arguments.length == 1) {
        max = min
        min = 1
    }
    if (min == max) return min
    return Math.floor(Math.random() * (max - min + 1)) + min
}

function randomPick(items) {
    if (isObject(items)) {
        items = Object.entries(items)
    }
    if (!isArray(items)) return items
    return items[Math.floor(Math.random() * items.length)]
}

function onceFactory(fn) {
    let touched
    return function once(x) {
        if (!touched && (fn ? fn(x) : x)) {
            touched = true
            return true
        }
    }
}

function getIndexesOf(items, fn) {
    return items
        .map((item, i) => {
            return fn(item) ? i : null
        })
        .filter(notNull)
}

function schemaMatch(schema, s, flags = 'g') {
    const captureDictionary = {
        quote: '(?:\'(.*?)\'|"(.*?)")',
        mathvar: '\\w+(?:\\^\\w+)?',
        //line: '(?:^|\\n)(.+)(?=\\n|$)',
        line: '\\S.+',
        mathop: '[+-/\\*] *',
        rest: '[^]+',
        para: '.*',
        char: '\\S',
        word: '[a-zA-Z]{1,}',
        w: '[\\w-$]{1,}',
        a: '.*?',
        A: '[^]+?',
        sym: '\\S{1,}',
        symbol: '[\\W]{1,}',
        nonspace: '\\S{1,}',
    }

    const noCaptureDictionary = {
        q: '\\?',
        s: '\\s*',
        ws: '\\s+',
        to: '[^]+?',
        linebreak: ' *(?:\\n+|$)',
    }

    let keys = []
    let names = []
    let count = 0
    let regex
    schema = prepareSchema(schema)
    regex = schema.replace(/\$(\w+)#?/g, regexParser)
    regex = regex.replace(/\*\?(?=\)(?:$|\|))/g, '*')
    regex = RegExp(regex, flags)

    function prepareSchema(s) {
        const SchemaDictionary = {
            arr: '[$1,$1]',
            config: '$word $any(?=  |$)',
            config: '$sym $sym',
        }

        if (s in SchemaDictionary) s = SchemaDictionary[s]
        return s.replace(
            / *([\[\]. :,]) */g,
            (_, x, offset, o) => {
                if (x == '[' || x == ']' || x == '.')
                    return '\\' + x
                if (x == ' ') return ' +'
                if (x == ':' && o[offset - 1] == '?') return ':'
                if (x == ':' || x == ',') return ` *${x} *`
            }
        )
    }

    function regexParser(_, x) {
        if (x in noCaptureDictionary) {
            return noCaptureDictionary[x]
        }

        count++

        if (x in captureDictionary) {
            let value = captureDictionary[x]
            let groups = countCaptureGroups(value)
            if (groups == 0) return parens(value)
            else {
                count += groups - 1
                return value
            }
        }

        if (isPlural(x)) {
            let regexValue = captureDictionary[depluralize(x)]
            keys[count] = regexValue
            names[count] = x
            const all = '(\\S[^]+?)'
            return all
            //return parens(regexElongation(regexValue))
        }

        const value = parens(regexParserHelper(x))
        return value
    }

    function regexParserHelper(x) {
        switch (x) {
            case 'mc':
                keys[count - 1] = '\\w+'
                names[count - 1] = x
                return '\\S+ \\S+ \\S+ \\S+(?= *(?:$|\\n))'
        }
    }

    // ------------------------------------------ start
    //console.log(regex)
    s = smartDedent(s)
    if (flags.includes('g')) {
        let matches
        let output = []
        while (exists((matches = regex.exec(s)))) {
            let store = []
            for (let i = 1; i < matches.length; i++) {
                let index = i
                let match = matches[i]
                if (match == undefined) {
                    continue
                }
                match = match.trim()
                console.log({
                    name: names[index],
                    match,
                    keys,
                    index,
                    r: keys[index],
                })
                if (keys[index]) {
                    store.push(findall(keys[index], match))
                } else {
                    store.push(toArgument(match))
                }
            }
            output.push(store)
        }
        return smallify(output)
        return output
        return store
    } else {
        let match = s.match(regex)
    }
}

s = `

dog {
   sfgf dffd 
    hog
}

foo {
    bog
    hog
}
`

s = `
x + 2 : red
x^2 : blue
x^2 + 5x + 6 : green
[2,3] : red
[2,5] : blue
`

class MathRearrangement {
    constructor(s) {
        this.s = s
    }
    generate() {}
    //const arrange = new MathRearrangement('y = x + 4')
}

s = `

The graph of f(x) crosses the yax at the coordinate point (a,b).
wmtv of a be? ans cbd a b 0      
`

sc = '$A$q$s(?:ans)? *(?:$mc|$para)'

function getOptionsFromSchema(s, schema) {
    const options = {}
    const keys = []
    schema = schema.replace(/\$(\w+)/g, (_, x) => {
        keys.push(x)
        return '(\\w+)'
    })
    schema = schema.replace(/[\[\]]/g, '\\$&')
    schema = schema.replace(/ *, */, ' *, *')
    //console.log(schema); throw "";
    s = s.replace(RegExp(schema, 'g'), (...args) => {
        for (let i = 1; i < args.length - 2; i++) {
            if (!args[i]) continue
            options[keys[i - 1]] = toArgument(args[i])
        }
        return ''
    })
    return [s.trim(), options]
}

s = `

            case 'symbol':
                return '[\\W]{1,}'
            case 'nonspace':
                return '\\S{1,}'
`

s = `
bb
nn

h
h
h
`

function defineAliases(state, object, dict) {
    for (let [k, v] of Object.entries(dict)) {
        state[k] = object[v].bind(v)
    }
}

class KVStorage {
    constructor() {
        this.store = []
    }

    add(key, value, data) {
        const payload = data
            ? { ...data, key, value }
            : { key, value }
        this.store.push(payload)
        return value
    }

    getKeys(fn = identity) {
        return this.store.filter(fn).map((x) => x.key)
    }

    getValues(fn = identity) {
        return this.store.filter(fn).map((x) => x.value)
    }

    getValue(fn) {
        const value = this.store.find(fn)
        return value && value.value
    }
}

function letterRange(x) {
    let [a, b] = split(x, '-')
    a = char2n(a)
    b = char2n(b)
    let store = []
    for (let i = a; i <= b; i++) {
        store.push(n2char(i))
    }
    return store
}
function partitionLetterGroups(groupSize, groupAmount) {
    const store = []
    const n = groupSize * groupAmount
    for (let i = 0; i < n; i++) {
        if (i % groupSize == 0) {
            store.push([])
        }
        getLast(store).push(n2char(i))
    }
    return store
}

function recursiveDataBuilder(depth) {
    const store = {}
}

function debounce(fn, delay = 250) {
    let id
    return function debouncedFunction(...args) {
        clearTimeout(id)
        id = setTimeout(() => {
            fn.call(this, ...args)
        }, delay)
    }
}

s = ['a', 'b', 'c', 'd', 'e']

function getAndGetAgain(fn, delay = 100) {
    let id
    let breaker = BreakerFactory(5)
    return new Promise((resolve, reject) => {
        id = setInterval(() => {
            breaker()

            console.log('hi')
            const value = fn()
            if (value) {
                resolve(value)
                clearInterval(id)
                return
            }
        }, delay)
    })
}
function tryAndTryAgain(fn, ...args) {
    let count = 0
    let id = setInterval(() => {
        try {
            fn(...args)
            clearInterval(id)
        } catch (e) {
            if (count++ > 10) {
                clearInterval(id)
                throw 'try error'
            }
            console.log('trying agan')
        }
    }, 1000)

    function runner() {
        try {
            fn(...args)
        } catch (e) {}
    }
}

function buildFileRelations() {
    /* he */
}

function superbf(...args) {
    args = gatherArgs(args)
    const store = []
    for (let i = 0; i < args.length; i++) {
        let el = args[i]
        if (isFunction(el)) {
            store.push([el, []])
        } else {
            getLast(store)[1].push(el)
        }
    }
    return function lambda(s) {
        for (let [a, b] of store) {
            s = a(s, ...b)
        }
        return s
    }
}

function gatherArgs(args) {
    if (isArray(args[0]) && args.length == 1) {
        return args[0]
    }
    if (args.some(isArray)) {
        return flat(args)
    }
    return args
}
function gatherAllArgs(args) {
    return filter(flat(args))
}

function assertion(x) {
    if (x == null) {
        throw new AssertiongError()
    } else {
        //console.log('the value of x has been asserted')
        return x
    }
}

async function actions(n, fn, delay = 1000, state) {
    for (let i = 0; i < n; i++) {
        await sleep(delay)
        state ? fn.call(state) : fn()
    }
}

function optiongetter(s) {
    return mreplace(/^# *(\w+) *(.*)/gm, s.toString())
}
function waterfall(items, onTick, callback) {
    let id
    let i = 0
    let max = items.length
    let delay

    function runner(x) {
        let item = items[i++]
        //console.log(item)
        delay = item.delay || 1000
        onTick(item)
        if (i == max) {
            clearTimeout(id)
            setTimeout(() => {
                callback()
            }, delay + 250)
            return
        }
        id = setTimeout(() => {
            runner()
        }, delay)
    }
    runner()
}

function waterfall2(promises) {
    return promises.reduce((acc, promise, i) => {
        return acc.then(() => {
            return promise.then(() => {
                return true
            })
        })
    }, Promise.resolve([]))
}

function incrementName(name, offset = 1) {
    return test(/\d$/, name)
        ? name.replace(/\d+$/, (x) => Number(x) + offset)
        : name + '2'
}
function defineVariable(a, b) {
    eval(`${a} = ${b}`)
}

// 04-08-2022

function getThis(state, regex) {
    const value = mapfilter(Object.entries(state), (x) => {
        return (
            !isFunction(x[1]) &&
            test(regex, x[0]) && [x[0], x[1]]
        )
    })
    return reduce(value)
}

s = `

component circle-data
props h,k,r
colors h,k,r

the circle currently
has a h value of :h
has a k value of :k
is centered around the point (:h,:k)
has a radius of :r
has the equation #equation(circle, h, k, r)
`

const standards = {
    equations: {
        circle(h, k, r) {
            return `(x - ${h})^2 + (y - ${k})^2 = ${r}^2`
        },
    },
}

function lineNeedsEndingColon(s) {
    if (test(/[^a-zA-Z]$/, s)) {
        return false
    }
    const words = ['is', 'of', 'currently', 'has', 'be']
    let word = getLastWord(s)
    if (words.includes(word)) {
        return true
    }
}

function infuseVue(s) {
    return s.replace(/:([a-z]+)/g, (_, x) => {
        return `{{${x}}}`
    })
}

function infuseSpanColors(s, colors) {
    if (isArray(colors)) {
        colors = reduce(colors, rainbow)
    }
    const regex = ncg('\\b($1)\\b|({{(?:$1)}})', colors)
    return replace(
        regex,
        (_, a, b) => {
            let value = a || b
            let color = colors
                ? colors[getFirstWord(value)]
                : rainbow()
            return spanify(value, { style: { color } })
        },
        s,
        'g'
    )
}
function createClassFromValue(s) {
    let match = search(/^\w+(?: \w+)?/, s)
    return toDashCase(match)
}
function spanify(value, options) {
    if (isString(options)) {
        options = {
            style: cssEvaluator(options),
        }
    } else if (!options) {
        options = {
            class: createClassFromValue(value),
        }
    }
    //console.log(options); throw ''
    const attrs = Object.entries(options)
        .reduce((acc, [a, b], i) => {
            acc += a + '="'
            if (a == 'style') {
                if (isObject(b)) {
                    for (let [k, v] of Object.entries(b)) {
                        acc += k + ': ' + v + '; '
                    }
                }
                acc = acc.trim()
            } else {
                acc += b
            }

            acc += '" '
            return acc
        }, '')
        .trim()
    //console.log(attrs); throw ''
    return `<span ${attrs}>${value}</span>`
}

function validArgs(args) {
    return args.filter((x) => x != null && x != '')
}

function schemaRegexFactory(schema, fn) {
    let [a, template] = split(schema, / *\.\.\. */)
    const dict = {
        wallu: '[^]+?',
        function: 'function',
        //'\\n': '\\\\n',
        //'\\cw': '(\\\\w+)',
        //'\\w': '\\\\w+',
        n: '\\n',
        cw: '(\\w+)',
        w: '\\w+',
        dotu: '.*?',
        s8: ' {8}',
        s4: ' {4}',
    }
    let flags = 'g'
    let r = RegExp(dreplace(a, dict, null), flags)
    console.log(r)
    return function lambda(s) {
        //console.log({s})
        const matches = findall(r, s)
        //console.log(matches); throw ''
        //console.log('matches.length', matches.length)
        return matches.map((x) => spicyTemplater(template, x))
    }
}

function removeThis(s) {
    return s.replace(/\bthis\./g, '')
}
s = `
Chapter 4: Circles

To make a circle, all you need is a [point (:h, :k)],
and a radius :r
`

function bindObjectToState(obj, state, transformer) {
    if (!transformer)
        transformer = (x, state) => {
            return x.bind(state)
        }

    return walk(obj, (x) => {
        if (isFunction(x)) {
            return transformer(x, state)
        }
    })
}

function bringFunctionsToLife(dict, state, transform) {
    return reduce(dict, (k, v) => {
        if (isFunction(v)) {
            return [k, v]
        }

        const fn = new FunctionBuilder()
        fn.name = toCamelCase(k)
        if (transform) {
            v = transform(v)
        }

        if (isThisFunction(v) && state) {
            fn.append(v)
            fn.params.push('...args')
            return [k, fn.getValue().bind(state)]
        } else if (isThisFunction(v)) {
            v = v.replace(/\bthis\b/g, 'state')
            fn.params.push('state')
            if (v.includes('...args')) fn.params.push('...args')
            fn.append(v)
            return [k, fn.getValue()]
        } else {
            const param = itersearch(v, 'app', 'state', 'vue')
            fn.params.push(param)
            fn.params.push('...args')
            fn.append(v)
            //console.log(fn.toString())
            return [k, fn.getValue()]
        }
    })
}

s = `

var board = JXG.JSXGraph.initBoard('jsxgraph', {
    grid: false,
    zoom: {
        factorX: 'cv',
        factorY: gogo,

        wheel: false,
        needshift: false,
        eps: 0.1,
    },
})

var ax1 = board.create('line', [
`

s = `

const HTMLBuilderTemplate = \`
    <!doctype html><html>
        <head>
            $dependencies

\`
`

function schemaReplace(s, schema) {
    let [a, b] = split(schema, / \.\.\. /)
    let regex = rescape(a).replace(/\\\$(\w+)/g, (_, x) => {
        if (x == 1) x == 'w'
        return '(\\' + x + '+)'
    })
    regex = regex.replace(/[\'\"]/g, '[\'"]')
    regex = RegExp(regex, 'g')
    console.log(regex)
    //console.log(regex); throw ''
    const replacement = test(/\$\d/, b)
        ? b
        : bringToLifeLambda(b)
    console.log(replacement)
    const value = s.replace(regex, replacement)
    return value
    return s.replace(regex, value)
}

function xveryMagicLogicHandler(s) {
    const info = {
        Array: [
            'length',
            'concat',
            'fill',
            'find',
            'findIndex',
            'lastIndexOf',
            'pop',
            'push',
            'reverse',
            'shift',
            'unshift',
            'slice',
            'sort',
            'splice',
            'includes',
            'indexOf',
            'join',
            //"keys",
            //"entries",
            //"values",
            //"forEach",
            //"filter",
            //"flat",
            //"flatMap",
            //"map",
            'every',
            'some',
            //"reduce",
            //"reduceRight",
        ],
        //"Number": [
        //"toExponential",
        //"toFixed",
        //"toPrecision",
        //"toString",
        //"toLocaleString"
        //],
        String: [
            'length',
            //"anchor",
            //"big",
            //"blink",
            //"bold",
            //"charAt",
            //"charCodeAt",
            //"codePointAt",
            //"concat",
            'endsWith',
            //"fontcolor",
            //"fontsize",
            //"fixed",
            'includes',
            'indexOf',
            //"italics",
            //"lastIndexOf",
            //"link",
            //"localeCompare",
            //"match",
            //"matchAll",
            //"normalize",
            //"padEnd",
            //"padStart",
            'repeat',
            'replace',
            //"replaceAll",
            //"search",
            'slice',
            //"small",
            'split',
            //"strike",
            //"sub",
            //"substr",
            //"substring",
            //"sup",
            'startsWith',
            'toString',
            'trim',
            'trimStart',
            //"trimLeft",
            'trimEnd',
            //"trimRight",
            //"toLocaleLowerCase",
            //"toLocaleUpperCase",
            'toLowerCase',
            'toUpperCase',
            //"at"
        ],
    }
    s = 'ifhnl'
    obj = { ifo: 'if (isObject($1)) {\n    $c\n}' }
    const { spaces, first, second } = getLineInfo(s)
    const { sol, eol, mol } = getCursorInfo()
}
function xnothingInfront(s) {}

function defineEmitProperty(state, key) {
    function get() {
        return this['_' + key]
    }

    function set(value) {
        this['_' + key] = value
        this.emit(key, value)
    }

    Object.defineProperty(state, key, { get, set })
}

function endsWithParentheses(s) {
    return test(/\)$/, s)
}

const StorageMixin = {
    reduce(fn, checkpoint = exists) {
        return Object.entries(this.store).reduce(
            (acc, [a, b]) => {
                const value = fn(b)
                if (value && checkpoint(value)) acc[a] = value
                return acc
            },
            {}
        )
    },
    has(x) {
        return this.store.hasOwnProperty(x)
    },
    set(key, value) {
        if (key == null || value == null) return
        this.store[key] = value
    },
    get(key) {
        return this.store[key] || ''
    },
}

function lengthDelta(a, b) {
    const runner = (x) => (isNumber(x) ? x : x.length)
    return Math.abs(runner(a), runner(b))
}

function indentAfterFirstLine(s, n) {
    return replace('\n', '\n' + toSpaces(n), s, 'gm')
}

function templateToFunction(s) {
    s = smartDedent(s)
    let items = s.split(/(\$[a-zA-Z0-9]+)/)
    let template = ''
    let variables = new Set()
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        if (item.startsWith('$')) {
            item = item.slice(1)
            if (isNumber(item)) {
                item = n2char(Number(item) - 1)
            }
            variables.add(item)
            let prev = items[i - 1]
            let spaces = prev && search(/\n( *).*$/, prev)
            let value = spaces
                ? `indentAfterFirstLine(${item}, ${spaces.length})`
                : item
            template += wrap(value, ' + ')
        } else {
            template += singlequote(
                escapeNewlinesAndQuotes(item)
            )
        }
    }
    //const body = 'return ' + dreplace(template, {
    //'\n': '\\n',
    //'\'': '\\\'',
    //'\"': '\\\"',
    //})
    const body = 'return ' + template
    variables = Array.from(variables).sort()
    let params = variables.map((x, i) => `${x} = ''`)

    if (variables[0] != 'a') {
        params = `{${params.join(', ')}} = {}`
    }
    //console.log(variables)
    const fn = toStringFunction('lambda', params, body)
    //console.log(fn); throw "";
    //console.log([fn])
    //
    return bringToLife(fn)
}

s = `fb(`

function runit(s, evaluater = eval) {
    let value
    let count = 0
    while (++count <= 3) {
        breaker(3)
        try {
            console.log('v')
            value = evaluater(stringTryWrap(s))
            console.log('hi')
        } catch (e) {
            console.log('unreachable syntax error')
            console.log(e)
            return
        }
        if (!value) {
            return true
            /* true usually means everything is okay */
            /* however it also means terminate onTick... or to stop something. it usually ends up meaning the case u want it to be. */
            return console.log('done without errors')
        }
        if (value.proposedFixFn) {
            s = value.proposedFixFn(s)
            console.log(s)
        }
    }
}

//allowIgnoreFilterFactory

function rigidCompareFactory(preset, transform = identity) {
    return function compare1(x) {
        const value = preset.indexOf(transform(x))
        console.log(value)
        return value > -1 ? value : preset.length + 1
    }
}
function sortHtmlAttrs(items) {
    const preset = ['v-for', 'v-if', 'v-show']
    const compare1 = rigidCompareFactory(preset, onFirst)
    const compare2 = (x) => x.join('').length
    return multiSort(items, compare1, compare2)
}
function rigidSort(items, preset, transform = identity) {
    const reference = items.map(transform)
    const base = copy(reference)
    const value = preset.map((key, i) => {
        const index = findIndex(key, reference)
        if (index < 0) return 
        edit(reference, index, null)
        const value = items[index]
        return value
    }).filter(isDefined)

    const extra = difference(base, value.map(transform))
    extra.sort()
    return value.concat(extra)
}
function multiSort(items, ...criteria) {
    if (getLast(criteria) != identity) criteria.push(identity)

    const sort = (a, b) => {
        for (let i = 0; i < criteria.length; i++) {
            const fn = criteria[i]
            const A = fn(a)
            const B = fn(b)

            let value
            if (isNumber(A)) {
                value = Number(A) - Number(B)
            } else if (isString(A)) {
                value = charPointScore(A) - charPointScore(B)
            }
            if (value) return value
        }
        return 0
    }
    return items.sort(sort)
}

function charPointScore(s) {
    let score = 0
    for (let i = 0; i < s.length; i++) {
        let c = s.codePointAt(i)
        score += c * Math.pow(10, -2 * i)
    }
    return score
}

function isStringClass(s) {
    return test(/^class/, s)
}

function isStringFunction(s) {
    return test(
        /^(?:async )?(?:.*?=>|function|class|\w+\(.*?{)/,
        s
    )
}

function isStringObjectFunction(s) {
    return test(/^(?:async )?\w+\(.*?{/, s)
}
function isStringLambdaFunction(s) {
    return test(/^(?:async )?.*?=>/, s)
}

function functionStringRevive(k, v) {
    if (isStringFunction(v)) {
        return bringFunctionToLife(v)
    }
    return v
}

function magicComplete(line, upline, state) {
    let baseWords = line.match(/\w+/g)
    // ways to map the state
    // calenderTracker

    function ifMagic(args, line, upline) {
        let words = upline.match(/\w+/g)
        let targets = args.map((x) => words[x - 1])

        // count the targets
        return pairs.map((item, i) => {
            let value = dreplace(upline, [targets, item])
            return value
        })
    }
    const ref = {
        if: ifMagic,
        ef: ifMagic,
    }

    upline = "if (key == 'a') left = 1"
    line = 'w up d right s down Escape escape Enter enter'
    magicArgs = '$3 $4'
    let words = upline.match(/\w+/g)
    if (!words) return
    let runner = ref[words[0]]
    let value = runner(magicArgs, line, upline)
    console.log(words)
    // sprawl to the upline
    // return
}

class InfiniteStorage {
    ccumulative(ref, key, value) {
        const current = ref[key]
        if (isArray(current)) {
            ref[key] = push(current, value, 1)
        } else if (current !== value)
            ref[key] = [current, value]
    }
    set(...keys) {
        let ref = this
        for (let i = 0; i < keys.length - 1; i++) {
            let key = keys[i]
            if (i == keys.length - 2) {
                if (
                    this.cumulative &&
                    ref.hasOwnProperty(key)
                ) {
                    this.cumulative(ref, key, keys[i + 1])
                } else {
                    ref[key] = keys[i + 1]
                }
                break
            }

            if (!ref.hasOwnProperty(key)) {
                ref[key] = {}
            }

            if (isObject(ref[key])) {
                ref = ref[key]
            }
        }
    }
}

function getParenOffset(s) {
    const value = search(/[\'\"\)}\]]*$/, s)
    return (value && value.length) || 0
}

function randomLetter(ignore) {
    let value = randomPick(alphabet)
    if (ignore && ignore.includes(value)) {
        return randomLetter(ignore)
    }
    return value
}
function objectWalk(o) {
    let lastKeys = []

    function runner(x) {
        for (let [k, v] of Object.entries(x)) {
            if (isObject(v)) {
                lastKeys.push(k)
                runner(v)
            } else {
                //console.log(...lastKeys)
                //store.push(lastKeys.concat(v).join('-'))
            }
        }
    }
    runner(o)
}

function visitor() {}
//console.log(readableProperties(new Storage()))
//console.log(Object.entries(new Storage))

function jshintErrorInfo(s) {
    return jshint(s)
        .errors.slice(0, -1)
        .filter((x) => {
            return x.code.startsWith('E')
        })
        .map((item, i) => {
            return {
                line: item.line,
                ch: item.character,
                reason: item.reason,
                code: item.code,
                evidence: item.evidence,
            }
        })
}
function tryval2(s, f) {
    try {
        return eval(s)
    } catch (e) {
        console.log(e)
        if (f) return fparse(f, s)
        return e.toString()
    }
}
function evaluate(s) {
    try {
        const success = eval(s) || true
        return { success }
    } catch (e) {
        console.log(e.stack)
        const error =
            getErrorInfo(e) ||
            prettierErrorInfo(s) ||
            jshintErrorInfo(s)
        return { error }
    }
}

s = `  console.log(' bye)`

function surpassFunction(fn, gn) {
    return (...args) => {
        if (gn(...args)) return
        fn(...args)
    }
}
function wrapFactory(before, after) {
    if (!after) after = before
    return function lambda(fn) {
        if (isAsync(fn)) {
            return async function lambda(...args) {
                const beforeValue = before()
                console.log('before', beforeValue)
                const value = await fn(...args)
                const afterValue = after()
                console.log('after', afterValue)
                return value
            }
        } else {
            return function lambda(...args) {
                before()
                const value = fn(...args)
                after()
                return value
            }
        }
    }
}

function codeWords(s) {
    let words = s.match(/[a-zA-Z][\w.]{6,}/g)
    if (!words) return
    let ignore = ['function']
    words = unique(words, ignore)
    return words
}

function bigWords(s) {
    return unique(findall(/[\w.]{10,}/g, s))
}
function onFirst(fn) {
    if (isFunction(fn)) {
        return function lambda(k, v) {
            return fn(k)
        }
    }
    if (isArray(fn)) {
        return fn[0]
    }
}

function onlyFirst(fn) {
    return (x, i) => (i == 0 ? fn(x) : x)
}

function onlySecond(fn) {
    return (x, i) => (i == 1 ? fn(x) : x)
}

function onSecond(fn) {
    if (isFunction(fn)) {
        return function lambda(k, v) {
            return fn(k)
        }
    }
    if (isArray(fn)) {
        return fn[1]
    }
}

function getLongestDollar(s) {
    return getLongest(
        (s.match(/\$\d+/g) || []).map((item, i) => {
            return Number(item.slice(1))
        })
    )
}

function doubleReplace(s, regex, childRegex, fn) {
    //console.log(childRegex)
    return s.replace(regex, (_, x, offset) => {
        return _.replace(x, x.replace(childRegex, fn)).replace(
            /  +/g,
            ' '
        )
    })
}

function assetObject(items, insideObject, lang = 'js') {
    const delimiter = insideObject ? ': ' : ' = '
    const ending = insideObject ? ',\n' : ''

    if (items.length == 1) {
        return `${insideObject ? '' : jspy(lang, 'const')}${
            items[0]
        }${delimiter}{\n\t\n}`
    }
    return (
        jspy(lang, 'const') +
        items[0] +
        delimiter +
        items.slice(1).reduce((acc, item, i) => {
            if (i % 2 == 0)
                acc += '    ' + toStringArgument(item)
            else {
                acc += ': ' + toStringArgument(item) + ',\n'
            }
            return acc
        }, '{\n') +
        '}' +
        ending
    )
}
function removeNumbers(s) {
    return s.replace(/\d/g, '')
}
function assetArray(items, lang = 'js') {
    /* insideObject can be done later */
    if (items.length == 1) {
        return `${jspy(lang, 'const')}${items[0]} = [\n\t\n]`
    }
    return (
        jspy(lang, 'const') +
        ' = ' +
        items[0] +
        wrap(items.slice(1).map(singlequote).join(', '), '[]')
    )
}

function unquote(s) {
    return s.slice(1, -1)
}

function lineDitto(template, args) {
    const key = search(/\w+(?= *=)/, template)
    const regex = key
        ? key.length > 2
            ? key + '\\b'
            : `\\b${key}\\b`
        : args.shift()

    const runner = (x) => {
        return replace(regex, x, template)
    }
    return args.map(runner).join('\n')
}

function loremMath(n = 1, mode) {
    function loremSimpleMathQuestion(a, b) {
        if (a == null) a = rng(1, 10)
        if (b == null) b = rng(1, 10)
        let question = `${a} * ${b}`
        let answer = eval(question)
        return { question, answer }
    }
    return (mode == Array ? identity : smallify)(
        range(n).map(loremSimpleMathQuestion)
    )
}

function abbreviateObject(o) {
    return reduceObject(o, (k, v) => {
        return [abbreviate(k), v]
    })
}

function extractConfig(s) {
    let [a, b] = mreplace(/(\w+) *= *(\w+)/g, s)
    if (b) {
        b = reduce(b)
    }
    return [a, b]
}
function Factory(fn, ...args) {
    if (args.includes(null)) {
        let [a, b] = partition(args, isNull)
        return function lambda(s) {
            return fn(...a, s, ...b)
        }
    }
    return function lambda(s) {
        return fn(...args, s)
    }
}
//console.log(coerceTo('gg'))

function generateTiles() {
    s = `

    2 3
    2 4

    3 4
    2 8
    4 6

    3 6
    4 4
    5 5
    1 7
`
    let numbers = splitter(s, /(\d+) (\d+)/g)
    numbers = walk(numbers, toNumber)
    return flat(numbers.map(parser))

    function splitter(s, r) {
        return split(smartDedent(s), /\n\n+/).map((x) =>
            findall(r, x)
        )
    }

    function parser(a, id) {
        let tiles = []

        a.forEach((item, i) => {
            //const {question, answer} =  mathSum(item)
            //push(question, 'question')
            //push(answer, 'answer')
            item.forEach((x) => push(x))
        })

        function push(value, type) {
            tiles.push({ value, id })
        }
        return tiles
        //const addColor = exporter(MathColors, 'color')
        const addColor = identity
        push(addColor(base.question), 'question')
        push(addColor(base.answer), 'answer')
        push(
            [
                addColor(sum.expression),
                addColor(product.expression),
            ],
            'setup'
        )
        //console.log(tiles); throw ''
        return tiles
        return {
            question: base.question,
            answer: base.answer,
            setup: [sum.expression, product.expression],
        }
        /* separating the data-layer from the presentation-layer */
    }
}
function mathConditionFromString(s) {
    if (isFunction(s)) {
        return s
    }

    return fastFunction(s)
}
function match(regex, s) {
    let match
    if (regex.flags.includes('g')) {
        let store = []
        while ((match = regex.exec(s))) {
            let value = matchGetter(match)
            store.push(value)
        }
        return store
    } else {
        match = s.match(regex)
        return matchGetter(match)
    }

    function matchGetter(match) {
        return !match
            ? null
            : match.length == 1
            ? match[0]
            : match.length == 2
            ? match[1] || match[0]
            : match.slice(1)
    }
}
function fastFunction(s) {
    if (isFunction(s)) {
        return s
    }
    let variables = unique(match(/\b[abcdexyzin]\b/g, s))
    const dict = {
        and: '&&',
        or: '||',
    }
    s = dreplace(s, dict)
    let fnCode = `(${variables.join(', ')}) => ${s}`
    return bringToLife(fnCode)
}
//console.log(generateNumbers({
//condition: 'a + b < 10 and a * b < 10 and a > 1'
//}))

s = `
Sometimes, you will have to carry a number over.
To enjoy reading.
creating education games
why did i let this happen

`

class TileMatch {
    constructor(tiles) {
        this.load(tiles)
    }

    load(tiles) {
        if (!tiles) {
            return
        }

        this.tiles = tiles.map((x) => {
            return {
                ...x,
                /* type, value, id */

                active: false,
                done: false,
                rotation: 0,
                style: {
                    background: 'white',
                    color: 'black',
                },
            }
        })

        this.matchLength = this.filterById(tiles[0].id).length
        const n = Math.ceil(tiles.length / this.matchLength)
        this.styles = generateStyles(n)
        return this.tiles
    }

    filterById(id, match = true) {
        return this.tiles.filter((x) => {
            return match ? x.id == id : x.id != id
        })
    }

    click(index) {
        let tile = this.tiles[index]
        if (tile.done) {
            return
        }

        tile.rotation += tile.active ? 1 : -1

        if (tile.active) {
            tile.active = false
            return
        }

        tile.active = true
        const possibles = this.filterById(tile.id)

        if (possibles.every((x) => x.active)) {
            const style = this.styles.pop()
            possibles.forEach((x) => {
                x.done = true
                x.style = style
            })
            return true
        } else {
            console.log('still waiting')
        }
    }
}
function generateTiles2() {
    return [1, 2, 3].map((x) => ({ value: x, id: 4 }))
    //return [[1,2], [3,4]]
}

function generateStyles(n) {
    //const backgrounds = Object.values(tailwind)
    const backgrounds = roygbiv
    let color = 'white'
    return range(n).map((item, i) => {
        return {
            color: color,
            background: backgrounds.pop(),
        }
    })
}

class EquationDisplay {
    load(equation, ref, colors) {
        this.template = this.cache.get(equation, () =>
            nerdamer.convertToLaTeX(equationLibrary[equation])
        )
        this.colors = colors
        if (colors) {
            this.template = infuseKatexColors(
                this.template,
                colors
            )
        }
        this.ref = ref
    }
    constructor() {
        this.cache = new Cache()
        const equationLibrary = {
            circle: '(x - h)^2 + (y - k)^2 = r^2',
            1213: '1a * 1b = 1cd',
        }
    }
    toKatex() {
        let template = infuseVariables(this.template, this.ref)
        console.log(template)
        return template
    }
    color(s) {}
}

function rungen(Generator, ...args) {
    let x = new Generator(...args)
    const value = x.generate()
    console.log(value)
    return value
}

function timeline(aa) {
    if (!isNestedArray(aa)) {
        aa = partition(aa, 2)
    }
    let index = 0
    let id
    function runner() {
        if (index == aa.length) {
            console.log('done')
            clearTimeout(id)
            return
        }

        let item = aa[index]
        let [delayBefore, callback] = item
        id = setTimeout(() => {
            callback(index++)
            runner()
        }, delayBefore)
    }
    runner()
}

function tryf(fn) {
    return function lambda(...args) {
        try {
            return fn(...args)
        } catch (e) {
            return null
        }
    }
}

function toggleForward(state, key, value, duration) {
    const current = state[key]
    state[key] = value
    console.log('toggle forward', key)
    setTimeout(() => {
        state[key] = current
    }, duration)
}

function randomGeneratorFactory(arr) {
    let copy = shuffle(arr)
    return function lambda() {
        const value = copy.pop()
        if (copy.length == 0) copy = shuffle(arr)
        return value
    }
}

function findall2(regex, s) {
    let store = []
    let match
    s = s.trim()

    while (exists((match = regex.exec(s)))) {
        match.length == 1
            ? store.push(match[0])
            : store.push(
                  smallify(match.slice(1).filter(exists))
              )
    }
    return store
}

function defineStateVariable(state, key, value) {
    if (state.hasOwnProperty(key)) {
        return
    }
    state[key] = value

    function runner(value) {
        const name = getConstructorName(value)
        console.log(name)
        switch (name) {
            case 'Array':
                return []
            case 'Set':
                return {}
            case 'Object':
                return {}
            default:
                return value
        }
    }
}

function lowerCase(s) {
    return s.toLowerCase()
}

function replacef(a, b, flags = 'g') {
    function smartRescape(s) {
        if (test(/\[\^\]|\(\?[:!=]|\\[wsdWSD]/, s)) {
            return s
        }
        return rescape(s)
    }
    const r = RegExp(smartRescape(a), flags)
    console.log(r)
    return function lambda(s) {
        return s.trim().replace(r, b)
    }
}

function calculateColorPortions({
    text,
    colors,
    max = 4,
    defaultColor = 'black',
    index = null,
} = {}) {
    /* used for adding on portions of color to the text */
    let words = split(text)
    if (words.length == max) {
        return colors
            .map((color, i) => {
                let word = words[i]
                if (!word) return
                if (index != null && i >= index) {
                    return [word, defaultColor]
                }
                return [word, color]
            })
            .filter(exists)
    }
    let colorLength = colors.length
    if (!colorLength) return [[text, defaultColor]]

    let store = []
    let textLength = text.length
    let length = Math.floor(textLength / max)
    let remainder = textLength - length * max
    //console.log(remainder, length); throw "";

    for (let i = 0; i < colorLength; i++) {
        let sliceLength = length
        if (remainder) {
            remainder -= 1
            sliceLength += 1
        }
        //
        //if (i == colorLength - 1) {
        //if (text.length)
        //}

        store.push(text.slice(0, sliceLength))
        text = text.slice(sliceLength)
    }
    if (text) store.push(text)
    return store.map((item, i) => {
        if (colors[i]) {
            return [item, colors[i]]
        }
        return [item, defaultColor]
    })
}

const smartAggregateActions = [
    //let {REGEXES, KEYWORDS, IGNORE, TOKENS} = toDictionary(map(partition(split(text, splitRE)), atSecond(fn)))

    /* used on getAliases */
    /.*?:\n*(?: *\S+ \S+\n)+/,
    (x) => {
        const splitonceRE = /^(\w+) +(.+)$/gm
        const fn = compose(toDictionary, matchf(splitonceRE))
        const f = atSecond(fn)
        return toDictionary(
            partition(split(x, /^(.*?):/m)).map(f)
        )
    },
    /^.*?:/,
    (x) => partition(split(x, /^(.*?):/m), 2),
    ///^(\w+):\n/
]

const smartAggregate = aggregatef(smartAggregateActions)

function sxxxxxxxxxxxxxxchemaRegexFactory(schema, fn) {
    let [a, template] = split(schema, / *\.\.\. */)
    const dict = {
        wallu: '[^]+?',
        function: 'function',
        //'\\n': '\\\\n',
        //'\\cw': '(\\\\w+)',
        //'\\w': '\\\\w+',
        n: '\\n',
        cw: '(\\w+)',
        w: '\\w+',
        dotu: '.*?',
        s8: ' {8}',
        s4: ' {4}',
    }
    let flags = 'g'
    let r = RegExp(dreplace(a, dict, null), flags)
    console.log(r)
    return function lambda(s) {
        //console.log({s})
        const matches = findall(r, s)
        //console.log(matches); throw ''
        //console.log('matches.length', matches.length)
        return matches.map((x) => spicyTemplater(template, x))
    }
}

function aggregatef(actions) {
    return function lambda(s) {
        let [a, b] = split(s, /^--+/m)
        if (b) {
            const fn = schemaSomethingFoobar(a)
            a = fn(b)
        }
        /* --------------------------- extract config */

        s = a.trim()
        for (let [a, b] of partition(actions, 2)) {
            if (ftest(a, s)) return fget(b, s)
        }
    }
}
function fget(b, s) {
    return isFunction(b) ? b(s) : findall2(b, s)
}
function createArrowRefFromString(s) {
    s = s.replace(/\bthis\b/g, 'state')
    const matches = smartAggregate(s)
    const ref = {
        up: 'ArrowUp',
        top: 'ArrowUp',
        bottom: 'ArrowDown',
        left: 'ArrowLeft',
        down: 'ArrowDown',
        right: 'ArrowRight',
        esc: 'Escape',
        escape: 'Escape',
        ent: 'Enter',
        enter: 'Enter',
        spc: ' ',
        space: ' ',
        bs: 'Backspace',
        backspace: 'Backspace',
        tab: 'Tab',
    }

    return reduce(partition(matches, 2), (k, body) => {
        if (!exists(body)) {
            return
        }
        const name = ref[k] || k
        const fnName = name == ' ' ? 'Space' : name
        const fn = toStringFunction(name, 'state', body, {
            private: true,
            lambda: true,
            mode: Function,
        })
        return [name, fn]
    })
}
//console.log(createArrowRefFromString('foo:\nbasdfs sdfs dfsd\ndfg \n\n\ndffg \nbar:\noka\nbov:'))

function fractionForms(s) {
    let [a, b] = getNumbers(s)
    if (!b) {
        b = a
        a = 1
    }
    let base = b
    //console.log([a,b])
    let x = 'x'
    if (a == b) throw 'cant equal each other'
    let complement = b - a
    let operator = '-'
    let neg = complement < 0
    if (neg) {
        complement *= -1
        operator = '+'
    }
    //console.log(base, complement)

    let aa = `${x} ${operator} ${x}/${fraction(
        base,
        complement
    )}`
    let bb = `${x} ${operator} ${complement}${x}/${base}`
    let cc = `${x} ${operator} ${x}/${decimal(
        base,
        complement
    )}`
    if (/\.\d{5}/.test(cc)) cc = null
    return [aa, bb, cc, s]

    //x - x / 1.5 is the same as
    //x - x / 3/2
    //x - 2x / 3
    //x/3
    //console.log(fractionForms('3x/5'))
}
function decimal(a, b) {
    return a / b
}
function utfChars() {
    let store = []
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    let symbols = '!@#$%^&*(){}[]\'":;,.<>/?~|\\=-+_'.split('')
    let ALPHABET = alphabet.map((x) => x.toUpperCase())
    let emojis = []
    store.push(...alphabet)
    store.push(...ALPHABET)
    store.push(...numbers)
    store.push(...symbols)
    store.push(...emojis)
    return store
}

function waterfall3(items, callback) {
    let i = 0
    let length = items.length
    return new Promise((resolve) => {
        function runner(items) {
            function done() {
                i += 1
                if (i == length) {
                    return resolve()
                } else {
                    runner(items)
                }
            }
            const value = callback(items[i], i, done)
            if (isPromise(value)) {
                done()
            }
            /* somehow, the value gets looped in */
        }
        return runner(items)
    })
}

function schemaSomethingFoobar(s) {
    const dict = {
        ns: '(\\S+)',
    }
    let schemaRegex = dreplacef(/\$(\w+)/g, dict)

    const actions = linegetter(s).map((item, i) => {
        let [s, noBoundary] = mreplace(/nb/, item)
        let [a, b] = splitonce(s)
        a = schemaRegex(a)
        if (!noBoundary) {
            a = boundary(a)
        }
        a = new RegExp(a, 'g')
        return [a, b]
    })

    return function lambda(s) {
        for (let [a, b] of actions) {
            s = s.replace(a, b)
        }
        //console.log(s)
        return s
    }
}

function endAdderF(s, value) {
    const regex = (x) => !RegExp(s).test(x)
    return conditional(addf(value || s), regex)
}

function extractArg(s) {
    return search(/\((.*?)\)/, s)
}

function dreplace2(s, dict) {
    const symbols = ['*', '[', ']', '{', '}', '. ', ' = ?']
    const filter = (x) => symbols.includes(x)
    const [a, b] = partition(Object.keys(dict), filter)
    const rA = exists(a)
        ? `(?:${a.map((x) => '\\' + x).join('|')})`
        : ''
    const rB = exists(b) ? `|\\b(?:${b.join('|')})\\b` : ''
    const regex = rA + rB
    //console.log(regex); throw "";

    return s.replace(RegExp(regex, 'g'), (x, offset, s) => {
        if (/[@$]/.test(s[offset - 1])) return x
        return dict[x]
    })
}
//console.log(variableExists('bvvcr'))
//
function escapeHtml(value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
}

//console.log(removeExtension(tail('f-ga.ttf')))

class ItemParser {
    constructor(fn) {
        if (fn) this.parser = fn.bind(this)
    }
    parse(s) {
        this.store = []
        this.index = 0
        this.items = isArray(s) ? s : s.trim().split('\n')
        let current
        while (this.index < this.items.length) {
            let i = this.index++
            let prev = this.items[i - 1]
            let next = this.items[i + 1]
            if (!exists(next)) next = null
            let item = this.items[i]
            if (!current) current = item
            let res = this.parser(current, next, prev, i)
            if (!res) {
                if (isArray(current)) {
                    current.push(item)
                } else {
                    current = [current, item]
                }
            } else {
                current = null
                this.store.push(res)
            }
        }
        return this.store
    }
}
function getValue(classObj, ...args) {
    let method = 'parse'
    let value = new classObj(p)[method](...args)
    console.log(value)
    function p(s) {
        return s
    }
}
s = `


It represents the faster worker because 3x>1x. It represents the fraction of the job done in 1 hour because the entire job is done in 7 hours and 7t1/7 is 1.
okay cool
`

//function p(s) {
//return s + "HI"
//}
//i = s.trim().split(/(\W+)/)
//t=(new ItemParser(p)).parse(i)
//console.log(t)

function quoteTheVeryInside(s) {
    const items = split(s, /([a-z]{2,}\()/i)
    const length = items.length - 1
    const target = items.pop().slice(0, -length)
    return (
        items.join('') +
        singlequote(target) +
        ')'.repeat(length)
    )
}
//s = "toLatex(nerdSolver(toLatex(r-2 /6 = 5)))"
//console.log(quoteTheVeryInside(s))

//console.log(dreplace('sgvgh', {g:'a'}, null))

//const regex = RegExp(ncg('^(?:($1|@\\w+) (.+))', ['a']), 'm')
//console.log(regex)

function unCamelCase(s) {
    if (test(/[a-z][A-Z]/, s)) {
        return capitalize(
            s.replace(
                /[a-z][A-Z]/g,
                (x) => x[0] + ' ' + capitalize(x[1])
            )
        )
    }
    return s
}
//obj = {a:1, b:2, c:3}
//s = reduceToString(obj, (fontFamily, weights) => {
//console.log(fontFamily, weights)
//})

function mathTemplater3(s, ref) {
    /* very simple */
    let regex = /(?:[+-] |\$)?\$\d+/g
    return s.replace(regex, runner)

    function getValue(b) {
        if (isNestedArray(ref)) {
        }
        let value = ref[Number(b) - 1]
    }
    function runner(s) {
        let money
        let a
        let b
        let sign

        if (s.includes('$$')) {
            money = true
            b = s.split('$$')[1]
        } else {
            ;[a, b] = s.split('$')
            if (a) {
                sign = a[0]
            }
        }

        let value = getValue(b)
        if (money) {
            return toMoney(value)
        }
        if (value < 0 && sign == '-') return '+ ' + value * -1
        if (value < 0) return '- ' + value * -1
        return a + value
    }
}
function templater2(s, ref, keep) {
    /* for the spaceOrNothing html fn located in r6 */
    if (!s.includes('$')) {
        return isObject(ref) ? dreplace2(s, ref) : s
    }

    let regex = /\$(\{.*?\}|\w+\(.*?\)(?!\))|\d+|[\w-]+\b)/g
    if (isPrimitive(ref)) {
        ref = [ref]
    }

    let functionals = []
    let offset = s.includes('$0') ? 0 : 1

    function runner(s) {
        const value = _runner(s)
        return value
    }

    function _runner(s) {
        return s.replace(regex, (_, x) => {
            if (x == 'c') return '$c'
            //if (x == 'last') return eLastValue
            if (x.startsWith('{')) {
                let a = x.slice(1, -1)
                let b = _runner(a)
                b = b.replace(/\(([-a-zA-Z]+)\)/g, '("$1")')
                let eValue = eval(b)
                eLastValue = eValue
                return eValue
            }

            if (x.includes('(')) {
                let [a, b] = search(/(\w+)\((.*?)\)$/, x)
                if (isWordFragment(b)) {
                    b = quotify(b)
                }
                let c = _runner(b)
                if (isWordFragment(c)) {
                    c = quotify(c)
                }
                let t = `${a}(${c})`
                let eValue = eval(t)
                eLastValue = eValue
                return eValue
            }
            let val = isArray(ref)
                ? ref[Number(x) - offset]
                : ref[x]

            let capitalizeIt
            if (val == null) {
                if (isCapitalized(x)) {
                    val = ref[x.toLowerCase()]
                    if (!val) throwError(x)
                    capitalizeIt = true
                } else {
                    return keep ? '$' + x : ''
                }
            }

            if (isFunction(val)) {
                val = val()
            }
            return capitalizeIt ? capitalize(val) : val
        })
    }
    return runner(s)
}

function templaterf(ref, options = {}) {
    if (isString(ref)) {
        return lambda(...arguments)
    }
    let lastValue
    let ordinalCount = 1
    let store
    let regex = /\$(\{.*?\}|\w+\(.*?\)(?!\))|\d+|[\w-]+\b)/g
    return lambda

    function lambda(s, _ref, config = {}) {
        if (_ref) ref = _ref
        if (isPrimitive(ref)) {
            ref = [ref]
        }

        if (!s.includes('$')) {
            return isObject(ref) ? dreplace2(s, ref) : s
        }
        return _runner(s, config)
    }

    function _runner(s, config = {}) {
        return s.replace(regex, (_, x) => {
            if (config.blank && config.blank.includes(_)) {
                //console.log('sup')
                return '$input'
            }
            if (x == 'ordinal') {
                if (config.ordinal) {
                    return ordinal(config.ordinal)
                }
                return ordinal(ordinalCount++)
            }

            if (x == 'c') return '$c'
            if (x == 'last') return lastValue
            if (x.startsWith('{')) {
                let a = x.slice(1, -1)
                let b = _runner(a)
                b = b.replace(/\(([-a-zA-Z]+)\)/g, '("$1")')
                lastValue = eval(b)
                return lastValue
            }

            if (x.includes('(')) {
                let [a, b] = search(/(\w+)\((.*?)\)$/, x)
                if (isWordFragment(b)) {
                    b = quotify(b)
                }
                let c = _runner(b)
                if (isWordFragment(c)) {
                    c = quotify(c)
                }
                lastValue = eval(`${a}(${c})`)
                return lastValue
            }
            let val = isArray(ref)
                ? ref[Number(x) - offset]
                : ref[x] || ref['$' + x]

            if (val == null) {
                return options.keep ? '$' + x : ''
            }
            return val
        })
    }
}

function skip(x) {
    return x.filter((y) => !y.skip)
}

function stamp(text) {
    let [h, m, s, ms, ampm] = getHMSM()
    return blue(`${s}:${ms}  ${text}`)
}
function debug() {
    if (arguments.length == 1 && arguments[0]) {
        return
    }
    console.log('starting debug')
    const stack = getStackTrace()
    console.log(stack)
    console.log('end of debug')
}
s = `
goo:
d
f
f
f
d
a: sdf
df: fdsgfg
`
//console.log(smartAggregate(s))

function createAccessorsFromString(s) {
    const opts = {
        prefix: true,
        lambda: false,
        mode: Function,
    }

    const items = smartAggregate(s)
    //console.log(items); throw "";

    return reduce(items, (a, b) => {
        let bodyA = `return this._${a}`
        let bodyB = `this._${a} = arg\n${b}`
        let get = toStringFunction(a, '', bodyA, opts)
        let set = toStringFunction(a, 'arg', bodyB, opts)
        return [a, { get, set }]
    })

    /*  first used in lego.js to add in accessor properties for the LegoElement class mixin.
     *  
        el this.el
        es this.el.style 
        pp$ns toPixel($1) nb
        --------------------------------
        pos:
        el.style.left = pparg[0]
        el.style.top = pparg[1]
        text: el.innerText = arg 
     * */
}
//console.log(pipe([sayhi, saybye])())

function empty(s) {
    return s.length == 0
}
function setState(state, key, value) {
    state[key] = value
}

function isRegExpString(s) {
    return /^\/.{3,}\/\w* *$/.test(s)
}

function doubleLines(s) {
    return s.replace(/\n/g, '\n\n')
}

function toRegExp(s, ref, flags = '') {
    if (!ref) {
        /* s is an iterable
         * and there is no template
         * so we set the template*/
        if (isIterable(s)) {
            ref = s
            s = '(?:$1)'
        } else {
            return RegExp(s)
        }
    }
    let keys = prepareIterable(ref, 'keys')
    let regex = s.replace(/\$1/g, keys.join('|'))
    return RegExp(regex, flags)
}

function resolveSimilarities(storageValue) {
    /* it is used for resolving similarities between names.
     * often times, u may have a set of functions which have the same abbreviation. This function works to resolve that*/
    /* {"ab": ["appleBanana", "appleBox"]} --> {"ab": "appleBanana", "ab1": "appleBox"}*/
    const store = {}
    for (let [k, v] of Object.entries(storageValue)) {
        sorted(v).forEach((item, i) => {
            if (i == 0) {
                store[k] = item
            } else {
                store[k + i] = item
            }
        })
    }
    return store
}

function cleanupHtmlSpaces(s) {
    //s = s.replace(/<\w+>\s+<\/[\w-]+>\n/g, '')
    //s = s.replace(/<\w.*?["'\w]>\n +/g, '')
    s = s.replace(/ *<style>\s+<\/style>\n/g, '')
    s = s.replace(/ *<script>\s+<\/script>\n/g, '')
    return s
}
function undoComment(s) {
    return s.replace(/^(?:\/\/|#) */gm, '')
}
function removeEmptyLines(s) {
    s = s.replace(/^\S.*?\n\n+(?=\S)/, (x) => x.trim())
    return s.replace(/\n *\n *\n+/g, '\n\n')
}
function toFunctionNameRegex(name) {
    return RegExp('^(?:async )?function ' + name, 'm')
}
function tryCatchWrap(a, b) {
    if (!b) {
        b = 'console.log(e)'
    }
    return brackify('try', a) + ' ' + brackify('catch(e)', b)
}

//runDemo(resolveSimilarities)
//const stylediv = curryStart(divify, 'style', '')
//console.log(stylediv('hi\nbye'))

function toModuleImports(path, items) {
    return `${brackify(
        'var',
        toArray(items).map(addf(','))
    )} = require("${localPath(path)}")`
}

function toModuleExports(items) {
    return '\n' + join(map(items, 'module.exports.$1 = $1'))
}

function localPath(s, e = 'js') {
    s = addExtension(s, e)
    if (test(/^[\/.]/, s)) {
        return s
    }
    return './' + s
}

//console.log(toModuleImports('dfg', [1]))

function slicef(a, b) {
    if (b == null) return (x) => x.slice(a)
    return (x) => x.slice(a, b)
}

function arrayf(...keys) {
    return (x) => {
        return prepareIterable(x, 'entries').map((item, i) => {
            return map(keys, (k) => item[k])
        })
    }
}

function objectf(...keys) {
    return (x) => {
        return reduce(x, (k, v) =>
            keys.includes(k) ? v : null
        )
    }
}

//console.log(templater2('$1hi', 'f""'))

function getWord(s) {
    return match(/[a-z][\w]+/, s)
}

function splitf(
    x,
    {
        maxLength = 2,
        config = 0,
        presets = 0,
        clean = 1,
        first = 0,
    } = {}
) {
    /*
     * when x is a regex, it acts like @splitThePage
     * when x is a dict, it is used with splitonce
     * many parsers have the first element as a key
     * that is arg[0] of splitonce
     * arg[1] is then passed into it
     *
     * */
    if (isRegExp(x)) {
        return function lambda(s, n, ignoreClean) {
            if (clean && !ignoreClean) s = removeComments(s)
            let items = split(s, x)
            if (n == Array) return items.slice(0, 2)
            if (n) return items[n]
            //console.log(items)
            if (items.length > maxLength) {
                first = 1
                error = console.log
                error = identity
                error(`
                    For certain regexes, 
                    only a certain number of splits are ok
                    @splitThePage
                    maxLength represents this number of splits
                `)
            }
            if (first) return items[0]
        }
    }
    if (isObject(x)) {
        return function lambda(s) {
            let [a, b] = splitonce(s)
            try {
                return config
                    ? x[a](createConfig(b, presets), a)
                    : x[a](b, a)
            } catch (e) {
                console.log([a, b, s])
            }
        }
    }
}

function isComponentTag(s) {
    return /^[A-Z]|^v-/.test(s)
}

function isCapitalized(s) {
    return /^[A-Z]/.test(s)
}

function preview(s) {
    console.log(s)
    return s
    throw ''
}

const stopString = splitf(/^\/+ *stop.*/m, { first: 1 })
const splitThePage = splitf(/^--+/m, { first: 1, clean: 1 })

function Export(...args) {
    if (!isNode()) return
    if (args.length == 1) {
        module.exports = args[0]
    } else {
        map(args, (x) => (module.exports[x.name] = x))
    }
}
function matchf(r, cleanIt) {
    return (x) => {
        const value = match(r, x)
        return unique(
            cleanIt ? flat(value.map(partial(filter))) : value
        )
    }
}
function searchf(x) {
    if (isFunction(x)) {
        return x
    }
    return function lambdaSearch(s) {
        try {
            return search(x, s)
        }
        catch(e) {
            console.log({s, x})
            throw ''
        }
    }
}
function mtest(tests, s, fallback) {
    for (let [a, b] of tests) {
        if (test(b, s)) {
            return a
        }
    }
    return fallback || s
}

//console.log({a:join(filter(map([null, '2'], (x) => x)))})

//console.log(dreplacef(aobj)('a'))

function exports() {
    sort = sorted
    module.exports = {
        alphabet,
        isReferenceError,
        isSyntaxError,
        pairlog,
        WordToNumberDictionary,
        trace,
        getFunctionInfo,
        dog,
        display,
        noop,
        isUrl,
        seasons,
        StandardObject,
        isError,
        isSet,
        stringify,
        datestamp,
        getHMSM,
        getMDY,
        isString,
        isArray,
        reduce,
        uncomment,
        escapeNewlinesAndQuotes,
        yes,
        longShort,
        shortLong,
        getLines,
        isSimilar,
        push,
        iterTest,
        hasPeriod,
        getFunction,
        argumentGetter,
        argumentFiller,
        toMilliseconds,
        isAsync,
        partition,
        getInterestingBindings,
        hasBracket,
        throwError,
        coinflip,
        isUtf,
        opposite,
        CumulativeStorage,
        addProperty,
        exists,
        addPropertyLambda2,
        addPropertyLambda3,
        iterRange,
        isPureObject,
        isThisFunction,
        rainbow,
        average,
        Indexed,
        isObject,
        type,
        breaker,
        isNumber,
        test,
        range,
        isPrimitive,
        textTable,
        isDoubleIterable,
        isQuote,
        isStringNumberRange,
        Tally,
        coerceToNullIf,
        tally,
        isNestedArray,
        removeEs6,
        isLink,
        regexElongation,
        getFunctionName,
        isFunction,
        isPlural,
        toSpaces,
        replace,
        Watcher,
        isHtmlFile,
        isCssFile,
        isJavascriptFile,
        getQuotes,
        findKeyFactory,
        findKey,
        findKeys,
        getShortestLongest,
        getShortest,
        getLongest,
        findCaller,
        hasSymbol,
        toArray,
        looksLikeRegex,
        prepareRegex,
        wordToNumber,
        toStringDictionaryEntry,
        comment,
        hasSelector,
        isUndefined,
        isSelector,
        boundary,
        getVueErrorInfo,
        hasSpaces,
        isNull,
        toStringCallable,
        uncapitalize,
        insertBelow,
        linebreak,
        hasNewline,
        toNumber,
        removeQuotes,
        blockComment,
        modularIncrementNumber,
        unique,
        numbered,
        getLast,
        find,
        matchall,
        toggleFunction,
        ErrorWatcher,
        getClassString,
        getClassMethods,
        hasSharedKeys,
        isPublic,
        getClassProperties,
        findall,
        smallify,
        deletef,
        functiongetter,
        removeAllComments,
        getLastWord,
        getFirstWord,
        getFirst,
        xsplit,
        removeComments,
        search,
        matchgetter,
        prepareIterable,
        indent,
        joined,
        getYear,
        difference,
        errorWrap,
        insertText,
        isIterable,
        linegetter,
        isDefined,
        isBoolean,
        addGFlag,
        isFirst,
        isWord,
        isPromise,
        isJsonParsable,
        isRegExp,
        isFalse,
        isTrue,
        isClassObject,
        isClass,
        isNode,
        isJson,
        isElement,
        isInteger,
        isPositive,
        isCapitalized,
        isYesterday,
        isDate,
        isToday,
        zeroPad,
        backspaced,
        indexgetter,
        insert,
        getSpaces,
        rescape,
        replaceTemplaterHelper,
        spicyReplace,
        spicyTemplater,
        reverse,
        templater,
        hasCaptureGroup,
        getIndent,
        identity,
        trim,
        AssertionErrorHandler,
        AssertionError,
        assert,
        parens,
        len,
        hasNumber,
        sum,
        recursiveFlat,
        flat,
        doublequote,
        delta,
        toVariable,
        quotify,
        tail,
        bindObject,
        initializeStateVariable,
        bind,
        fparse,
        Cache,
        getLongestOld,
        dreplace,
        ncg,
        filterObjectHelper,
        filter,
        filterObject,
        filtered,
        getIndentAndLine,
        capitalize,
        singlequote,
        ftest,
        mapObject,
        mapConditional,
        merge,
        mergeAll,
        tryval,
        shuffle,
        Clock,
        addExtension,
        getExtension,
        sorted,
        n2char,
        char2n,
        newlineIndent,
        Storage,
        modularIncrement,
        modularIncrementFn,
        mreplace,
        sleep,
        parseJSON,
        splitonce,
        pop,
        fill,
        splitOnceReverse,
        split,
        regexed,
        paired,
        toUpperCase,
        depluralize,
        intersection,
        shared,
        changeDate,
        sortByDependencies,
        copy,
        toDashCase,
        toSnakeCase,
        toStringObject,
        toArgument,
        toString,
        toAttr,
        toPascal,
        toCamelCase,
        toggleVue,
        toggle,
        toDictionary,
        toLiteralArray,
        toInteger,
        roygbiv,
        numberToWord,
        numberWords,
        hasComma,
        hasLetter,
        hasWord,
        hasLookBehind,
        hasLookAround,
        endsWithWord,
        endsWithNumber,
        stringcall,
        dedent,
        getWords,
        zip,
        cartesianProduct,
        curry,
        force,
        isStorage,
        isNewLine,
        colorToHex,
        iter,
        StringMixins,
        mixin,
        Eater,
        notNull,
        trimSpaces,
        Matrix,
        getStrings,
        normalizeSpaces,
        partial,
        toStringArgument,
        splitmapfilter,
        splitMapJoin,
        argsplit,
        isOnlyWords,
        warn,
        getSingleAndDoubleAttrs,
        getOptions,
        aggregate,
        pipe,
        createError,
        replaceFromIndex,
        freplace,
        Table,
        evaluate,
        regexgetter,
        hasGFlag,
        regexStartsWithSpaces,
        inferlang,
        isAllCaps,
        abbreviate,
        TextTokenizer,
        getFunctionNames,
        removeSpaces,
        spaceToCamel,
        listgetter,
        spaceToSnake,
        createConfig,
        jspy,
        curryStart,
        stateCurryEnd,
        stateCurryStart,
        curryEnd,
        timestamp,
        wordCount,
        exporter,
        stateTrace,
        CodeLibrary,
        getfunctions,
        mapfilter,
        foo,
        getParameters,
        scopedEval,
        timegetter,
        getErrorInfo,
        getDetailedErrorInfo,
        ItemIter,
        forEach,
        getCaller,
        vars,
        trywrap,
        stringIIFEWrap,
        stringTryWrap,
        getLoggableProperties,
        removeStrings,
        addf,
        lineCount,
        saybye,
        sayhi,
        captureRegex,
        splitLast,
        replaceLast,
        bringToLife,
        addDeepKey,
        collectObjectFromString,
        looksLikeProse,
        getFirstParameter,
        isStandardHtml,
        fixUrl,
        isSymbol,
        consoleThrow,
        getChunks,
        pluralize,
        findallStrings,
        isStandardCss,
        reduceToString,
        join,
        wrap,
        hasOwn,
        startsWithSymbol,
        splitOnceSymbolOrWord,
        IndexError,
        mergeProps,
        mergeFunction,
        compose,
        coerceToArray,
        coerceToString,
        coerceToNumber,
        startsWithPeriod,
        splitOptionalComma,
        brackify,
        hasColon,
        hasDash,
        getFirstLine,
        removeStartingSpaces,
        toFunction,
        toFunctionRegex,
        getSpacesFromOffset,
        countParentheses,
        countCaptureGroups,
        getLastLine,
        iterSearch,
        itersearch,
        findError,
        hasCamelCase,
        lbreplace,
        sreplace,
        toRequireString,
        removeFunctionPrefix,
        removeExtension,
        getStackInfo,
        getStackTrace,
        isCss,
        IndexedMap,
        isSingleCssProperty,
        smartDedent,
        Iter,
        LineEdit,
        isEnterBlock,
        fixSpaceLength,
        isHtml,
        isHtmlAttr,
        EventEmitter,
        testf,
        vmap,
        atFirst,
        atSecond,
        logger,
        run,
        IncrementalBuilder,
        getUniqueLetters,
        isAllEqual,
        fillTo,
        Builder,
        getVariablesFromString,
        toStringFunction,
        checkjs,
        toAbbreviationRegex,
        expensiveFuzzyMatch,
        fuzzyMatch,
        isAllSingleWords,
        startsWithSingleWord,
        count,
        isLogicFunction,
        isGetFunction,
        sortByOccurence,
        toVimVariable,
        toConfig,
        toVimDict,
        splitparsef,
        splitCamelCase,
        mergeSingleLetters,
        fixPath,
        once,
        seen,
        FunctionBuilder,
        splitNumberBoundary,
        functionProxy,
        isStorageSchema,
        toStorageSchema,
        getModuleExports,
        catpics,
        regexTemplater,
        dynamicGetterSetter,
        hasReturnValue,
        defineFunctionProperty,
        defineProperty,
        toArrayOrObjectList,
        isEven,
        isOdd,
        removeSymbols,
        edit,
        isWordy,
        walk,
        allowIgnoreFilterFactory,
        toHtmlRegex,
        removeHtmlComments,
        stop,
        assignAliases,
        assignFresh,
        assignExisting,
        rng,
        randomPick,
        onceFactory,
        getIndexesOf,
        schemaMatch,
        MathRearrangement,
        getOptionsFromSchema,
        defineAliases,
        KVStorage,
        letterRange,
        partitionLetterGroups,
        recursiveDataBuilder,
        debounce,
        Breaker,
        BreakerFactory,
        getAndGetAgain,
        tryAndTryAgain,
        buildFileRelations,
        gatherArgs,
        assertion,
        actions,
        optiongetter,
        waterfall,
        incrementName,
        defineVariable,
        datemark04082022,
        getThis,
        standards,
        lineNeedsEndingColon,
        infuseVue,
        infuseSpanColors,
        spanify,
        validArgs,
        schemaRegexFactory,
        removeThis,
        bindObjectToState,
        bringFunctionsToLife,
        schemaReplace,
        xveryMagicLogicHandler,
        xnothingInfront,
        defineEmitProperty,
        endsWithParentheses,
        lengthDelta,
        indentAfterFirstLine,
        templateToFunction,
        runit,
        mergeProperty,
        mergeOnTop,
        mapfilter,
        multiSort,
        rigidCompareFactory,
        getSecondWord,
        isObject,
        isObjectLiteral,
        conditional,
        announceError,
        countParameters,
        createVariable,
        repf,
        conditional,
        addNestedProperty,
        getParamInfo,
        coerceTo,
        intersects,
        latexTemplater,
        lineFilter,
        getNumbers,
        findall2,
        lowerCase,
        notIn,
        editStorage,
        getConstructorName,
        log,
        smartAggregate,
        partial,
        match,
        pairWith,
        atObject,
        normalizePath,
        extractArg,
        map,
        bindObject,
        removeJavascriptComments,
        dreplace2,
        getVariables,
        quoteTheVeryInside,
        spellcheckf,
        blue,
        doubleLines,
        toRegExp,
        empty,
        isRegExpString,
        cleanupHtmlSpaces,
        undoComment,
        removeEmptyLines,
        tryCatchWrap,
        toFunctionNameRegex,
        spellcheckf,
        removeComments,
        superbf,
        sort,
        runDemo,
        logf,
        filterf,
        toModuleImports,
        toModuleExports,
        slicef,
        objectf,
        atBoth,
        hasCode,
        reWrap,
        templater2,
        reWrap,
        reStr,
        toCamelCase,
        dogLogFactory,
        Export,
        splitThePage,
    }
}

module.exports.matchf = matchf
module.exports.arrayf = arrayf

function mooLexer(s, states) {
    const moo = require('moo')
    const first = getFirst(states)
    const lexer = states[first].match
        ? moo.compile(states)
        : moo.states(states)

    lexer.reset(s)
    return lexer
    const value = map(lexer, objectf('type', 'value'))
    console.log(value)
    return value
    return map(lexer, arrayf('type', 'value'))
}
module.exports.mooLexer = mooLexer
module.exports.replacef = replacef
module.exports.incrementf = incrementf
module.exports.toJSON = toJSON

function toJSON(x) {
    if (!x) return null

    if (!isObject(x)) {
        return x
    }

    if ('getValue' in x) {
        return x.getValue()
    }

    if ('storage' in x) {
        return x.storage.store
    }

    if ('store' in x) {
        return x.store
    }

}

function incrementf(
    template,
    { offset = 0, limit = 1000 } = {}
) {
    if (isObject(template)) {
        return incrementf(null, template)
    }
    let count = offset
    if (isFunction(template)) {
        return function lambda() {
            return template(count++)
        }
    }
    function lambda() {
        if (count > limit) count = 0
        if (!template) return count++
        return template.replace(/[1a]/i, (x) => {
            count++
            switch (x) {
                case 'a':
                    return n2char(count - 1)
                case 'A':
                    return capitalize(n2char(count - 1))
                case 'i':
                    return count
                case '$1':
                    return count
                case '1':
                    return count
            }
        })
    }
    function reset() {
        count = offset
    }
    lambda.reset = reset
    return lambda
}

module.exports.unCamelCase = unCamelCase

module.exports.isComponentTag = isComponentTag

function addQuotes(s) {
    let quoteRE = /^(?:".*?"|'.*?')/
    if (test(quoteRE, s)) {
        return s
    }
    return quotify(s, '"')
}
function removeVPrefix(s) {
    return toCamelCase(s.replace(/^[a-zA-Z]+-/, ''))
}
module.exports.addQuotes = addQuotes
module.exports.removeVPrefix = removeVPrefix
//console.log(templater2( '${removeVPrefix($1)}', 'v-boo'))
//
var getIndex = incrementf()

function aggregator0711(s, a, b) {
    a = 'd'
    b = 'ex?'
    const regex = RegExp(
        '([^]+?)\\n${a} *\\n([^]+?)(?:${b}|$)',
        'g'
    )
    const m = findall(regex, s)
    console.log(m)
}
module.exports.isProse = isProse
module.exports.endAdderF = endAdderF
module.exports.fastFunction = fastFunction
//console.log(map([{a:1, b:2, c:3}, {a:31, b:2, c:3}], 'a'))
//
//

s = 'table(1/x, evaluate) from 1 to 5 [fraction, decimal value]'
/* it returns a object with type table */
function addRegexCaret(s, flags = '') {
    if (/^\/?\^/.test(s.toString())) {
        return s
    }

    if (isString(s)) {
        return RegExp('^' + s, flags)
    }
    if (!flags) flags = s.flags
    s = reStr(s)
    return RegExp('^' + s, flags)
}
const tableRegexSet = {
    columns: /\w*\((.*?)\)/,
    headers: /\[(.*?)\]/,
    from: /from (\w+)/,
    to: /to (\w+)/,
}
mutate(tableRegexSet, addRegexCaret)

function aggTableArgs(
    s,
    regexSet,
    parserRef = {
        headers: capitalize,
    }
) {
    const store = new Storage()
    const regexes = Object.entries(regexSet)
    let found
    while (true) {
        s = s.trim()
        found = false
        for (let [k, v] of regexes) {
            let m = s.match(v)
            if (!m) continue
            found = true
            s = s.slice(m[0].length)
            let value = matchgetter(m)
            if (isPlural(k)) {
                value = split(value, commaRE)
            } else if (isNumber(value)) {
                value = Number(value)
            }
            if (parserRef[k]) {
                if (isArray(value)) {
                    value = value.map(parserRef[k])
                } else {
                    value = parserRef[k](value)
                }
            }
            store.add(k, value)
        }
        if (!found) break
    }
    return toJSON(store)
}

function tabler({ from = 1, to = 10, headers, columns }) {
    const type = 'table'
    const store = []
    let lastVal
    for (let i = from; i <= to; i++) {
        store.push(
            columns.map((col) => {
                if (isExpression(col)) {
                    lastVal = col.replace(/x/, i)
                    return toLatex(lastVal)
                }
                if (col == 'evaluate') {
                    return nerdSolver(lastVal)
                }
                return eval(
                    col.replace(/\(\w\)/, (x) => {
                        return parens(lastVal)
                    })
                )
            })
        )
    }
    return { headers, store, type }
}
module.exports.mutate = mutate

module.exports.classMixin = classMixin
s = `

series(20/100, 2000/100000, 3000/1000000 blank($n, $eval))
    $n = log10($2)
    $n2 = log10($2)
    $1/$2 means take $1, and shift the decimal left $n places.
    $map($n, $ordinal shift: $eval($1/Math.pow(10, $i)))
    Final Answer: $last
`
ss = `

series(10, 100 b, 1000 b, 10000 b, 100000)
    $n = $i
    $p = pluralize('place', $n)
    Dividing by $1 shifts the decimal point to the left by $n $p.
`
const seriesRegexSet = {
    args: /series\((.*?)\)$/m,
    headers: /\[(.*?)\]/,
    vars: /\$\w+ *= *.+/,
    code: /.+/,
}

function logn(n, base) {
    const value = Math.log(n) / Math.log(base)
    return isInteger(value) && value

    for (let i = 1; i < 10; i++) {
        if (Math.pow(base, i) == n) {
            return i
        }
    }
}

function log10(n, base = 10) {
    return Math.round(Math.log(n) / Math.log(base))
}
function seriesParser(s) {
    const { args, code, vars } = aggTableArgs(s, seriesRegexSet)
    const templater = templaterf()
    const argValues = args.map((arg, i) => {
        let blankRE = /\b(b) *$|blank\((.*?)\)/
        let [item, blank] = mreplace(blankRE, arg)
        blank = blank ? split(blank, / *, */) : []
        if (blank[0] == 'b') {
            blank = ['$n']
        }
        //console.log(blank)
        let potentials = findall(/\w+/g, item)
        let varDictionary = {}

        potentials.forEach((item, i) => {
            varDictionary[i + 1] = item
        })

        function fn(acc, item) {
            let [a, b] = splitonce(item, equalRE)
            if (b == '$count' || b == '$i') {
                acc[a] = i + 1
            } else {
                acc[a] = tryval2(templater(b, acc))
            }
        }

        mutateInPlace(vars, fn, varDictionary)

        return code.map((item, i) => {
            if (isCallable(item)) {
                let [n, b] = match(/([\w$]+), *(.+)\)$/, item)
                n = varDictionary[n]

                return range(n).map((i) => {
                    varDictionary.i = i

                    return templater(b, varDictionary, {
                        blank,
                        ordinal: i,
                    })
                })
            } else {
                return templater(item, varDictionary, { blank })
            }
        })
        return codeValue
    })

    return argValues.every((x) => x.length == 1)
        ? argValues.map((x) => x[0])
        : argValues
}

//console.log(['$n'].includes('$n'))

function isCallable(s) {
    return isString(s) && test(/^[$\w]+\(/, s)
}

function mutateInPlace(items, f, acc) {
    for (let item of items) {
        f(acc, item)
    }
}

function R0714(s, flags = '', capture = 1) {
    RSTR = `

    TOKENS:
    fraction \\d+/\\d+|[a-z]+-[a-z]+
    word-number [a-z]+-[a-z]+
    number -?\\d+(?:\\.\\d+)?%?
    REGEXES:

    number (?:$number|$word-number)
    comparison (?:more|less) than|(?:times )?of|(?:times|less)
    `
    const { REGEXES, TOKENS } = aggregateRegexes(RSTR)
    mutate(REGEXES, replacer, String, TOKENS)
    //console.log(TOKENS, REGEXES); throw '';
    //console.log(REGEXES)

    function replacer(x, mode, TOKENS) {
        let flags = ''
        let r = x.replace(/\$([a-zA-Z-]+\d*)/g, (_, x) => {
            let value = TOKENS[x]
            if (isPlural(x) && /\w+(?: \w+)*/.test(value)) {
                return reWrap(split(value))
            }
            return value
        })
        if (mode == String) return r
        r = r.replace(/\\\\/g, '\\')
        let regex = RegExp(r, flags)
        return {
            match: regex,
        }
    }

    const regex = s.replace(templaterRE, (_, x) => {
        const value = REGEXES[x]
        if (capture) return parens(value)
        return value
    })

    return RegExp(regex, flags)
}

function del(r, s, { after = '.*', flags = '' } = {}) {
    if (isRegExp(r)) {
        return s.replace(r, '')
    }

    let regex
    if (isString(r)) {
        regex = `(?:${r})${after}`
    } else {
        flags = r.flags
        regex = r
    }
    regex = RegExp(regex, flags)

    return s.replace(regex, '').trim()
}
function aggregateRegexes(s) {
    let splitRE = /^(\w+):$/m
    let splitonceRE = /^([\w-]+) +(.+)$/gm
    let fn = compose(toDictionary, matchf(splitonceRE))

    return toDictionary(
        map(
            partition(split(smartDedent(s), splitRE)),
            atSecond(fn)
        )
    )
}
function hasValue(s) {
    return s != null
}
function greeting(name, mood = 'default') {
    const templates = [
        { value: 'hi', mood: 'default' },
        { value: 'hi', mood: 'default' },
        { value: "how's it going!", mood: 'upbeat' },
    ]

    let template = templates.filter((x) => x.mood == mood)[0]
    if (template.direction) {
        return coinflip()
            ? capitalize(name) + ', ' + addComma(template.value)
            : capitalize(template.value) + ' ' + name + ','
    } else {
        return capitalize(template.value) + ' ' + name + ','
    }
    return templater(template, name)
}
module.exports.del = del
module.exports.R0714 = R0714

function topOf(s, percent = 0.4) {
    let length = s.length
    let portion = Math.round(length * percent)
    return s.slice(0, portion)
}
function btest(regex, s) {
    return RegExp('\\b' + regex + 's?\\b', 'i').test(s)
}
module.exports.btest = btest
module.exports.topOf = topOf
//console.log(join(['a', 'b'],[], ['v', 'fff']))
//console.log(len(3.32))
//console.log(bringToLife('(100 + a) * b / 100')(10,20))

function babyName(i) {
    return capitalize(babyNames[i])
}

function lineParser(s, fn, useSpaces = 1) {
    s = smartDedent(s)
    return linegetter(s, null).map((line, i, lines) => {
        if (useSpaces) {
            let [spaces1, line1] = getIndentAndLine(line)
            let next = lines[i + 1]
            let [spaces2, line2] = next
                ? getIndentAndLine(next)
                : [null, null]
            return fn(spaces1, line1, spaces2, line2)
        }
        return fn(line, lines[i + 1], i)
    })
}
function turnIntoConversation(s) {
    let names = selectIndexes(babyNames, 2, 1, 1).map(babyName)
    let store = []
    lineParser(s, (line, next, i) => {
        let soloDollar = test(/\b\$\b/, s)
    })
    console.log(names)
    throw ''
}
//console.log(turnIntoConversation())
//let r = R0714('$number $comparison $number$')
//console.log(r)

module.exports.toStringObject = toStringObject

module.exports.isCallable = isCallable
module.exports.ItemParser = ItemParser

//console.log(seriesParser('+', 4, 12, 0))

function blankf(indexes) {
    return (x, i) => {
        return indexes.includes(i) ? null : x
    }
}
//console.log(patternParser('3x + 2 + 3x', 1, 1, 5, 'R'))

//console.log([[3,4], [1,2]].map(atBoth({a: (x) => x + 1, b: (x) => x + 2})))
module.exports.filterSecond = filterSecond

function sayhif({ mood = '' } = {}) {
    let ending = '.'
    if (mood == 'upbeat') {
        ending = '!'
    }

    let selfs = ['My name is', 'I am']
    let greetings = [
        'hello everyone',
        'Hi everyone',
        'Good afternoon ladies and gentlemen',
    ]
    greetings = shuffle(greetings)
    return function lambda(name) {
        let self = randomPick(selfs)
        let greeting = greetings.pop()
        return `${greeting}${ending} ${self} ${name}.`
    }
}
//const a = linegetter(sequences).map((x) => x.split(''))
//console.log(flat(a).length); throw '';

function getStudents(key) {
    const ref = {
        summer2022: ['diego', 'joel', 'marylynn'],
    }
    if (!key) {
        key = getSeason() + getYear()
    }
    return shuffle(ref[key].map(capitalize))
}
function getSeason(date) {
    const month = (date || new Date()).getMonth() + 1
    switch (month) {
        case 12:
        case 1:
        case 2:
            return 'winter'
        case 3:
        case 4:
        case 5:
            return 'spring'
        case 6:
        case 7:
        case 8:
            return 'summer'
        case 9:
        case 10:
        case 11:
            return 'autumn'
    }
}
function runClass(X, s, ...args) {
    if (arguments.length == 0) {
        return
    }
    const f = exporter(X, ...args)
    return f(s)
    return console.log(stringify(f(s)))
}

//runClass(Dialogue)
module.exports.runClass = runClass

function simplePeriodify(s) {
    if (test(/^[a-zA-Z]+\d+/, s)) {
        /* ignore it because not prose */
        return s
    }
    if (test(/^[a-z][a-z']{1,}[,.]? [a-z]/i, s)) {
        /* if it starts with prose-like words capitalize it */
        s = capitalize(s)
    }

    if (test(/[.?!"]$/, s)) {
        /* if it has ending grammar return it */
        return s
    }

    if (test(/[a-z]1$/, s)) {
        /* if it ends with 1, exclam it */
        return s.replace(/1$/, '!')
    }

    if (questionWords.includes(getFirstWord(s).toLowerCase())) {
        /* if it is a question */
        return s + '?'
    }
    return s + '.'
}

module.exports.getStudents = getStudents
module.exports.simplePeriodify = simplePeriodify
module.exports.sayhif = sayhif
module.exports.isQuestion = isQuestion
//console.log(['a', 'b', 'c', 'd', 'e'].slice(-2))
//console.log(datePhrase('$season$year'))
//

stest = `

el this.el
es this.el.style 
pp$ns toPixel($1) nb
--------------------------------

pos:
el.style.left = pparg[0]
el.style.top = pparg[1]

height: es.height = pparg
width: es.width = pparg

text: el.innerText = arg 
color: es.color = arg 
background: es.background = arg
`

//console.log(createAccessorsFromString(stest))
//
//

function small(x) {
    return x.slice(0, 2)
}
//console.log(datePhrase('$Season $year'))

function throwError(x) {
    console.log({ ERROR: x })
    throw ''
}

function joinDashes(...args) {
    return args.filter(exists).join('-')
}
data = [600, 600, 600, 500, 200, 300, 400, 500, 400, 300].map(
    (x) => ({ height: x })
)

function partitionByHeights(
    datum,
    { threshold = 1050, margin = 10, padding = 10 } = {}
) {
    const store = new Storage()
    let count = 0

    let h = 0
    let lastTop
    for (let i = 0; i < datum.length; i++) {
        let data = datum[i]
        console.log(data)
        if (data.top == lastTop) {
            store.add(count, i)
            continue
        }
        let height = parseInt(data.height)
        h += margin
        if (h + height > threshold) {
            count++
            h = height
        } else {
            h += padding + height
        }
        store.add(count, i)
        lastTop = data.top
    }
    //nolog(store)
    return Object.values(toJSON(store))
}
function nolog(...args) {
    if (exists(args)) {
        console.log(...args)
    }
    console.log = noop
}

function getPartitionsFromIndexes(store, data) {
    return store.map((a) => {
        return a.map((i) => data[i])
    })
}
//anestlist.flat()
//runDemo(removeAllComments)
el = {
    children: [
        {
            className: 'b',
            children: [{ className: 'c' }, { className: 'd' }],
        },
    ],
    className: 'a',
}
function skelNames(el) {
    const limit = 4
    const store = {}
    /* something about the stack is not popping  */
    let current = store
    let key = 'root'
    runner(el)
    return console.log(store)

    function runner(el, depth = 0) {
        if (depth == limit) {
            return
        }
        if (!el.children || !el.children.length) {
            current[key] = el.className
            return
        }

        depth++
        key = el.className
        current[key] = {}
        current = current[key]

        for (let child of el.children) {
            runner(child, depth)
        }
    }
}
//console.log(skelNames(el))

class Fo {
    constructor() {}
    run() {
        console.log(getAlias())
    }
}
function getAlias(x, key, fallback) {
    if (!x) return ''
    if (!key) key = getCaller(-1)
    s = `
        psuedo:
        b before
        h hover
        a after

        Zook:
        mo ag
    `
    const ref = smartAggregate(s)
    Object.assign(ref, {
        paper: {
            letter: {
                width: 8.5,
                height: 11,
                unit: 'inches',
                padding: 0.5,
            },
            notecard: {
                width: 3,
                height: 5,
                unit: 'inches',
                padding: 0.25,
            },
        },
    })
    return dictgetter(ref, key, x)
}

function splitByLength(a, n) {
    return [a.slice(0, n), a.slice(n)]
}
function splitArray(a, n) {
    if (n === null) {
        const storage = new PageStorage()
        a.forEach((item, i) => {
            if (item === null) {
                storage.count++
                return
            }
            storage.add(item)
        })
        return Object.values(toJSON(storage))
    }

    if (isNumber(n)) {
        return splitByLength(a, n)
    }

    let include = false
    include = include ? 0 : 1
    for (let i = 0; i < a.length; i++) {
        if (ftest(n, a[i])) {
            return [a.slice(0, i), a.slice(i + include)]
        }
    }
    return [a, []]
}
//console.log(timestamp())
//console.log(splitArray(abclist, 2))
//
//
//
function isValidNerdamer(s) {
    if (s.includes('/')) return s.length < 6
    return 1
}
function isValidCSS(s) {
    return hasBrackets(s)
}

//assert('g', isValidCSS)
function getThis(state, key) {
    let f
    if (isString(key)) {
        f = (x) => getConstructorName(x) == key
    }
    return Object.values(filter(state, f))
}
//class Fos {
//constructor() {
//this.g = 'h'
//}
//}
//console.log(getThis(new Fos, 'String'))
s = `
toArgument


null null
[1,2] hi
hi bye
{a:6} ''
`
function testsuite(f, x) {
    function testsuiteMath(f, x) {
        const data = isNumber(x) ? range(x) : linegetter(x)

        return data.map((arg) => testRunner(f, arg))
    }

    function testRunner(f, args) {
        args = toArray(args)

        try {
            return {
                inputArgs: args,
                output: f(...args),
            }
        } catch (e) {
            return {
                inputArgs: args,
                error: e.toString(),
                caller: getCaller(0, 0, e),
            }
        }
    }

    function testsuite2(f, x) {
        return linegetter(x)
            .map((x) => fget(/\S+/g, x).map(toArgument))
            .map((args) => testRunner(f, args))
    }

    let caller
    let test = testsuite2

    if (!x) {
        if (!f) f = s
        /* global s value */
        f = removeComments(f)
        if (hasOperator(f)) {
            test = testsuiteMath
        }
        let [a, b] = splitonce(linegetter(f))
        caller = a
        f = bringToLife(a)
        x = b
    } else {
        caller = f.name
    }

    const results = test(f, x)

    console.blue(test.name)
    console.blue(caller)
    console.log(results)

    return { caller, results }
}
function mget(r, s, flags = '') {
    const store = []
    const sliceBy = hasCaptureGroup(r) ? 1 : 0

    function parser(...args) {
        let value = smallify(
            args.slice(sliceBy, -2).filter(isDefined).map(trim)
        )
        store.push(value)
        return ''
    }

    const text = replace(r, parser, s, flags)
        .replace(/^\n+/, '')
        .trimEnd()

    let singular = r.flags
        ? !r.flags.includes('g')
        : !flags.includes('g')
    if (singular) {
        const storeValue =
            store.length == 1
                ? store[0]
                : store.length == 0
                ? ''
                : store
        return [text, storeValue]
    }
    return [text, store]
}
//testsuite(s)
module.exports.testsuite = testsuite

class Picker {
    constructor(items) {
        if (items) {
            this.items = items
            this.index = 0
        } else {
            this.store = {}
        }
    }
    load(key, value) {
        this.store[key] = new Picker(value)
        this.activeKey = key
    }
    pick(key) {
        if (this.store) {
            return this.store[this.activeKey].pick(key)
        }

        if (key) {
            let value = fuzzyMatch(key, this.items)
            if (value) {
                this.index = this.items.indexOf(value)
                this.value = value
            }
        } else {
            this.value = modularIncrement(
                this.items,
                this.index
            )
        }
        return this.value
    }
}

function rngRange(...ranges) {
    return rng(...randomPick(ranges))
}

function randomColor({
    mode = String,
    forbiddenColors = false,
    pastel = false,
    vibrant = false,
    cool = false,
    spring = false,
    autumn = false,
} = {}) {
    let s1 = 75
    let s2 = 100
    let l1 = 40
    let l2 = 90
    let h1 = 0
    let h2 = 360
    let a = 1
    let h
    if (arguments[0] == null) {
        vibrant = true
    }

    if (pastel) {
        s1 = 80
        s2 = 100
        l1 = 80
        l2 = 100
        h = rngRange([0, 24], [100, 360])
        a = rng(2, 6) / 10
    } else if (vibrant) {
        s1 = 100
        l1 = 50
        l2 = 60
        h = rngRange([0, 24], [100, 360])
    } else if (cool) {
        s1 = 100
        l1 = 50
        l2 = 60
    }

    let s = rng(s1, s2)
    let l = rng(l1, l2)

    if (pastel) {
        if (s <= 70) l = 100
        if (l <= 70) s = rng(95, 100)
    }

    if (!h) h = rng(h1, h2)

    return mode == String
        ? `hsla(${h}, ${s}%, ${l}%, ${a})`
        : [h, s, l, a]
}

function toObject(k, v) {
    if (isDefined(v)) {
        return { [k]: v }
    }
    return k
}
module.exports.ignoref = ignoref

/* import nerdamer */

const COMMON_FRACTIONS = [
    '1/2',
    '1/3',
    '1/4',
    '1/5',
    '1/6',
    '1/7',
    '1/8',
    '1/9',
    '2/3',
    '3/4',
    '4/5',
    '5/6',
    '6/7',
    '7/8',
    '8/9',
]
function print(s) {
    console.log(stringify(s))
}
const PRIMES = [
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,
    59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,
    127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,
    191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,
    257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
    331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
    401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
    467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,
    563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619,
    631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
    709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787,
    797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
    877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953,
    967, 971, 977, 983, 991, 997, 1009, 1013,
]

function primesFrom(a, b, n) {
    if (!b) {
        b = a
        a = 0
    }
    let c = PRIMES.findIndex((x) => x >= a)
    let d = PRIMES.findIndex((x) => x >= b)
    let primes = PRIMES.slice(c, d)
    if (n && primes.length < n) {
        primes.push(...PRIMES.slice(d, d + n - primes.length))
    }
    return primes
}

function coinflip(n = 0.5) {
    return Math.random() > 1 - n
}

function hasMultipleVariables(s) {
    return count(/\b[a-z]\b/g, s) > 1
}

function allEqual(arr) {
    return arr.every((x) => x == arr[0])
}

function hasEquals(s) {
    return test(/=/, s)
}

function hasVariableX(s) {
    return test(/x/, s)
}

function hasNaN(s) {
    return s.toString().includes('NaN')
}

function isPositive(n) {
    return n > 0
}
function isNiceAnswer(n) {
    return n > 0 && isInteger(n) && n <= 10
}

function hasTerminatingDecimal(s) {
    return len(s) < 6 || isRepeatingDecimal(s)
}

function getPrimeFactors(n) {
    return getFactors(n).filter(isPrime)
}

function getDigitsFromString(x) {
    return String(x).split('').map(Number)
}

function notPrime(n) {
    return !isPrime(n)
}

function power10(n) {
    return Math.pow(10, n)
}

function getDecimalLength(n) {
    return search(/\.(.+)/, n).length || 0
}

function getOperators(s) {
    return findall(mathOperatorRE, s)
}

function getOperator(s) {
    return search(mathOperatorRE, s)
}

function allSame(items) {
    return items.every((x) => x == items[0])
}

function hasMathOperator(x) {
    return test(/[^*+-]/, x)
}

function isNegativeAnswer(s) {
    return String(s).trim().startsWith('-')
}

function isLatexOperator(s) {
    const r = /[\+\-\*]/
    return test(r, s)
}

function isLatexFraction(s) {
    return test('frac', s)
}

function isLatexExponent(s) {
    return /^\w+\^/.test(s)
}

function simplifyRatio(a, b) {
    let g = gcd(a, b)
    return [a, b].map((x) => x / g)
}

function hasDecimal(x, n = 0) {
    return test('\\.' + '\\d'.repeat(n), String(x))
}

function isSquare(x) {
    return !hasDecimal(Math.sqrt(x))
}

function isCube(x) {
    return !hasDecimal(Math.cbrt(x))
}

function toPercent(s) {
    let value = fixFloatingPoint(100 * s) + '%'
    //console.log(s, value)
    return value
}

function toPercentage(a, b) {
    return 100 * (a / b).toFixed(2) + '%'
}

function fractionToPercent(a, b) {
    return 100 * (a / b).toFixed(2) + '%'
}

function hasVariable(s) {
    return test(/\b[abcde]\b/, s)
}

function isTerminating(a, b) {
    if (isPrime(b)) return false
    return true
}

function lcm(a, b) {
    return (a * b) / gcd(a, b)
}

function countDecimalPlaces(n) {
    return (n.toString().split('.')[1] || '').length
}

function divmod(n, d) {
    return [Math.floor(n / d), Math.floor(n % d)]
}

function toRatio(a, b) {
    return simplifyRatio(a, b).join(':')
}

function isPercentage(s) {
    return s.toString().endsWith('%')
}

function isRepeatingDecimal(s) {
    s = s.toString()
    if (!s.includes('.')) return
    const decimal = s.split('.')[1]
    return allEqual(split(decimal.slice(4)))
}

function getFactorPairs(number) {
    const factors = []
    const seen = []
    for (var i = 1; i <= number; i++) {
        if (seen.includes(i)) continue
        if (number % i == 0) {
            let other = number / i
            seen.push(other)
            factors.push([i, other])
        }
    }
    return factors
}

function countFactors(n) {
    return getFactors(n).length
}

function gcd(a, b, ...args) {
    if (args.length > 0) {
        return [a, b, ...args].reduce((acc, item) =>
            gcd(acc, item)
        )
    }
    if (a == 0) return b

    while (b != 0) {
        if (a > b) a = a - b
        else {
            b = b - a
        }
    }
    return a
}

function removeDecimals(n, amount = 0) {
    return n.toString().replace(/\.\d+/, (x) => {
        if (amount)
            return '.' + Math.round(x.slice(1, 1 + amount))
        return ''
    })
}

function roundToNearestTen(n, boundary = 10) {
    return Math.round(n / boundary) * boundary
}

function roundToLowestTen(n) {
    if (n < 10) {
        return 0
    }

    if (n < 100) {
        return 10
    }

    if (n < 1000) {
        return 100
    }
}

function roundToNearest(n, boundary = 10) {
    return Math.ceil(n / boundary) * boundary
}

function isPrime(n) {
    //if (PRIMES.includes(n)) r
    for (let i = 2, s = Math.sqrt(n); i <= s; i++) {
        if (n % i === 0) return false
    }
    return n > 1
}

function simplifyFraction(a, b) {
    if (!b) [a, b] = a.split('/')

    if (hasDecimal(a)) {
        let factor = Math.pow(10, countDecimalPlaces(a))
        a *= factor
        b *= factor
    }
    if (hasDecimal(b)) {
        let factor = Math.pow(10, countDecimalPlaces(b))
        a *= factor
        b *= factor
    }

    const g = gcd(a, b)
    const p = [a, b].map((x) => x / g).join('/')
    return p
}

function randomlyAddZeroes(n, decimals = 1) {
    let [a, b] = [0, decimals]
    let r = coinflip(0.5)
    if (r > 0.67) return n + '0'.repeat(rng(a, b))
    if (r > 0.33) return '0.' + '0'.repeat(rng(a, b)) + n
    return n
        .toString()
        .replace(/\d\d/, (x) => x[0] + '.' + x[1])
}

function isLinearEquation(s) {
    return test(/^\d*?x.*?\d$|^\d+.*?\d+x$/, s)
}

function isEquation(s) {
    return test(/=/, s)
}

function divisibleBy(a, b) {
    return a % b == 0
}

function isSymbolTag(s) {
    return /^[@#]\S+$/.test(s)
}
function chunkgetter(s) {
    return split(s, /\n\n+/)
}
function splitLinesTwice(s) {
    return chunkgetter(s).map(linegetter)
}

class Calculation {
    constructor() {
        this._symbols = {}
        this.defineOperator('!', this.factorial, 'postfix', 6)
        this.defineOperator('^', Math.pow, 'infix', 5, true)
        this.defineOperator(
            '*',
            this.multiplication,
            'infix',
            4
        )
        this.defineOperator('/', this.division, 'infix', 4)
        this.defineOperator('+', this.last, 'prefix', 3)
        this.defineOperator('-', this.negation, 'prefix', 3)
        this.defineOperator('+', this.addition, 'infix', 2)
        this.defineOperator('-', this.subtraction, 'infix', 2)
        this.defineOperator(',', Array.of, 'infix', 1)
        this.defineOperator('(', this.last, 'prefix')
        this.defineOperator(')', null, 'postfix')
        this.defineOperator('min', Math.min)
        this.defineOperator('sqrt', Math.sqrt)
    }
    // Method allowing to extend an instance with more operators and functions:
    defineOperator(
        symbol,
        f,
        notation = 'func',
        precedence = 0,
        rightToLeft = false
    ) {
        // Store operators keyed by their symbol/name. Some symbols may represent
        // different usages: e.g. "-" can be unary or binary, so they are also
        // keyed by their notation (prefix, infix, postfix, func):
        if (notation === 'func') precedence = 0
        this._symbols[symbol] = Object.assign(
            {},
            this._symbols[symbol],
            {
                [notation]: {
                    symbol,
                    f,
                    notation,
                    precedence,
                    rightToLeft,
                    argCount: 1 + (notation === 'infix'),
                },
                symbol,
                regSymbol:
                    symbol.replace(
                        /[\\^$*+?.()|[\]{}]/g,
                        '\\$&'
                    ) + (/\w$/.test(symbol) ? '\\b' : ''), // add a break if it's a name
            }
        )
    }
    last(...a) {
        return a[a.length - 1]
    }
    negation(a) {
        return -a
    }
    addition(a, b) {
        return a + b
    }
    subtraction(a, b) {
        return a - b
    }
    multiplication(a, b) {
        return a * b
    }
    division(a, b) {
        return a / b
    }
    factorial(a) {
        if (a % 1 || !(+a >= 0)) return NaN
        if (a > 170) return Infinity
        let b = 1
        while (a > 1) b *= a--
        return b
    }

    calculate(expression) {
        const value = this._calculate(expression)
        if (test(/syntax|error/i, value)) {
            return logError(expression)
        }
        return value
    }

    _calculate(expression) {
        let match
        const values = [],
            operators = [this._symbols['('].prefix],
            exec = (_) => {
                let op = operators.pop()
                values.push(
                    op.f(
                        ...[].concat(
                            ...values.splice(-op.argCount)
                        )
                    )
                )
                return op.precedence
            },
            error = (msg) => {
                let notation = match
                    ? match.index
                    : expression.length
                return `${msg} at ${notation}:\n${expression}\n${' '.repeat(
                    notation
                )}^`
            },
            pattern = new RegExp(
                // Pattern for numbers
                '\\d+(?:\\.\\d+)?|' +
                    // ...and patterns for individual operators/function names
                    Object.values(this._symbols)
                        // longer symbols should be listed first
                        .sort(
                            (a, b) =>
                                b.symbol.length -
                                a.symbol.length
                        )
                        .map((val) => val.regSymbol)
                        .join('|') +
                    '|(\\S)',
                'g'
            )
        let afterValue = false
        pattern.lastIndex = 0 // Reset regular expression object
        do {
            match = pattern.exec(expression)
            const [token, bad] = match || [')', undefined],
                notNumber = this._symbols[token],
                notNewValue =
                    notNumber &&
                    !notNumber.prefix &&
                    !notNumber.func,
                notAfterValue =
                    !notNumber ||
                    (!notNumber.postfix && !notNumber.infix)
            // Check for syntax errors:
            if (
                bad ||
                (afterValue ? notAfterValue : notNewValue)
            )
                return error('Syntax error')
            if (afterValue) {
                // We either have an infix or postfix operator (they should be mutually exclusive)
                const curr =
                    notNumber.postfix || notNumber.infix
                do {
                    const prev = operators[operators.length - 1]
                    if (
                        (curr.precedence - prev.precedence ||
                            prev.rightToLeft) > 0
                    )
                        break
                    // Apply previous operator, since it has precedence over current one
                } while (exec()) // Exit loop after executing an opening parenthesis or function
                afterValue = curr.notation === 'postfix'
                if (curr.symbol !== ')') {
                    operators.push(curr)
                    // Postfix always has precedence over any operator that follows after it
                    if (afterValue) exec()
                }
            } else if (notNumber) {
                // prefix operator or function
                operators.push(
                    notNumber.prefix || notNumber.func
                )
                if (notNumber.func) {
                    // Require an opening parenthesis
                    match = pattern.exec(expression)
                    if (!match || match[0] !== '(')
                        return error(
                            'Function needs parentheses'
                        )
                }
            } else {
                // number
                values.push(+token)
                afterValue = true
            }
        } while (match && operators.length)
        return operators.length
            ? error('Missing closing parenthesis')
            : match
            ? error('Too many closing parentheses')
            : values.pop() // All done!
    }
}

function reverseMathString(s) {
    const items = s.split(' ')
    items.reverse()
    return items.join(' ')
}

function mathTruncate(answer, degree) {
    s = answer.toString()
    let match = search(/(^.*?\.0+)(.+)/, s)
    if (match) {
        let [a, b] = match
        return a + b.slice(0, 2)
    } else {
        return isDecimal(answer)
            ? answer.toFixed(2).replace(/0+$/, '')
            : answer
    }
}

function addMultiplicationSigns(s) {
    return s.replace(
        /[abcd\d][abcxyz]/g,
        (x) => x[0] + '*' + x[1]
    )
}

function fixFloatingPoint(number) {
    let flag = false
    function parser(x, offset, original) {
        if (original[offset - 1] != '.') {
            if (x.startsWith('9')) {
                flag = true
            }
        }
        return ''
    }
    let value = Number(
        String(number)
            .replace(/[09]{8,}[\d]+/, parser)
            .replace(/\.$/, '')
    )
    if (flag) value += 0.1
    if (value.toString().length > 8) {
        return mathTruncate(value)
        console.log(value)
        throw 'too long fix  floating point didnt work'
    }
    return value
}

function addZeroes(n, amount) {
    return n * Math.pow(10, amount)
}

function isDecimal(x) {
    return /^-?\d*?\.\d+/.test(x.toString())
}

function combinate(arr, comboLength = 2) {
    const sourceLength = arr.length
    if (comboLength > sourceLength) return []

    const combos = [] // Stores valid combinations as they are generated.

    const makeNextCombos = (
        workingCombo,
        currentIndex,
        remainingCount
    ) => {
        const oneAwayFromComboLength = remainingCount == 1

        // For each element that remaines to be added to the working combination.
        for (
            let sourceIndex = currentIndex;
            sourceIndex < sourceLength;
            sourceIndex++
        ) {
            // Get next (possibly partial) combination.
            const next = [...workingCombo, arr[sourceIndex]]

            if (oneAwayFromComboLength) {
                // Combo of right length found, save it.
                combos.push(next)
            } else {
                // Otherwise go deeper to add more elements to the current partial combination.
                makeNextCombos(
                    next,
                    sourceIndex + 1,
                    remainingCount - 1
                )
            }
        }
    }

    makeNextCombos([], 0, comboLength)
    return combos
}

function permute(arr) {
    const store = []

    function runner(len) {
        if (len === 1) store.push(arr.slice(0))
        for (let i = 0; i < len; i++) {
            runner(len - 1)
            len % 2
                ? ([arr[0], arr[len - 1]] = [
                      arr[len - 1],
                      arr[0],
                  ])
                : ([arr[i], arr[len - 1]] = [
                      arr[len - 1],
                      arr[i],
                  ])
        }
    }

    runner(arr.length)
    return store
}

function distance(x1, y1, x2, y2) {
    if (arguments.length == 2) {
        ;[x2, y2] = y1
        ;[x1, y1] = x1
    }
    let y = x2 - x1
    let x = y2 - y1
    return roundToNiceNumber(Math.sqrt(x * x + y * y))
}

function roundToNiceNumber(n) {
    return hasDecimal(n) ? n.toFixed(2) : n
}

// hohoo

function xxdecimalToFraction(dec) {
    let epsilon = 1e-7
    dec = Number(dec)
    //console.log(dec)
    if (isInteger(dec)) return dec
    let flag = false
    if (dec >= 1) {
        flag = true
        dec /= 100
    }
    var is_neg = dec < 0
    //console.log(Math.abs(-1))

    if (dec < 0) dec *= -1
    //console.log(Math.abs(0.3333)); throw "";
    //console.log(dec)
    var done = false
    var n1 = 0,
        d1 = 1,
        n = 1,
        d = 0,
        n = 0,
        q = dec
    while (!done) {
        if (n++ > 50) {
            console.log('done forced')
            done = true
        }

        var a = parseInt(q)
        //console.log(a)
        var num = n1 + a * n
        var den = d1 + a * d
        //console.log(num, den)
        if (num > 1000 || den > 1000) {
            num = n
            den = d
            break
        }
        var e = q - a
        if (e < epsilon) {
            done = true
        }
        q = 1 / e
        n1 = n
        d1 = d
        n = num
        d = den
        if (Math.abs(num / den - dec) < epsilon || n > 30) {
            done = true
        }
    }
    console.log(n, 'count')

    if (flag) {
        console.log('sup')
        den /= 100
        if (hasDecimal(den)) {
            den *= 100
            num *= 100
            let g = gcd(den, num)
            den /= g
            num /= g
        }
    }
    let p = [is_neg ? -num : num, den]
    console.log(p)
    //return toFraction(p)
}

function hasDecimal(x, n = 0) {
    return test('\\.' + '\\d'.repeat(n), String(x))
    // n is the number of decimal places to match.
}

function gcd(a, b) {
    return !b ? a : gcd(b, a % b)
}

function toFraction(a, b, mode = String) {
    if (arguments.length == 2) {
        if (b == Array) {
            if (isArray(a)) {
                return a
            }
            return split(a, /\//)
        }
    }
    if (isArray(a)) {
        b = a[1]
        a = a[0]
    }
    ;[a, b] = simplifyFraction(a, b)
    if (b == 1) return a
    if (mode == Array) return [a, b]
    if (mode == String) return a + '/' + b
    return '\\frac' + '{' + a + '}' + '{' + b + '}'
}

function simplifyFraction(a, b) {
    if (!b) [a, b] = a.split('/')

    if (hasDecimal(a)) {
        let factor = Math.pow(10, countDecimalPlaces(a))
        a *= factor
        b *= factor
    }
    if (hasDecimal(b)) {
        let factor = Math.pow(10, countDecimalPlaces(b))
        b *= factor
        a *= factor
    }
    let g = gcd(a, b)
    return [a, b].map((x) => x / g).join('/')
}

function countDecimalPlaces(n) {
    return (n.toString().split('.')[1] || '').length
}
const floatingPointRE =
    /(?:.(?:0{5,}|1{5,}|2{5,}|3{5,}|4{5,}|5{5,}|6{5,}|7{5,}|8{5,}|9{5,})(?:\d|e-\d+)$)/g

function xfixFloatingPoint(number) {
    if (len(number) < 5) return number
    return String(number).replace(floatingPointRE, f)
    function f(x, offset, s) {
        let a = x[0]
        let b = Number(x[1])
        if (a == '.') {
            return offset == 2 ? x[1] : x
        }
        if (b >= 5) return Number(a) + 1
        return a
    }
}

const floatingPointREGEX =
    '(?:.(?:' +
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        .map((x) => x + '{' + 5 + ',}')
        .join('|') +
    ')(?:\\d|e-\\d+)$)'
//console.log(floatingPointREGEX)

function normalizeMath(s) {
    s = s.toString().trim()
    return s
}

function isSimpleEquation(s) {
    return true
}

//console.log(toLatex('(3 + 3) * (3 + 4)'))
//console.log(toLatex(zeroDecimalToFraction('0.75*x')))
//console.log(decimalToFraction(0.3333333))

function decimalToFraction(dec, precision = 4) {
    if (/\.\d{1,2}$|[a-z]/.test(dec) && precision != 'force') {
        return dec
    }
    if (precision == 'force') {
        precision = 4
    }

    let epsilon = Math.pow(10, -1 * precision)
    dec = Number(dec)
    //console.log(dec)
    if (isInteger(dec)) return dec
    let flag = false
    if (dec >= 1) {
        flag = true
        dec /= 100
    }
    var is_neg = dec < 0
    dec = Math.abs(dec)
    //console.log(dec)
    var done = false
    var n1 = 0,
        d1 = 1,
        n2 = 1,
        d2 = 0,
        n = 0,
        q = dec
    while (!done) {
        if (n++ > 50) {
            console.log('done forced')
            done = true
        }

        var a = parseInt(q)
        //console.log(a)
        var num = n1 + a * n2
        var den = d1 + a * d2
        //console.log(num, den)
        if (num > 1000 || den > 1000) {
            num = n2
            den = d2
            break
        }
        var e = q - a
        if (e < epsilon) {
            done = true
        }
        q = 1 / e
        n1 = n2
        d1 = d2
        n2 = num
        d2 = den
        if (Math.abs(num / den - dec) < epsilon || n > 30) {
            done = true
        }
    }

    if (flag) {
        den /= 100
        if (hasDecimal(den)) {
            den *= 100
            num *= 100
            let g = gcd(den, num)
            den /= g
            num /= g
        }
    }
    let p = [is_neg ? -num : num, den]
    return p[0] + '/' + p[1]
}

function _nerdSolver(a, b) {
    if (b == null) {
        if (a.includes('$input')) {
            let s = a.replace(/\$input/, 'q')
            return nerdamer(s)
                .solveFor('q')
                .toString()
                .replace(/,.+/, '')
        }
        if (a == '0^0') {
            return 1
        }
        /* get rid of brackets */
        if (!hasLatex(a)) a = a.replace(/[{}]/g, '')

        /* fix starting negatives */
        a = a.replace(/^-\w+(?=\^)/, (x) => parens(x))

        if (test(/= *$/, a)) {
            return nerdEval(a.replace(/= *$/, ''))
        }
        if (isEquation(a)) {
            let solveForVar = solveForVariable(a)
            if (solveForVar != null) return solveForVar
            b = search(/[xyz]/, a)
            const value = orderByPolynomialDegree(
                nerdEval(nerdamer(a).solveFor(b))
            )
            return value
        } else {
            return nerdEval(nerdamer(a))
        }
    }
    if (b.length < 2 && isSimpleEquation(a)) {
        const value = orderByPolynomialDegree(
            nerdEval(nerdamer(a).solveFor(b))
        )
        return b + ' = ' + value
    }
    if (isEquation(b)) {
        return equationSolver(a, b)
    }
}
function nerdConvert(s) {
    if (isString(s) && hasLatex(s)) {
        s = s.replace(/[dc]frac/g, 'frac')
        return nerdamer.convertFromLaTeX(s)
    }
    return nerdamer(s)
}
function solveFor(s, a, validator = isValidNerdamer) {
    let answer = nerdConvert(s).solveFor(a)
    if (isArray(answer)) {
        return smallify(filter(answer.map(String), validator))
    } else {
        return validator(String(answer)) ? answer : null
    }
}
function solveForVariable(s) {
    let variables = getVariables(s, Object)
    let length = len(variables)
    if (length == 2) {
        let [a, b] = lowHigh(variables)
        return solveFor(s, a)
    } else if (length == 1) {
        let a = Object.keys(variables)[0]
        return solveFor(s, a)
    }
}
//console.log(nerdSolver('x/2 + x/4'))
//console.log(isInteger(4))

//console.log(primesFrom(40))

function romanCase(n) {
    var roman = {
        M: 1000,
        CM: 900,
        D: 500,
        CD: 400,
        C: 100,
        XC: 90,
        L: 50,
        XL: 40,
        X: 10,
        IX: 9,
        V: 5,
        IV: 4,
        I: 1,
    }
    var str = ''

    for (var i of Object.keys(roman)) {
        var q = Math.floor(n / roman[i])
        n -= q * roman[i]
        str += i.repeat(q)
    }
    return str
}

function randomNumbers(
    n,
    { min = 1, max = 10, prime = null } = {}
) {
    let base0 = prime
        ? primesFrom(min, max, n)
        : range(min, max)
    if (prime === false) {
        base0 = base0.filter((x) => !isPrime(x))
        if (base0.length < n) {
            base0.push(...range(max + 1, max + n + 1))
        }
    }
    let base = shuffle(base0)
    return base.slice(0, n)
}
//console.log(randomNumbers(20, {prime: true}))

function toLatex(s, styles) {
    return s
    s = fixExpression(s)

    if (!hasLatex(s)) {
        s = nerdamer.convertToLaTeX(s)
    }
    if (styles) {
        s = latexTemplater(s, styles)
    }
    console.log(s)
    return s
}

//console.log(nerdSolver('infinity^0'))
//console.log(toLatex('(3 + 3) * (3 + 4)'))
//console.log(toLatex('infinity^0'))

//console.log(nerdSolver('x^1 * x^2 * x^3 * x^4 * $input = x^100'))
//console.log(nerdSolver('2 + 3 ='))
//console.log(nerdSolver('1000^0'))
//console.log(toLatex('y^(y - y)'))
//s0 = '\\cfrac{\\frac{1}{2}}{1 + \\cfrac{1}{\\frac{2}{3}}}'
//console.log(nerdSolver(s0))
//From 5 choose 3

function numberFromNumber(n) {
    return permute(split(n)).map((x) => Number(x.join('')))
}
//console.log(combinate([1,2,3,4,5], 2))

function calculatePC(a, b, mode = 'C') {
    let template =
        mode == 'C' ? 'a! / ((a - b)! * b!)' : 'a! / (a - b)!'

    let expr = templater(template, { a, b })
    return nerdSolver(expr)
}

function nerdSolveMultipleSteps() {
    var dR = nerdamer('R=L*dR').solveFor('dR')
    var I = nerdamer('dR=c*I^2/A').sub('dR', dR).solveFor('I')
    //You can first start by reducing the first few equations since they are linear and you can solve them as a linear system
    var solutions = nerdamer.solveEquations(
        ['P = I * U', 'DV = R * I', 'DW = DV * I'],
        ['I', 'DW', 'P']
    )
    //the solutions come back as an array arrays in the form of [variable, value]
    //you can see what they look like. In your case all your solutions will be in terns of DV & U since these are the only actual knowns
    //You can see what the solutions look like
    solutions.map(function (x) {
        console.log('-' + x[0] + ' = ' + x[1])
    })
    console.log('------------------ R ----------------')
    var R = nerdamer
        .setEquation(I[0], solutions[0][1])
        .solveFor('R')
    //I will have 3 solutions since it's cubic. You can console.log them below
    R.map(function (x) {
        console.log('R = ' + x.toString())
    })
    /* no ... it simply is not appropriate */
}

//console.log(calculatePC(5, 3))

function splitKatex(s) {
    if (isArray(s)) {
        return s
    }
    if (isNumber(s)) {
        return [s.toString()]
    }
    if (!hasLatex(s)) return [s]
    const regex =
        /(\bif |\.? (?:[a-zA-Z]{2,}(?: |$))+|\$\w+(?:\(.*?\))?)/i
    return split(s, regex).filter(exists)
}

function isMathematical2(s) {
    return /[\^\/=\\\\]/.test(s) && !/\w+ \w+ \w+/.test(s)
}

function isMathematical(s) {
    return /[\^\/]/.test(s) && !/\\|\w+ \w+ \w+/.test(s)
}
function hasLatex(s) {
    return test(/\\\w|\^| [\+-] /, s)
}

function katexBold(s) {
    return `\\bold{${s}}`
}

function katexAttributer(a, b, c) {
    return wrap(`\\${a}{${b}}{${c}}`, '{}')
}

function katexColorer(x, color) {
    return katexAttributer('textcolor', color, x)
}

function colorTheMath(s) {
    let colors
    const items = splitKatex(s).map((item, i, arr) => {
        if (item.startsWith('$input')) {
            let arg = extractArg(item) || nerdSolver(arr[i - 1])
            let color = colors[arg] || 'fakeColor'
            return {
                type: 'input',
                value: {
                    colorIt: color,
                    answer: arg,
                },
            }
        }
        if (hasLatex(item)) {
            if (!colors) {
                colors = getColors(item)
            }
            return {
                type: 'katex',
                value: latexTemplater(item, colors),
            }
        }

        return {
            type: 'prose',
            value: latexTemplater(item, colors),
        }
    })

    return items

    function getColors(s) {
        const numbers = match(/\^(\w+)/g, s)

        const colors = [
            //'#09346d',
            //'#6c7fb4',
            //'#c5d4ff',
            'red',
            'blue',
            'green',
        ]
        //const colors = roygbiv
        return zip(numbers, colors)
    }
}

function math1213(a, b) {
    const base = mathProduct('1' + String(a), '1' + String(b))
    const sum = mathSum(a, b)
    const product = mathProduct(a, b)
    return [base, sum, product]
}

//console.log(splitKatex('x^1 * x^2 * x^3 * x^4 * x^5 = $input'))

function fixExpression(s) {
    /* fix symbols */
    s = dreplace2(s, {
        infinity: '\\infty',
        inf: '\\infty',
        pi: '\\pi',
        tan: '\\tan',
        sin: '\\sin',
        cos: '\\cos',
        ln: '\\ln',
        log: '\\log',
        '*': '\\cdot',
        '*': '\\times',
        //'. ': '.\\medspace ',
        //' = ?': ' \\medspace = \\medspace ?',
    })

    s = s.replace(/\?$/, '?\\medspace')
    s = s.replace(/\^(\(.*?\)|\w{2,})/g, (_, x) => {
        return '^' + wrap(x, '{}')
    })

    /* fix multiple-expressions ... x^2^3 --> (x^2)^3 */
    s = s.replace(/(?:\w\^){2,}\w/, (x) => {
        let items = split(x, /\^/)
        let temp = items[0]
        for (let i = 1; i < items.length; i++) {
            let item = items[i]
            if (i > 1) {
                temp = wrap(temp, '()')
            }
            temp += '^' + item
        }
        return temp
    })
    return s
}
//console.log(fixExpression('100^100 * 100^99 = x^198 * 100^y. x + y = ? $input(101)'))

function fraction(a, b) {
    return `${a}/${b}`
}

function toLatex(s, styles) {
    return s
    s = fixMath(s)
    s = s.replace(/cdot/g, 'times')

    if (!hasLatex(s)) {
        try {
            s = nerdamer.convertToLaTeX(s)
        } catch (e) {}
    }
    if (styles) {
        s = latexTemplater(s, styles)
    }
    return s
}

function toLatexFraction(a, b) {
    return '\\frac' + '{' + a + '}' + '{' + b + '}'
}
//console.log(satMathData)
//console.log(colorTheMath('2^3 * 2^4 = 2^7 because 3 + 4 = $input(7)'))

//s = "toLatex(nerdSolver(toLatex(r-2 /6 = 5)))"
//console.log(eval(quoteTheVeryInside(s)))

function tryval3(s) {
    try {
        return eval(s)
    } catch (e) {
        console.log('rrrrrrrrrrrrrrrrrrrr')
        console.log({
            error: e.stack.toString(),
            input: s,
        })
    }
}

function june24postassessmentangelanswers() {
    const data1 = {
        1: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: 'toLatex(r-2/6 = 5)',
            },
            {
                type: 'prose',
                value: 'is',
            },
            {
                type: 'katex',
                value: 'toLatex(nerdSolver(toLatex(r-2 /6 = 5)))',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        2: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: 'toLatex((5p3i)p(-4p7i))',
            },
            {
                type: 'prose',
                value: 'is',
            },
            {
                type: 'katex',
                value: 'toLatex(nerdSolver(toLatex((5p3i)p(-4p7i))))',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        3: [
            {
                type: 'prose',
                value: ' Not exceeds 100 means 99 is okay, 100 is okay, 101 is not okay. The answer is',
            },
            {
                type: 'katex',
                value: 'toLatex(s + b \\lte 100)',
            },
        ],
        4: [
            {
                type: 'prose',
                value: ' It represents the faster worker because',
            },
            {
                type: 'katex',
                value: 'toLatex(3x>1x)',
            },
            {
                type: 'prose',
                value: '. It represents the fraction of the job done in 1 hour because the entire job is done in 7 hours and',
            },
            {
                type: 'katex',
                value: 'toLatex(7 * 1/7)',
            },
            {
                type: 'prose',
                value: 'is 1.',
            },
        ],
        5: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: 'toLatex((3xe3-13xp4)-(3xe2-4xp5))',
            },
            {
                type: 'prose',
                value: 'is',
            },
            {
                type: 'katex',
                value: 'toLatex(nerdSolver(toLatex((3xe3-13xp4)-(3xe2-4xp5))))',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        6: [
            {
                type: 'prose',
                value: ' Find the zeroes for',
            },
            {
                type: 'katex',
                value: 'toLatex(6xe2-13x-5)',
            },
            {
                type: 'prose',
                value: 'because that will be where the function is undefined. Using the AC-method, we can rewrite',
            },
            {
                type: 'katex',
                value: 'toLatex(6xe2-13x-5)',
            },
            {
                type: 'prose',
                value: 'into',
            },
            {
                type: 'katex',
                value: 'toLatex(6xe2-15xp2x-5)',
            },
            {
                type: 'prose',
                value: ' After factoring, it becomes',
            },
            {
                type: 'katex',
                value: 'toLatex(3x(2x-5)+(2x-5))',
            },
            {
                type: 'prose',
                value: 'which becomes',
            },
            {
                type: 'katex',
                value: 'toLatex((3xp1)(2x-5))',
            },
            {
                type: 'prose',
                value: '. Set them equal to 0 and find',
            },
            {
                type: 'katex',
                value: 'toLatex(x)',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        7: [
            {
                type: 'prose',
                value: ' The x-coordinate of the vertex of a parabola occurs between the roots of the parabola.',
            },
            {
                type: 'katex',
                value: 'toLatex( y=3(x-4)(xp6))',
            },
            {
                type: 'prose',
                value: " Right in between 4 and -6 is 1. This is the x-coordinate we're looking for. The corresponding y-coordinate is -63.",
            },
            {
                type: 'prose',
                value: ' So now, we plug 1 into each equation and if it equals -63 then we will have found the equation.',
            },
        ],
        8: [
            {
                type: 'prose',
                value: ' if the diagonal is 12, each side of the square is',
            },
            {
                type: 'katex',
                value: 'toLatex(12/sqrt2x)',
            },
            {
                type: 'prose',
                value: '. The frame pads it by 2 inches on each side so to each side, we should add 2 (left side) and 2 (right side). The total area is ',
            },
            {
                type: 'katex',
                value: 'toLatex((12/sqrt+4)e2)',
            },
            {
                type: 'prose',
                value: 'The inner area is',
            },
            {
                type: 'katex',
                value: 'toLatex((12/sqrt)e2)',
            },
            {
                type: 'prose',
                value: ' the area of the frame is the total area - the inner area',
            },
            {
                type: 'prose',
                value: ' Subtracting, we get',
            },
            {
                type: 'katex',
                value: 'toLatex(16p48sq2)',
            },
        ],
        9: [
            {
                type: 'prose',
                value: ' A line parallel to',
            },
            {
                type: 'katex',
                value: 'toLatex(y=3x/2-7/4)',
            },
            {
                type: 'prose',
                value: 'is any line that has a slope of',
            },
            {
                type: 'katex',
                value: 'toLatex(3/2. -6x + 4y)',
            },
            {
                type: 'prose',
                value: 'has a slope of',
            },
            {
                type: 'katex',
                value: 'toLatex(3/2.)',
            },
        ],
        10: [
            {
                type: 'prose',
                value: ' The intersection of',
            },
            {
                type: 'katex',
                value: 'toLatex(m=3.65p0.35x)',
            },
            {
                type: 'prose',
                value: 'and',
            },
            {
                type: 'katex',
                value: 'toLatex(n=4.25p0.15x)',
            },
            {
                type: 'prose',
                value: 'can be found by setting the 2 equations equal to each other. After combining like terms,',
            },
            {
                type: 'katex',
                value: 'toLatex(m=0.2)',
            },
            {
                type: 'prose',
                value: 'and b equals 0.6.',
            },
            {
                type: 'katex',
                value: 'toLatex(0.6/0.2 = 3)',
            },
        ],
        11: [
            {
                type: 'prose',
                value: ' Normalize the expression by multiplying the numerator and denominator by',
            },
            {
                type: 'katex',
                value: 'toLatex(2pi)',
            },
            {
                type: 'prose',
                value: '. The answer is',
            },
            {
                type: 'katex',
                value: 'toLatex(-3/5)',
            },
        ],
        12: [
            {
                type: 'prose',
                value: ' The graph cannot be A because the yint is positive. Cannot be B because B has a negative slope. Cannot be D because it is a degree 2 polynomial and we have a degree 3 polynomial.',
            },
            {
                type: 'prose',
                value: '(Alsoit doesnt fit the shape of a cubic graph.)',
            },
        ],
        13: [
            {
                type: 'prose',
                value: ' Plugging in a x value of 6 yields 138 which means b has to be 3. Solving it again with a b-value of 3, the answer is 78.',
            },
        ],
        14: [
            {
                type: 'prose',
                value: ' 350 male students and 250 are science. So that means 100 are arts. There are a total of 200 arts. So left over is 100 female art students.',
            },
        ],
        15: [
            {
                type: 'prose',
                value: ' Solve for y by moving 11, 4, ',
            },
            {
                type: 'katex',
                value: 'toLatex(1.6x^2)',
            },
            {
                type: 'prose',
                value: ', and 2.6x',
            },
            {
                type: 'prose',
                value: 'to the other side.',
            },
        ],
        16: [
            {
                type: 'prose',
                value: ' The rate of decrease from 1950 to 2000 is',
            },
            {
                type: 'katex',
                value: 'toLatex((1/2)tx=1/3)',
            },
            {
                type: 'prose',
                value: 'where x represents the rate.',
            },
            {
                type: 'katex',
                value: 'toLatex(X=1/6)',
            },
            {
                type: 'prose',
                value: '. Therefore in 2050, the fraction should be',
            },
            {
                type: 'katex',
                value: 'toLatex(1/3*1/6=1/18.)',
            },
        ],
        17: [
            {
                type: 'prose',
                value: ' 75 base price for each month for 4 months is 300.',
            },
            {
                type: 'katex',
                value: 'toLatex(850-300=550. 550/10 = 55)',
            },
        ],
        18: [
            {
                type: 'prose',
                value: ' the 2 shorter sides of a triangle must be longer than the third side. The missing side has to be bigger than 4 and less than 18. The smallest possible is there 5, the largest possible is 17.',
            },
            {
                type: 'katex',
                value: 'toLatex(5t17=85)',
            },
        ],
        19: [
            {
                type: 'prose',
                value: ' The missing side AB is 80 because',
            },
            {
                type: 'katex',
                value: 'toLatex(60~80~100)',
            },
            {
                type: 'prose',
                value: 'corresponds to',
            },
            {
                type: 'katex',
                value: 'toLatex(6~8~10)',
            },
            {
                type: 'prose',
                value: 'corresponds to a',
            },
            {
                type: 'katex',
                value: 'toLatex(3~4~5)',
            },
            {
                type: 'prose',
                value: 'triangle.',
            },
            {
                type: 'prose',
                value: 'angle D corresponds to angle A.',
            },
            {
                type: 'katex',
                value: 'toLatex( cosA=60/100=3/5)',
            },
            {
                type: 'katex',
                value: 'toLatex( cosD=3/5)',
            },
        ],
        20: [
            {
                type: 'katex',
                value: 'toLatex(l = 5 *c- 6 arr 0.3c + 0.7 * l = 7.2)',
            },
            {
                type: 'prose',
                value: ' Solve for C by plugging the first equation into the second equation.',
            },
            {
                type: 'katex',
                value: 'toLatex(0.3 * c + 0.7(5*c-6) = 7.2)',
            },
            {
                type: 'prose',
                value: ' Rearranging,',
            },
            {
                type: 'katex',
                value: 'toLatex(0.3* c + 3.5 * c = 7.2-4.2)',
            },
            {
                type: 'prose',
                value: ' Combining like terms and solving for cucumbers, we get 3',
            },
        ],
    }

    let answers = [
        'C',
        'A',
        'C',
        'D',
        'A',
        'C',
        'C',
        'B',
        'B',
        'B',
        'C',
        'C',
        'C',
        'C',
        'B',
        '1/18',
        '55 days',
        '85',
        '3/5',
        '3',
    ]
    function h(data) {
        return map(data, g)
    }
    function g(data) {
        return data.map((x, i) => {
            if (x.type == 'katex') {
                const value = g1(x.value)
                return {
                    type: x.type,
                    value,
                }
            }
            return x
        })
    }

    function g1(value, depth, key) {
        return tryval3(quoteTheVeryInside(value))
    }
    //console.log(h(data1))
    return [h(data1), answers]
}
//write('temp4.json', june24postassessmentangelanswers())

const data123 = [
    {
        1: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: '\\frac{r-2}{6} = 5',
            },
            {
                type: 'prose',
                value: 'is',
            },
            {
                type: 'katex',
                value: '32',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        2: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: '(5+3i)+(-4+7i)',
            },
            {
                type: 'prose',
                value: 'is',
            },
            {
                type: 'katex',
                value: '1+10\\cdot i',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        3: [
            {
                type: 'prose',
                value: ' Not exceeds 100 means 99 is okay, 100 is okay, 101 is not okay. The answer is',
            },
            {
                type: 'katex',
                value: 's + b \\leq 100',
            },
        ],
        4: [
            {
                type: 'prose',
                value: ' It represents the faster worker because',
            },
            {
                type: 'katex',
                value: '3x>1x',
            },
            {
                type: 'prose',
                value: '. It represents the fraction of the job done in 1 hour because the entire job is done in 7 hours and',
            },
            {
                type: 'katex',
                value: '7 \\cdot \\frac{1}{7}',
            },
            {
                type: 'prose',
                value: 'is 1.',
            },
        ],
        5: [
            {
                type: 'prose',
                value: 'The value of',
            },
            {
                type: 'katex',
                value: '(3x^{3}-13x+4)-(3x^{2}-4x+5)',
            },
            {
                type: 'prose',
                value: 'is found by combining like terms.',
            },
            {
                type: 'katex',
                value: '3x^{3} - 9x -1',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        6: [
            {
                type: 'prose',
                value: ' Find the zeroes for',
            },
            {
                type: 'katex',
                value: '6x^{2}-13x-5',
            },
            {
                type: 'prose',
                value: 'because that will be where the function is undefined. Using the AC-method, we can rewrite',
            },
            {
                type: 'katex',
                value: '6x^{2}-13x-5',
            },
            {
                type: 'prose',
                value: 'into',
            },
            {
                type: 'katex',
                value: '6x^{2}-15x+2x-5',
            },
            {
                type: 'prose',
                value: ' After factoring, it becomes',
            },
            {
                type: 'katex',
                value: '3x(2x-5)+(2x-5)',
            },
            {
                type: 'prose',
                value: 'which becomes',
            },
            {
                type: 'katex',
                value: '(3x+1)(2x-5)',
            },
            {
                type: 'prose',
                value: '. Set them equal to 0 and find',
            },
            {
                type: 'katex',
                value: 'x',
            },
            {
                type: 'prose',
                value: '.',
            },
        ],
        7: [
            {
                type: 'prose',
                value: ' The x-coordinate of the vertex of a parabola occurs between the roots of the parabola.',
            },
            {
                type: 'katex',
                value: 'y = 3 \\left(x - 4\\right) \\left(x + 6\\right)',
            },
            {
                type: 'prose',
                value: " Right in between 4 and -6 is 1. This is the x-coordinate we're looking for. The corresponding y-coordinate is -63.",
            },
            {
                type: 'prose',
                value: ' So now, we plug 1 into each equation and if it equals -63 then we will have found the equation.',
            },
        ],
        8: [
            {
                type: 'prose',
                value: ' If the diagonal is 12, each side of the square is',
            },
            {
                type: 'katex',
                value: '12/\\sqrt{2x}',
            },
            {
                type: 'prose',
                value: '. The frame pads it by 2 inches on each side so to each side, we should add 2 (left side) and 2 (right side). The total area is ',
            },
            {
                type: 'katex',
                value: '(\\frac{12}{\\sqrt{2}}+4)^{2}',
            },
            {
                type: 'prose',
                value: 'The inner area is',
            },
            {
                type: 'katex',
                value: '(12/\\sqrt{2})^{2}',
            },
            {
                type: 'prose',
                value: ' the area of the frame is the total area - the inner area',
            },
            {
                type: 'prose',
                value: ' Subtracting, we get',
            },
            {
                type: 'katex',
                value: '16+48\\sqrt{2}',
            },
        ],
        9: [
            {
                type: 'prose',
                value: ' A line parallel to',
            },
            {
                type: 'katex',
                value: 'y=\\frac{3x}{2}-\\frac{7}{4}',
            },
            {
                type: 'prose',
                value: 'is any line that has a slope of',
            },
            {
                type: 'katex',
                value: '\\frac{3}{2}. -6x + 4y',
            },
            {
                type: 'prose',
                value: 'has a slope of',
            },
            {
                type: 'katex',
                value: '\\frac{3}{2}.',
            },
        ],
        10: [
            {
                type: 'prose',
                value: ' The intersection of',
            },
            {
                type: 'katex',
                value: 'm=3.65+0.35x',
            },
            {
                type: 'prose',
                value: 'and',
            },
            {
                type: 'katex',
                value: 'n=4.25+0.15x',
            },
            {
                type: 'prose',
                value: 'can be found by setting the 2 equations equal to each other. After combining like terms,',
            },
            {
                type: 'katex',
                value: 'm = \\frac{1}{5}',
            },
            {
                type: 'prose',
                value: 'and b equals ',
            },
            {
                type: 'katex',
                value: '0.6',
            },
            {
                type: 'prose',
                value: '. ',
            },

            {
                type: 'katex',
                value: '{0.6}{0.2} = 3',
            },
        ],
        11: [
            {
                type: 'prose',
                value: ' Normalize the expression by multiplying the numerator and denominator by',
            },
            {
                type: 'katex',
                value: '2 + i',
            },
            {
                type: 'prose',
                value: '. The answer is',
            },
            {
                type: 'katex',
                value: '-\\frac{3}{5}',
            },
        ],
        12: [
            {
                type: 'prose',
                value: ' The graph cannot be A because the yint is positive. Cannot be B because B has a negative slope. Cannot be D because it is a degree 2 polynomial and we have a degree 3 polynomial.',
            },
            {
                type: 'prose',
                value: '(Alsoit doesnt fit the shape of a cubic graph.)',
            },
        ],
        13: [
            {
                type: 'prose',
                value: ' Plugging in a x value of 6 yields 138 which means b has to be 3. Solving it again with a b-value of 3, the answer is 78.',
            },
        ],
        14: [
            {
                type: 'prose',
                value: ' 350 male students and 250 are science. So that means 100 are arts. There are a total of 200 arts. So left over is 100 female art students.',
            },
        ],
        15: [
            {
                type: 'prose',
                value: ' Solve for y by moving 11, 4, ',
            },
            {
                type: 'katex',
                value: '1.6x^2',
            },
            {
                type: 'prose',
                value: ', and 2.6x',
            },
            {
                type: 'prose',
                value: 'to the other side.',
            },
        ],
        16: [
            {
                type: 'prose',
                value: ' The rate of decrease from 1950 to 2000 is',
            },
            {
                type: 'katex',
                value: '(\\frac{1}{2})x = \\frac{1}{3}',
            },
            {
                type: 'prose',
                value: 'where x represents the rate.',
            },
            {
                type: 'katex',
                value: 'x=\\frac{1}{6}',
            },
            {
                type: 'prose',
                value: '. Therefore in 2050, the fraction should be',
            },
            {
                type: 'katex',
                value: '\\frac{1}{3} \\cdot \\frac{1}{6}=\\frac{1}{18}.',
            },
        ],
        17: [
            {
                type: 'prose',
                value: ' 75 base price for each month for 4 months is 300.',
            },
            {
                type: 'katex',
                value: '850-300=550. \\frac{550}{10} = 55',
            },
        ],
        18: [
            {
                type: 'prose',
                value: ' the 2 shorter sides of a triangle must be longer than the third side. The missing side has to be bigger than 4 and less than 18. The smallest possible is there 5, the largest possible is 17.',
            },
            {
                type: 'katex',
                value: '5 \\cdot 17=85',
            },
        ],
        19: [
            {
                type: 'prose',
                value: ' The missing side AB is 80 because',
            },
            {
                type: 'katex',
                value: '60~80~100',
            },
            {
                type: 'prose',
                value: 'corresponds to',
            },
            {
                type: 'katex',
                value: '6~8~10',
            },
            {
                type: 'prose',
                value: 'corresponds to a',
            },
            {
                type: 'katex',
                value: '3~4~5',
            },
            {
                type: 'prose',
                value: 'triangle.',
            },
            {
                type: 'prose',
                value: 'angle D corresponds to angle A.',
            },
            {
                type: 'katex',
                value: 'cosA=\\frac{60}{100}=\\frac{3}{5}',
            },
            {
                type: 'katex',
                value: '. cosD=\\frac{3}{5}',
            },
        ],
        20: [
            {
                type: 'katex',
                value: 'l = 5 \\cdot c- 6 \\rightarrow 0.3c + 0.7 \\cdot l = 7.2',
            },
            {
                type: 'prose',
                value: ' Solve for C by plugging the first equation into the second equation.',
            },
            {
                type: 'katex',
                value: '0.3 \\cdot c + 0.7(5\\cdot c - 6) = 7.2',
            },
            {
                type: 'prose',
                value: ' Rearranging,',
            },
            {
                type: 'katex',
                value: '0.3\\cdot c + 3.5 \\cdot c = 7.2-4.2',
            },
            {
                type: 'prose',
                value: ' Combining like terms and solving for cucumbers, we get an answer of 3.',
            },
        ],
    },
    [
        'C',
        'A',
        'C',
        'D',
        'A',
        'C',
        'C',
        'B',
        'B',
        'B',
        'C',
        'C',
        'C',
        'C',
        'B',
        '1/18',
        '55 days',
        '85',
        '3/5',
        '3',
    ],
]

function numberRangeFromDash(s) {
    if (isArray(s)) {
        return s
    }
    if (!isString(s)) {
        debug()
        return [1, 2, 3]
    }
    let items = s.split('-')
    if (items.length == 1) {
        return items.map(toNumber)
    }

    if (items.length == 2) {
        let [a, b] = items.map(toNumber)
        let store = []
        let increment = roundToNearestZero(a)
        for (let i = a; i <= b; i += increment) {
            store.push(i)
        }
        return store
    }
}
function roundToFour(n) {
    return n - (n % 4)
}

function roundToNearestZero(n) {
    if (n < 5) return 1
    if (n < 50) return 10
    if (n < 500) return 100
    if (n < 1500) return 1000
    if (n < 15000) return 10000
}
//console.log(numberRangeFromDash('450-850'))

function cyclicalf(limit) {
    return function lambda(n) {
        if (n < 0) return limit - n
        return n > limit ? n - limit : n
    }
}
const cyclical360 = cyclicalf(360)

function threeAngles(n, delta = 30, more = 180) {
    return [n, n + more - delta, n + more + delta]
        .map(cyclical360)
        .sort((a, b) => a - b)
}


class TemplateMath {
    constructor() {
        this.dict = {}
        const regex = /^(\w+) *= *(\[.*?\]|\w+)/
        this.eater = new Eater(regex)
    }
    run(s) {
        const [text, store] = this.eater.run(s)
        const getSeeds = (b) =>
            /^\[/.test(b) ? eval(b) : [Number(b)]
        const dict = reduce(store, (k, v) => [k, getSeeds(v)])
        const matrix = new Matrix(store)
        const col1 = matrix.getColumn(0)
        const col2 = matrix.getColumn(1).map(getSeeds)
        const combos = cartesianProduct(col2)
        const dicts = combos.map((x) => zip(col1, x))
        const results = dicts.map((dict) =>
            this.parse(dreplace(text, dict, '\\$($1)\\b'))
        )
        console.log(results)
    }
    parse(s, seed) {
        const regex = /\$(\w+(?:\(.*?\)(?! =|\)))?)/g
        s = s.replace(regex, (_, s) => this.runner(s))
        s = s.replace(/  /g, ' ')
        return s
    }
    runner(s) {
        if (s.endsWith(')')) {
            let [name, args] = search(/(\w+)\((.*?)\)/, s)
            args = args.split(/, */).map(toArgument)

            if (!this[name]) {
                console.log(
                    'creating function from global scope:',
                    name
                )
                this[name] = eval(name).bind(this)
            }
            return this[name](...args)
            //
            //return eval(name).call(this, ...args)
        } else {
            return this[s]
        }
    }
}

function sumDigits(n) {
    const items = split(n)
    const answer = sum(items)
    return answer
    /* $items.join(' + ') = $answer */
}

function divisibleByThree(n) {
    const divisible = n % 3 == 0
    return divisible
}

const mathSum = mathFactory('+')
const mathProduct = mathFactory('*')

function mathEval(s) {
    s = s.replace(/ = $/, '')
    s = s.replace(/\\(?:cdot|times)/, '*')
    return eval(s)
}
function mathFactory(operator, colors) {
    if (operator == '*') {
        operator = '\\cdot'
        operator = '\\times'
    }
    let equalSign = ' = '

    return function lambda(a, b) {
        if (isArray(a)) {
            b = a[1]
            a = a[0]
        }
        const question = `${a} ${operator} ${b}${equalSign}`
        const answer = mathEval(question)
        const expression = `${addEqualSign(question)}${answer}`
        return { question, answer, expression }
    }
}

function generateNumbers({
    start = 1,
    end = 9,
    condition = identity,
    amount = 0,
} = {}) {
    condition = fastFunction(condition)
    const store = []
    for (let i = start; i <= end; i++) {
        for (let j = i + 1; j <= end; j++) {
            if (condition(i, j)) {
                coinflip()
                    ? store.push([i, j])
                    : store.push([j, i])
            }
        }
    }
    //console.log(store); throw '';

    if (false) {
        store = shuffle(store)
    }
    if (amount) {
        return store.slice(0, amount)
    }
    return store
}

//if (typeof window  == 'undefined') nerdamer  = require('nerdamer/all.min')
// generates
//console.log(math1213(3,4))

function round(n, decimals = 3) {
    return parseFloat(n.toFixed(decimals))
}
function latexed(s, ref) {
    return toLatex(templater(s, ref))
}
function f78([a, b]) {
    if (!seen) seen = new Set()
    const value = round(a / b)
    if (seen.has(value)) {
        return
    }
    seen.add(value)
    //return longdiv(a,b)
    return latexed('a/b', { a, b })
}
function longdiv(a, b) {
    return `\\begin{array}{l}
\\phantom{${a}\\medspace\\medspace}\\
x-3\\overline{\\smash{\\bigl)}${b}}\\
\\end{array}`
}

//const f1 = compose(toLatex, (x) => x.join('*'))
//mathQuestions = shuffle(map(generateNumbers({start:11, end: 19}), f1))

const mathData = {
    title: 'Fraction to Decimal using Long Division',
    prose: 'Please show your work in your math notebook. Sometimes, you will be able to do it in your head. If that is the case, you do not need to show any work for those questions.',
    prose: 'Write an equivalent fraction for each fraction. Dont use the same number twice. For example if you multiply fraction 1 by 3, for other fractions, you will need to choose a different number.',
    prose: 'Turn each fraction into a decimal. Keep doing the divison process until the decimal starts to repeat.',
    //mathQuestions,
    name: '12x13',
}
//console.log(mathData)

function porkData(student) {
    return toJSON(new BaseHomeworkPacket(student))
}

class BaseHomeworkPacket {
    toJSON() {
        let f = (x) => x[0]
        let [a, b] = partition(
            this.values,
            (x) => x[0] >= 0
        ).map((x) => sorted(x, f).map((x) => x[1]))

        return merge(a, this.store, b)
        return this.store
    }
    constructor(studentName) {
        this.store = []
        this.values = []

        this.studentName = studentName
        this.$name = studentName
        this.$date = datePhrase()

        this.handlerRef = {
            generateCoverPage: {
                index: 0,
            },

            generateLetter: {
                index: 1,
            },

            generateTableOfContents: {
                index: 1,
            },

            generateCatPicture: {
                index: 1,
            },
        }
    }
    get $greeting() {
        return greeting(this.$name)
    }
    handler(key, ...args) {
        let value = this[key](...args)
        if (isString(value)) {
            value = value.replace(/\$\w+/, (x) => this[x])
            value = prosePug(value)
            value = {
                tag: 'div',
                props: {
                    staticClass: 'inner-html',
                    domProps: {
                        innerHTML: value,
                    },
                },
            }
        }
        let ref = this.handlerRef[key]
        if (hasValue(ref.index)) {
            this.values.push([ref.index, value])
        } else {
            this.store.push(value)
        }
    }
    generateCoverPage() {
        /* todo */
        return `
            Homework Packet
            $date
            $tableOfContents
            $name
        `
    }
    generateLetter() {
        return `
            $greeting
            $body
        `
        /* the body could be absolutely anything */
    }
    generateCatPicture() {
        return {
            layout: '',
            children: [''],
        }
    }
    generateTableOfContents() {}
    generateAssignment(s) {}

    generateQuestions() {}
    build() {}
}

function addSpacesToEnd(s) {
    if (s) return s + ' '
    return ''
}

// 07-14-2022 series and template parsers
// 07-15-2022 solverMoreThan
function percentToNumber(a) {
    if (test(/%$/, a)) {
        return Number(a.slice(0, -1) / 100)
    }
    return Number(a)
}
function solverMoreThanLessThan(s) {
    s = del('is eq', s)
    let r = R0714('$number $comparison $number$')
    function f(_, a, b, c) {
        //console.log([a, b, c])
        a = percentToNumber(a)
        c = percentToNumber(c)
        //let p = a + c
        let p = 0
        //console.log(r)
        //console.log({a, b, c, p})
        switch (b) {
            case 'more than':
                return c + a
            case 'less than':
                return c - a
            case 'less':
                return c - a
            case 'of':
            case 'times of':
                return p
            case 'times':
                return a * c
            default:
                console.log(b, 'hiiiidefa')
        }
    }
    while (true) {
        breaker(10)
        s = s.replace(r, compose(fixFloatingPoint, f))
        console.log(s)
        if (isNumber(s)) return s
    }
}

s = '10% more than 10% less than 10% more than 10 is equal to'
s =
    '10% more than 4 times 3 less 10% less than 10% more than 10 is equal to'
//console.log(seriesParser(s))
//console.log(solverMoreThanLessThan(s))

function generatorMoreThanLessThan(n) {
    function atom() {
        return rng()
    }
    function op() {
        const operators = [
            'less than',
            'more than',
            'less',
            'times',
        ]
        return randomPick(operators)
    }
    let s = ''
    for (let i = 0; i < n; i++) {
        s += atom() + ' ' + op() + ' '
    }
    s += atom()
    return s
}

function getAnswerFn(s) {
    return solverMoreThanLessThan
}
function generateAnswerChoices(s) {
    let answerFn = getAnswerFn(s)
    s = del('equals', s)
    let answer = answerFn(s)
    return answer
}

s = '10% more than 10% less than 10% more than 10 equals'
//10% of 10% of 10% of 10 equals
//console.log(generateAnswerChoices(s))

//console.log(solverMoreThanLessThan('50% more than 25% more than 12'))

/* Something that is cheap.
 * Is often something without quality.
 * Why does it matter?
 * */

function buildTree(numNodes, options = {}) {
    if (numNodes > 3) {
        options.wrng = { '+': 0.6, '-': 0.3, '*': 0.1 }
    } else {
        options.wrng = {
            '+': 0.6,
            '-': 0.2,
            '*': 0.2,
        }
    }
    if (numNodes === 1) {
        return options.getValue ? options.getValue() : rng()
    }

    var [modeA, modeB] = coinflip()
        ? ['floor', 'ceil']
        : ['ceil', 'floor']

    var numLeft = Math[modeA](numNodes / 2)
    var leftSubTree = buildTree(numLeft, options)
    var numRight = Math[modeB](numNodes / 2)
    var rightSubTree = buildTree(numRight, options)
    var tree = new TreeNode(leftSubTree, rightSubTree, options)
    return options.string ? tree.toString() : tree
}

function randomOperator(x) {
    var m = rng(0, x.length)
    var operators = ['*', '-', '+', '+', '+']
    return randomPick(operators)
}

class TreeNode {
    constructor(left, right, options) {
        this.left = left
        this.right = right
        this.depth = 0
        this.wrng = rngf(options.wrng)
        this.options = options || {}
        if (isObject(left)) {
            this.depth += 1 + left.depth
        }

        if (isObject(right)) {
            this.depth += 1 + right.depth
        }
    }
    toString() {
        return joinString(
            this.left,
            this.operator(),
            this.right
        )
    }

    operator() {
        let prefix = ''
        if (
            this.options.times &&
            coinflip(this.options.times)
        ) {
            prefix = rng(this.options.range) + ' times'
        } else if (
            this.options.fractions &&
            coinflip(this.options.times)
        ) {
            prefix = coinflip()
                ? fractionWord(randomFraction()) + ' of'
                : randomPick(COMMON_FRACTIONS) + ' of'
        } else if (this.options.fractions) {
            console.log('hi fractions')
        }

        return join(this.op, prefix, ' ')
    }

    get op() {
        if (this.options.moreThan) {
            return coinflip() ? 'more than' : 'less than'
        }

        if (this.options.moreThan) {
        }

        return this.wrng()
        /* returns the operators */
    }
}

function fractionWord(s) {
    const denominators = [
        null,
        null,
        'half',
        'third',
        'fourth',
        'fifth',
        'sixth',
        'seventh',
        'eighth',
        'ninth',
        'tenth',
    ]
    const numerators = [
        null,
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
    ]
    let [a, b] = s.split('/').map(Number)
    return numerators[a] + '-' + pluralize(denominators[b])
}
function randomFraction(m) {
    if (m == String) {
        return randomPick(COMMON_FRACTIONS)
    }
    return randomPick(COMMON_FRACTIONS)
}

function moreThanLessThanGenerator({
    terms = 2,
    equality = 0,
    range = [1, 9],
    times = 0,
    fractions = 0,
    operations = 0,
    getValue = null,
} = {}) {
    function runner() {
        return buildTree(terms, {
            range,
            fractions,
            times,
            operations,
            moreThan: 1,
            getValue,
        }).toString()
    }

    return equality
        ? infuseX(join(runner(), 'is', runner(), ' '))
        : runner()
}
function infuseX(s) {
    let n = randomPick(getNumbers(s))
    return s.replace(RegExp(boundary(n)), 'x')
}
//console.log(moreThanLessThanGenerator(3))

function countBy(increment, times, template) {
    return range(times).map((x) => {
        let val = x * increment
        return template ? [val, template.replace(/\d/, x)] : val
    })
}

function percentChange(a, b) {
    return mathTemplater(
        `
        $solve((b-a)/a). 
        Turn a decimal into a percentage by multiplying by 100 and adding a percent sign.
        $ans --> $eval(toPercent)
        $ans is $cond(isPositive, 'positive', 'negative') which means a $cond(percent increase, percent decrease).
        Final answer: $eval.
    `,
        { a, b }
    )
}

const MathProblemsList = [
    {
        title: 'Mental Math Percent Calculations',
        notes: 'Watch how Mr. Mario does the calculations in his youtube video. It feels so easy and smooth. Try to incorporate that type of smoothness into the way you perform math.',
        key: 'mmpc1',
        youtube: 'https://www.youtube.com/watch?v=pFdWnl5RAPE',
        question: '$a% of $b',
        fn: (a, b) => fixFloatingPoint((a * b) / 100),
        levels: {
            0: {
                range: [
                    [1, 10],
                    [10, 20],
                ],
                amount: 3,
            },
            1: {
                range: [
                    [1, 10],
                    [10, 40],
                ],
                amount: 1,
            },
            2: {
                range: [
                    {
                        min: 6,
                        max: 15,
                        prime: 1,
                    },
                    {
                        min: 6,
                        max: 21,
                        odd: true,
                    },
                ],
                amount: 1,
            },
        },
        skip: 1,
    },

    {
        title: 'Percent Increase and Decrease',
        youtube: 'https://www.youtube.com/watch?v=9g1iW_sZwMI',
        notes: 'Often, you will have to multiply decimals when doing percent questions. A useful strategy for multiplying decimals is to pretend the decimals arent even there. Afterwards, count up the decimals, and shift your answer left, by that many decimal places.',
        questions: {
            '$a% more than $b': '(100 + a) * b / 100',
            '$a% less than $b': '(100 - a) * b / 100',
        },
        levels: {
            0: { min: 10, max: 20 },
            1: { min: 2, max: 100 },
            2: { min: 20, max: 1000 },
        },
        extensions: ['multiplyingDecimals'],
    },
    {
        title: 'Finding percent change',
        fn: (a, b) => toPercent((b - a) / a),
        levels: {
            0: { min: 10, max: 20 },
            1: { min: 2, max: 100 },
            2: { min: 20, max: 1000 },
        },
        requirements: {
            len: -7,
            unEqual: 1,
        },
        answer: 'percentChange',
        question: 'Find the percent change from $a to $b.',
        youtube: 'https://www.youtube.com/watch?v=v_wqykVJ0js',
    },
]

function mathfoo() {
    let list = MathProblemsList
    //.filter((x) => !x.skip)
    return map(list, (x) => {
        const data = {}
        data.questions = foo1(x, null, 1)
        data.title = x.title
        data.youtube = x.youtube
        if (x.notes) data.notes = toArray(x.notes)
        return data
    })
}
function foo1(ref, levels, amount = 5) {
    const store = []
    const watcher = new Watcher(String)
    const n = countParameters(ref.fn) || 2

    assignFresh(ref, {
        requirements: {
            len: -5,
            unEqual: 1,
        },
    })

    function getValue(args, ref) {
        let req = ref.requirements

        if (req.unEqual && args[0] == args[1]) {
            return
        }
        if (!watcher.isFresh(args)) {
            return
        }

        let value = ref.fn(...args)

        if (isNull(value)) {
            return
        }

        if (req.len) {
            if (req.len > 0 && len(value) < req.len) {
                return
            }

            if (req.len < 0 && len(value) > -1 * req.len) {
                return
            }
        }

        if (req.odd && !isOdd(value)) {
            return
        }

        return value
    }

    for (let [k, v] of Object.entries(levels || ref.levels)) {
        let count = 0
        let errorCount = 0
        while (count < (v.amount || amount)) {
            if (errorCount > 10) {
                throw 'errc'
            }

            let args = v.range
                ? v.range.map((x) => {
                      return isArray(x)
                          ? rng(...x)
                          : rng(x.min, x.max)
                  })
                : range(n, numbergen)

            if (ref.questions) {
                let [q, a] = randomPick(
                    Object.entries(ref.questions)
                )
                ref.question = q
                ref.fn = bringToLife(a)
            }
            let value = getValue(args, ref)
            if (isNull(value)) {
                errorCount += 1
            } else {
                count++
                let question = isString(ref.question)
                    ? mathTemplater(ref.question, args)
                    : null

                let explanation = ref.answer
                    ? evalCall(ref.answer, ...args)
                    : null

                let questionPayload = {
                    question,
                    explanation,
                    answer: value,
                    show: false,
                }
                store.push(questionPayload)
            }
        }
    }
    return store
}

function percentChangeGraph(a, b) {}

function evalCall(name, ...args) {
    if (isFunction(name)) {
        return name(...args)
    }
    let expr = stringcall(name, ...args)
    return eval(expr)
}

function numbergen({
    min = 1,
    max = 10,
    odd = 0,
    even = 0,
    prime = 0,
    amount = 1,
} = {}) {
    if (amount > 1) {
        return new Numbergen().generate(amount, [min, max])
    }
    let n = rng(min, max)
    if ((odd && !isOdd(n)) || (even && !isEven(n))) {
        n++
    }
    if (prime) {
        while (!isPrime(n)) {
            n += 1
        }
    }
    return n
}
//let nextId = incrementf('id-1')
//console.log(mathfoo())

function katexVertical(numbers, operator, n) {
    if (!operator) operator = '+'
    if (!n) n = 1
    let spaces = '\\space '.repeat(n)
    let opSpaces = ' \\space '.repeat(n * 2.5)

    if (numbers.some(hasDecimal)) {
        return katexVerticalAlign(numbers, operator)
    }
    const ref = {
        '*': '\\times',
    }
    if (operator) operator = ref[operator] || operator
    edit(numbers, -1, (x) => operator + opSpaces + x)
    let stuff = numbers.join(' \\\\ ')
    stuff = stuff.replace(/\d/g, '$&' + spaces)
    return `\\begin{array}{r} ${stuff} \\\\ \\hline \\end{array}`
}

s = `

title
    questions
    left
    answers
`

const sample = {
    name: 'diego',
    age: 12,
    grade: 4,
}

class Person {
    constructor(traits) {
        Object.assign(this, traits)
    }
    get age() {
        return getAge(this.birthday)
    }
}

class Parent extends Person {
    constructor(...args) {
        super(...args)
    }
}

//tian de qiang (tony) (send the youtube video)
//
const summerStudents = [
    {
        name: 'Diego',
        grade: 4,
        currentTopic: 'multiplication',
        parentName: 'Martinez',
        parentPhone: '425',
    },
]
//const mondayClass = new Classroom(summerStudents)

function mathfoo2() {}

/* use delimiters or use implicitness */
mathfoo2string = `



After a discount of 40%, the new price is 20 dollars. What was the original price?

A discount of 40% means we take 40% off the original, which means 100% - 40% = 60%. 60% times x equals 20. Turn 60% into 3/5, solve for x, 20 * 5 / 3 equals 33.33 dollars.

3 friends share a computer for 3 hours. Sam uses it for 28% of the time, Bob uses 52% of the time. How many minutes does Fred use?

The question gives us hours, but the answer wants minutes. So before anything, first convert 3 hours into 180 minutes. The first 2 people use 28% + 52% which means 20% is leftover for Fred. 20% times 180 = 36. The answer is 36 minutes.

equals 18 * 2 = 36. Add a zero (because 180 has an extra zero), and then add another zero (because 20 has a zero) and then shift left twice (because % means divide by 100). The two extra zeros cancels with the left shifts. The answer is 36 minutes.


What is 20% of 25% of 4/5?

20% is 1/5 and 25% is 1/4. Now we have 1/5 * 1/4 * 4/5. The 4s will cancel out. The answer is 1/25.

Write 1/25 as a decimal.

1/25 is the same as 4/100. Dividing by 100 shifts the decimal left by two places. 4 becomes 0.4 becomes 0.04. The answer is 0.04.

Write 1%/25 as a decimal.

First, ignore the percent sign. 1/25 is 0.04. (see previous question) Percent sign means divide by 100. That means shift left two places. 0.04 becomes 0.004 becomes 0.0004. The answer is 0.0004.

5 divided by 50% equals ?

Rewrite as 5div(1/2). When dividing fractions, it is the same as multiplying by the flip. So let's do that. Change to multiplication and flip it. 5 * 2/1 = 10. The answer is 10.


5 divided by 0.0002% equals ?

Change 0.0002 into a decimal (2 left shifts because of the percent sign) and we get 0.000002. Now change this into a fraction. There are 6 decimal places. So we write it as 2/1000000 (6 zeroes for 6 decimal places)  Now, it is just like the previous question. The answer is 5 * 1000000 / 2 = 2500000.

0.04% of the light bulbs are always broken. Sam finds 3 broken lightbulbs. How many total lightbulbs must there have been?

Sometimes, when doing a hard question, change the numbers to slightly easier numbers.  Pretend: "50%" of the light bulbs are always broken. Sam finds 3. Then ... there must have been 6 light bulbs. You get the number 6 from the numbers 50% and 3 by doing 3 / 50%.  That means the real answer will be 3 / 0.04% which is 3/0.0004 which is 3/(4/10000) which is 30000/4 which is 7500.

4 types of ice-creams. 40% are chocolate, 20% strawberry, 10% mint, and the last 30 ice-creams are oreo. How many total ice-creams are there?

So far, 40% + 30% + 10% = 70%. That means the last 30 oreo ice-creams must be the final 30%. In other words, 30% of the total (x) equals 30. Solve for x, by dividing away 30%. 30 / 30% = 30/(3/10) = 100. There are 100 ice-creams in total.

The price of x increases by 20% and then decreases by 25%. The final price is what percent of the starting price?

Pretend x = 100. Increase by 20% equals 120. Decrease by 25% means take away a quarter of 120. 120 - 30 = 90.  So the start is 100.  And the final is 90. 90 / 100 = 90%. The final price is 90% of the original.

If x is 40% of y, y is larger than x, by what percent of x?

With variable questions like this, it is always quite convenient to plug in some numbers to help understand what is going on. Pretend x = 40 and y = 100. Is 40 40% of 100? It most certainly is. Our test numbers work. y is larger than x by 100 - 40 = 60.  60 is what percent of x? 60 / 40 = 1.5 --> 150%.


Shop Owner: If you buy the cake with cash, take a 4% discount."
sam: I'll pay with cash.
Shop Owner: Great. Your total is 84 dollars.
sara: i'll buy the same cake. Credit card.
Shop Owner: Are you sure? No discount for credit card.
sara im sure.
how much does sara pay?

84 dollars is when there is a 4% discount. That means 84 = 0.96x. Solve for x, x = 84/0.96. Can simplify the top and bottom by 12. 7/0.08 --> 700/8 = 87.5. Sara pays $87.5 dollars. 


45 * 25 = ?

45 = 40 + 5.
40 * 25 = 4 * 25 with an extra zero = 100 and then add the zero, 1000.  5 * 25 is 5 quarters or 1 dollar and 25 cents or 125. So 40 * 25 = 4125.


On day 1, 28 students take art class. On day 2, 3 boys leave the class. Now, the percentage of boys is 44%. What was the percentage of girls on day 1?
If 3 boy students leave, that means there are only 28 - 3 = 25 students. 44% of 25 is the number of boys. 44 * 25 = 1100. That means 44% * 25 = 11. That means before any boys leave, there are 14 boys. Before any boys leave, there are 28 students. 28 - 14 = 14. We start with 14 girls. 14 girls / 28 total students means the original class is 50% girls.






`

function arithmetic({
    m = 1,
    n = 1,
    easy = 0,
    hard = 0,
    answer = 0,
    operator = '*',
} = {}) {
    const r = () => {
        let [a, b] = easy ? [1, 5] : hard ? [5, 9] : [1, 9]
        if (n == 1 && a < 2) a += 1
        return rng(a, b)
    }

    if (answer) {
        let factors = getFactors(answer).slice(1)
        if (easy) return factors.find((x) => x[0] <= 10)
        if (hard) return factors.find((x) => x[0] >= 10)
        return randomPick(factors)
    }

    let A
    let B
    for (let i = 0; i < m; i++) {
        A = addOnANumber(A, r())
    }

    for (let i = 0; i < n; i++) {
        B = addOnANumber(B, r())
    }
    return A + operator + B
}
function addOnANumber(a, b) {
    if (!a) a = 0
    return 10 * a + b
}

//console.log(arithmetic({m:1, n:1, easy: 1}))

function countTo({
    from = 0,
    to = 0,
    delta = 0,
    dir = -1,
    n = 7,
    blanks = 1,
    a = 1,
    b = 5,
} = {}) {
    if (!from) from = rng(a, b)
    if (blanks) blanks = percentOf(n)
    let max = from * from
    if (!delta) delta = rng(5, max)
    const values = range(n).map((i) => {
        return from + i * delta
    })
    const indexes = selectIndexes(values, blanks)
    indexes.forEach((index, i) => {
        edit(values, index, null)
    })
    return dir > 0 ? values : values.reverse()
}
//console.log(countTo()); throw '';
s = mathfoo2string
function aParser(s) {
    return s + 'hi'
}

function isDialogue(s) {
    const simpleDialogueRE = /^(\w+): +(.+)/gm
    return simpleDialogueRE.test(s)
}
function qParser(s) {
    if (isDialogue(s)) {
        const simpleDialogueRE = /^(\w+): +(.+)/gm
        return map(match(simpleDialogueRE, s))
    }
    console.log(s)
    throw ''
    return s + 'hi'
}
//const parser = atBoth(qParser, aParser, Array)
//data = partition(split(s, /\n\n+/)).map(parser)
//console.log(data)

function decimalsFractionsPercents(from, to) {
    if (isDecimal(from)) {
    } else if (isPercentage(from)) {
        from = parseFloat(from) / 100
    } else {
        from = fractionToDecimal
        //from = parseFraction(from)
    }
}

function randomDecimal(n) {
    if (!n) n = rng(2, 5)
    return Number(Math.random().toFixed(n))
}
//runDemo(mathTemplater)

function interweave(term, times, j) {
    let s = ''
    for (let i = 0; i < times; i++) {
        s += term
        if (i == times - 1) {
            return s
        }
        s += j.includes(' ') ? j : ' ' + j + ' '
    }
}
function latexMultiply(a, b) {
    return a + ' \\times ' + b
}
function fourthGradeAdditionAndMultiplication(a, b) {
    if (!b) {
        ;[a, b] = parseArithmetic(a)
    }
    let addition = interweave(a, b, '+')
    let multiplication = latexMultiply(a, b)
    let answer = a * b
    let numbers = range(b).map((x) => a)
    let l = katexVertical(numbers)
    let series = edit(countBy(a, b), -1, '?')
    return {
        multiplication,
        answer,
        addition,
        //l,
        series,
    }
}
//console.log(foo(3, 4))
//console.log(datePhrase())
//console.log = display

const moreThanLessThanConfigItems = [
    { terms: 2, range: [1, 5] },
    { times: 1, terms: 2, range: [1, 9] },
    {
        terms: 3,
        equality: 0,
        fractions: 0,
        decimals: 0,
        operations: [],
        range: [1, 5],
        //times: 1,
        //average, median, mean
    },
]

function foobar(configItems, amount = 0, requirements = 0) {
    condition = requirements
        ? (x) => {
              return toArray(requirements).every((r) => r(x))
          }
        : yes

    const value = map(configItems, (item) => {
        f = () => {
            const expr = moreThanLessThanGenerator(item)
            const value = solverMoreThanLessThan(expr)
            if (condition(value)) return expr
            return f()
        }
        return map(range(amount || rng(1, 3)), f)
    })
    const results = flat(value)
    return results
}

function longDivision(a, b) {
    let store = []
    let numbers = a.toString().split('').map(Number)
    let length = numbers.length
    let current = numbers[0]
    let index = 0

    while (index < length - 1) {
        if (b > current) {
            current = addOnANumber(current, numbers[index + 1])
        }

        let [result, remainder] = divmod(current, b)
        let top = index == 0 ? a : current
        let remainderValue =
            index < length - 2 ? null : remainder
        let bottom = current - remainder

        store.push({
            a: result,
            top,
            bottom,
            remainder: remainderValue,
            index,
        })

        current = remainder
        index += 1
    }
    return store
}

class MathPlane {
    color(color) {
        this._color = color || 'black'
    }
    get height() {
        return this.pos.y + 10
    }
    normalizeCoordinates() {
        const offsetY = Math.max(
            ...this.coordinates.map(([b, [x, y]]) => y)
        )

        let lastX = 0
        let lastY = 0
        this.coordinates = this.coordinates.map(
            ([v, [x, y], color], i) => {
                let gapX = 10
                let gapY = 10
                gapX = 0
                gapY = 0
                const normalizedY = Math.abs(y - offsetY)
                if (normalizedY == lastY) {
                    /* do something */
                } else {
                    //gapY
                }
                lastY = normalizedY
                return [
                    v,
                    [
                        gapX + x * this._kfactor,
                        gapY + normalizedY * this._kfactor,
                    ],
                    color,
                ]
            }
        )
    }

    constructor() {
        this.matrix = new Matrix()
        this._kfactor = 50
        this._color = 'black'
        this.pos = new PositionTracker()
        this.coordinates = []
        this.calculateLength = len
    }
    get value() {
        return this.coordinates
        return this.coordinates.map(([a, b]) => {
            return { value: a, pos: b }
        })
    }

    add(a, b, c, color) {
        if (a == null) return
        if (b == null && c == null) {
            this.coordinates.push([a, this.pos.value, color])
            this.pos.increment(this.calculateLength(a))
        } else {
            let pos = [b, c]
            if (color == null) color = this._color
            this.coordinates.push([a, pos, color])
        }
    }
    addMultiple(answers, x, y, color) {
        answers = isArray(answers) ? answers : split(answers)
        for (let i = 0; i < answers.length; i++) {
            let answer = answers[i]
            this.add(answer, x + i, y, color)
        }
    }
}

class PositionTracker {
    constructor(x = 0, y = 0, lm = 0) {
        this.x = x
        this.y = y
        this.lm = lm
    }

    get value() {
        return [this.x, this.y]
    }

    set(x, y) {
        if (x != null) this.x = x
        if (y != null) this.y = y
    }

    increment(x, y) {
        if (x) this.x += x
        if (y) this.y += y
    }

    newline() {
        this.x = this.lm
        this.y += 1
    }
}

function displayDivision(dividend, divisor) {
    function generateColors(keys, bias) {
        let colors = roygbiv
        return keys.reduce((acc, key, i) => {
            let color = colors[i]
            acc[key] = color
            return acc
        }, {})
    }
    const info = longDivision(dividend, divisor)
    const answers = info.map((x) => x.a)

    const keys = ['question', 'answer', 'body', 'remainder']
    const colors = generateColors(keys)

    const grid = new MathPlane()
    grid.addMultiple(answers, 3, 1, colors.answer)
    grid.add(divisor, 0.75, 0, colors.question)

    let x = 2
    let y = 0

    let first = false
    let color = colors.question
    for (let item of info) {
        grid.addMultiple(item.top, x, y, color)
        color = colors.body
        y -= 1

        const extra = len(item.bottom) == 1 ? 1 : 0
        grid.addMultiple(item.bottom, x + extra, y, color)

        x += 1
        y -= 1

        grid.add(item.remainder, x, y, colors.remainder)
    }
    grid.normalizeCoordinates()
    return grid.value
}

function isDivision(s) {
    return /÷|\//.test(s)
}

function parseArithmetic(s) {
    if (isArray(s)) {
        return s
    }
    /* 34 / 4 */

    return getNumbers(s, Number)
    if (hasLatex(s)) {
    } else if (isDivision(s)) {
        return {
            type: 'division',
            value: getNumbers(s),
        }
    } else if (isMultiplication) {
        return getNumbers(s)
    }
}

function splitKatex2(s) {
    if (isArray(s)) {
        return s
    }
    //if (!hasLatex(s)) return [s]
    const regex =
        /(\bif |\.? (?:[a-zA-Z]{2,}(?: |$))+|\$\w+(?:\(.*?\))?)/i
    return split(s, regex).filter(exists)
}

function hasLatex(s) {
    return test(/\\\w|\^| [\+-] /, s)
}

function katexAttributer(a, b, c) {
    return wrap(`\\${a}{${b}}{${c}}`, '{}')
}

function katexColorer(x, color) {
    return katexAttributer('textcolor', color, x)
}

function colorTheMath(s) {
    let colors
    const items = splitKatex(s).map((item, i, arr) => {
        if (item.startsWith('$input')) {
            let arg = extractArg(item) || nerdSolver(arr[i - 1])
            let color = colors[arg] || 'fakeColor'
            return {
                type: 'input',
                value: {
                    colorIt: color,
                    answer: arg,
                },
            }
        }
        if (hasLatex(item)) {
            if (!colors) {
                colors = getColors(item)
            }
            return {
                type: 'katex',
                value: latexTemplater(item, colors),
            }
        }

        return {
            type: 'prose',
            value: latexTemplater(item, colors),
        }
    })

    return items

    function getColors(s) {
        const numbers = match(/\^(\w+)/g, s)

        const colors = [
            //'#09346d',
            //'#6c7fb4',
            //'#c5d4ff',
            'red',
            'blue',
            'green',
        ]
        //const colors = roygbiv
        return zip(numbers, colors)
    }
}

function math1213(a, b) {
    const base = mathProduct('1' + String(a), '1' + String(b))
    const sum = mathSum(a, b)
    const product = mathProduct(a, b)
    return [base, sum, product]
}

//console.log(colorTheMath('2^3 * 2^4 = 2^7 because 3 + 4 = $input(7)'))
//console.log(splitKatex('x^1 * x^2 * x^3 * x^4 * x^5 = $input'))

function fixExpression(s) {
    /* fix symbols */
    s = dreplace2(s, {
        infinity: '\\infty',
        inf: '\\infty',
        pi: '\\pi',
        tan: '\\tan',
        sin: '\\sin',
        cos: '\\cos',
        ln: '\\ln',
        log: '\\log',
        '*': '\\cdot',
        //'. ': '.\\medspace ',
        //' = ?': ' \\medspace = \\medspace ?',
    })
    //console.log(s); throw ''

    s = s.replace(/\?$/, '?\\medspace')
    s = s.replace(/\^(\(.*?\)|\w{2,})/g, (_, x) => {
        return '^' + wrap(x, '{}')
    })

    /* fix multiple-expressions ... x^2^3 --> (x^2)^3 */
    s = s.replace(/(?:\w\^){2,}\w/, (x) => {
        let items = split(x, /\^/)
        let temp = items[0]
        for (let i = 1; i < items.length; i++) {
            let item = items[i]
            if (i > 1) {
                temp = wrap(temp, '()')
            }
            temp += '^' + item
        }
        return temp
    })
    return s
}

function fraction(a, b) {
    return `${a}/${b}`
}

function fixMath(s, mode) {
    if (isFraction(s)) return latex.frac(...parseFraction(s))
    if (isVeryWordy(s)) {
        s = s.replace(
            /\((.*?)\/(\d+(?:\.\d+)?)\)/g,
            (_, a, b) => {
                return latex.dfrac(a, b)
            }
        )
        return s
    }

    s = fixSquareRoots(s)
    s = fixOperators(s)   /* 2p3 = 2+3 */
    s = fixExponents(s)
    s = fixFractions(s)
    s = fixEqualSignToLatexSpaces(s)
    s = fixPlusMinus(s)
    s = fixParensToLatexParens(s)
    s = fixNumberStartsWithZero(s) /* 05.11 */
    s = fixXAndThenNumber(s) /* 2x2 3e2*/
    if (mode != String) s = fixMultiplication(s) /* 2x */
    //s = fixSpacedDivision(s) /* x / 3 */
    return s
}

function toLatex(s, styles) {
    s = fixMath(s)

    if (!hasLatex(s)) {
        s = nerdamer.convertToLaTeX(s)
    }
    if (styles) {
        s = latexTemplater(s, styles)
    }
    return s
}

//console.log(satMathData)

//console.log(displayDivision(12, 7))

function counter(n) {
    let times = Math.floor(100 / n)
    return countBy(n, times)
}
//console.log(map([3, 8, 11, 14], counter))
//const values = range(100).map((item, i) => {
//return divisibleBy(item, n) ? null : item
//})
//console.log(values)

// 07-25-2022
class LineParser {
    constructor(fn) {
        bind(this, 'parser', fn)
    }

    reset() {
        this.store = []
        this.index = 0
    }

    parse(s) {
        this.reset()
        this.lines = isArray(s) ? s : s.trim().split('\n')
        while (this.index < this.lines.length) {
            let i = this.index++
            let prev = this.lines[i - 1]
            let line = this.lines[i]
            let next = this.lines[i + 1]
            let res = this.parser(line, next, prev, i)
            if (res != null) {
                this.store.push(res)
            }
        }
        return toJSON(this)
    }
}

class ChunkParser extends LineParser {
    constructor(options) {
        const defaultOptions = {
            mainParser: mainChunkParser,
            //stringParser: stringParser,
            parserRef: {
                table: tableParser,
                shape: shapeParser,
                chart: chartParser,
            },
        }

        super()
        if (!options) options = defaultOptions
        this.mainParser = options.mainParser.bind(this)
        //this.stringParser = options.stringParser.bind(this)
        this.buildParser(options.parserRef)
    }

    buildParser(parserRef = {}) {
        let keys = Object.keys(parserRef)
        let suffix = '(?: +(.+)|\\((.*)\\))'
        let solString = ncg('^($1|[@#]\\w+)' + suffix, keys)
        let solRE = RegExp(solString)

        //let symbolString = '^[@#](\\w+)\s+([^]+?)\\n\\n'
        //let symbolRE = RegExp(symbolString)

        this.parser = (line, next, prev, i) => {
            let m

            if ((m = line.match(solRE))) {
                let [type, b] = matchgetter(m)
                b = b.trim()
                let fn = parserRef[type]
                let value = fn(b)
                return {
                    type,
                    value,
                }
            }
            return this.mainParser(line)
        }
    }
}

function tableParser(s) {
    s = s.trim()
    if (isCallable(s)) {
        if (!s.endsWith(')')) s += ')'
        return eval(s)
    }
    let items = split(s, /, */).map(toNumber)
    let [_headers, [start, end, increment]] = splitArray(
        items,
        isNumber
    )

    if (!increment) {
        if (start * 5 <= end) {
            increment = start
        } else {
            increment = 1
        }
    }
    if (!start) start = 1
    if (!end) end = 5

    let aliases = []

    let headers = _headers.map((item, i) => {
        let [header, alias] = mget(/:(\w+)/, item, '')
        if (alias) {
            aliases.push(alias)
        } else {
            aliases.push(header)
        }
        return header
    })

    let store = []
    for (let i = start; i < end; i += increment) {
        store.push(
            headers.map((header, j) => {
                if (header == 'n') {
                    return i
                }

                if (isWord(header)) {
                    return eval(stringcall(header, i))
                }
                return Calculation.calculate(
                    header.replace(/n/, (x, offset, o) => {
                        if (isNumber(o[offset])) {
                            return '* ' + i
                        }
                        return i
                    })
                )
            })
        )
    }
    return {
        headers: aliases,
        columns: store,
    }
}

function mainChunkParser(s) {
    const _tests = [
        /:$/,
        'introducer',
        null,
        /^table\((.*?)\)/,
        tableParser,
        'table',
        /^\//,
        rawMathParser,
        'katex',
    ]
    const tests = partition(_tests, 3).map((item, i) => {
        let capture = hasCaptureGroup(item[0])
        return [...item, capture]
    })

    const items = split(s, /(\b\/\S+|table.*\))/)
    const values = items.map((item, i) => {
        for (let [regex, f, key, capture] of tests) {
            let m = item.match(regex)
            if (!m) continue
            let s = capture ? m[1] || m[2] || m[3] : item
            return isString(f)
                ? { type: 'string', class: f, value: s }
                : { type: key, value: f(s) }
        }
        return simplePeriodify(item)
        return { type: 'string', value: simplePeriodify(item) }
    })
    return smallify(values)
}

function rawMathParser(s) {
    /* 
        a/ben = aem/ben
        aem * aen=ae[mpn]
        (a^m)^n = ae[mn]
        (ab)en = aenben
        //(ab)en = aen * ben
        //ae[-n] = 1/aen
        //ae[fracmn]=nrtaem
        //xe-1 = 3 and ye-1 = 9. Find (x+y)e-1/2
        //(2^{x+1})^{-4} = 1/64. Find x.
        //16^1/2 * 256^3/4 =
        //6rtxe4 * 4rtxe6 =
        //If xe-1/2 = 1/8, what is the value of xe2/3?
        //If 10ek = 64, what is the value of 10^{\\frac{k}{2} + 1}?
        //(2rs)e-1 = 3se-2. Find r/s.
     */

    s = s.replace(/f(\w+)\/(\w+)/g, (_, a, b) => {
        return `\\\\frac{${a}}{${b}}`
    })

    s = s.replace(/(\w+)(?:sq)?rt(\w+)/g, (_, a, b) => {
        return `\\sqrt[${a}]{${b}}`
    })

    s = s.replace(/p/g, '+')
    s = s.replace(/\*/g, '\\cdot')
    let exponentRE = /e(-?(?:[a-zA-Z]|[\d\/]+)|\[.*?\])/g
    s = s.replace(exponentRE, (_, x) => {
        if (x.length == 1) {
            return '^' + x
        }
        if (x.startsWith('['))
            return '^' + wrap(x.slice(1, -1), '{}')
        return '^' + wrap(x, '{}')
    })
    s = s.replace(/frac(\w+)/g, (_, x) => {
        let [a, b] = x.split('')
        return `\\frac{${a}}{${b}}`
    })
    s = s.replace(/([\w^]+)\/([\w^]+)/g, (_, a, b) => {
        return `\\frac{${a}}{${b}}`
    })
    //console.log(s); throw "";

    let m = '\\medspace'
    s = s.replace(/ = *$/gm, [m, '=', m, '?', m].join(' '))
    return s
}

//runDemo(rawMathParser, 1)

hamstring = `
Multiples of 2 and 3

Multiples of 2s means counting by 2s table(countBy(2, 5))
Multiples of 3s means counting by 3s table(countBy(3, 5))

In the boxes below, 
If the number is a multiple of 2, color it yellow.
If the number is a multiple of 3, color it blue.
If the number is a multiple of 2 AND 3, color it green.

table(range(5))
`
function titleInstructionsDiagram(s) {
    /* uses global.fx */
    /*  */
    return firstBodyLast(s).map((item, i) => {
        let keys = ['title', 'instructions', 'diagram']
        let key = keys[i]
        let value = fx(item)
        if (isObject(value)) {
            value = { children: [value], type: key }
        } else if (isArray(value)) {
            value = { children: value, type: key }
        }
        return value
    })
}

function firstBodyLast(s) {
    let [a, first] = mreplace(/.+/, s)
    let [second, third] = mreplace(/.+$/, a)
    return [first, second, third]
}

function breakpoint(x) {
    return isArray(x)
}
function combineChunks(a) {
    let store = []
    let temp = []
    for (let i = 0; i < a.length; i++) {
        let item = a[i]
        if (breakpoint(item)) {
            if (exists(temp)) {
                store.push(temp)
                temp = []
            }
            store.push(item)
            continue
        }

        let next = a[i + 1]
        temp.push(item)
        if (!exists(next)) {
            store.push(temp)
            temp = []
        }
    }
    return store
}

function transformChunks(a) {
    let mode = null

    function reset() {
        mode = null
    }

    function g(item, i) {
        if (item.type != 'string') return item
        let s = item.value
        if (i == 0) {
            if (test(/,$/, s)) {
                mode = 'comma'
                item.class = 'comma-parent'
            }
        } else if (mode == 'comma') {
            item.class = 'comma-child'
        }
        return item
    }

    function f(item, i) {
        reset()
        const name = map(item, 'type').join('-')
        const value = map(item, g)
        return [name, value]
    }

    function reset() {
        mode = null
    }

    //return a.map(f)

    let store = []
    let lastName
    let temp = []
    for (let item of a) {
        const [name, value] = f(item)
        if (name == lastName) {
            temp.push(value)
        } else if (exists(temp)) {
            store.push(smallify(temp))
            temp = [value]
        } else {
            temp.push(value)
        }

        lastName = name
    }
    if (exists(temp)) {
        store.push(smallify(temp))
    }
    return smallify(smallify(store))
}

/* there is no need to ask those questions */

function renderChunks(h, a) {
    function runner(a) {
        const children = map(a, (item, i) => {
            if (isObject(item)) {
                return renderObject(item)
            }
            if (isArray(item)) {
                return renderArray(i, item)
            }
        })
        return children
    }
    function renderArray(name, a) {
        return renderWrapper(h, name, runner(a))
    }
    function renderObject(o) {
        /* sometimes there will be other values that need to be incorporated. as one item leads into a different item */

        if (o.children) {
            return renderArray(o.type, o.children)
        }
        if (isArray(o.value)) {
            return renderArray(o.type, o.value)
        }
        return renderWrapper(h, o.type, o.value)
    }

    const children = runner(a)
    return renderWrapper(h, children)
}
//console.log(titleInstructionsDiagram(s))
var Ham = {
    name: 'Ham',
    render(h) {
        return renderChunks(
            h,
            titleInstructionsDiagram(hamstring)
        )
    },
    mounted() {
        console.log('hi from Ham')
    },
}

function chartParser() {}

function shapeParser() {}

function betweenf(a, b) {
    return (x) => {
        return x >= a && x <= b
    }
}

/*  */

//1,2,3,4
//2,4,6,8
//5,10,15,20,25

function storeAndTemp() {
    let store = []
    let temp = []
    function push() {
        store.push(copy(temp))
        temp = []
    }
    return [store, temp, push]
}
function sequence12123(n = 10) {
    let a = 1
    let c = 0
    let store = []
    while (c < n) {
        for (let i = 1; i <= a; i++) {
            if (i == 1 && a == 1) continue
            store.push(i)
            c += 1
        }
        a++
    }
    return store
}

function sequence1122(n) {
    let a = 1
    let c = 0
    let store = []
    while (c++ < n) {
        store.push(a)
        store.push(a)
        c++
        c++
        a++
    }
    return store
}

function sequence12321(n) {
    let a = 1
    let c = 0
    let store = []
    while (c < n) {
        for (let i = 1; i <= a; i++) {
            if (i == 1 && a == 1) continue
            c += 1
            store.push(i)
        }

        for (let i = a - 1; i > 1; i--) {
            c += 1
            store.push(i)
        }
        a++
    }
    return store.concat(1)
}
//console.log(sequence1122(8))

function linearEquation(a, b) {
    let op = wrap(eitherOr('+', '-'), ' ')
    const value = a + 'x' + op + b
    return bringToLife(value)
    return value
}
function sequenceFromEquation(s) {
    if (s == 'r') {
        s = linearEquation(rng(2, 9), rng(1, 100))
        return s
    }
    if (hasOperator(s)) {
        return patternParser(s, rng(), 1, rng(5, 7), coinflip())
    }
    return s.split('').map((x) => (x == 'x' ? null : x))
}

/* multiplications by 2 digit */
/* start simple */
/* enough to eat */
/* what pattern comes next? */
/* to see how it goes ... */
/* have to aggregate ... have to build off of the past. not time to check fb right now*/
seqws = `

r
r
r
r
r
r

1x3454321
1122334455xxxx
5x32x2345
12233344445x555x
1202193184x
12xxx123412345
`
sequences = `

12345
12123123412345
123454321
1122334455
543212345
122333444455555
`

worksheets = ` 

INCLASS  = 4-5 Pages
HOMEWORK = 10 Pages
There needs to be a medley

`
class Dialogue {
    intro(lines) {
        const sayhi = sayhif()
        const students = this.students
        const speakers = []
        let index = students.length - 1
        for (let i = lines.length - 1; i >= 0; i--) {
            speakers.unshift(students[index--])
            if (index < 0) index = students.length - 1
        }
        speakers.push(...students)
        lines = lines.map((x) => this.templater(x))
        lines.push(...students.map(sayhi))
        const value = zip(speakers, lines, Array)
        this.nextSpeaker = randomPick(students.slice(0, -1))
        return value
    }
    templater(s) {
        return s.replace(/\$(\w+)/g, (_, x) => {
            if (x == 'n') x = 'length'
            const value = this[x]
            if (isPrimitive(value)) {
                return value
            }
            if (isArray(value)) {
                return ''
            }

            if (isObject(value)) {
                return ''
            }
        })
    }
    constructor(key) {
        this.students = getStudents(key)
        this.length = this.students.length
        this.store = []
        this.chunkParser = new ChunkParser()
    }
    getPoolSpeaker() {
        let length = -1 * (this.length - 1)
        const speakers = this.speakerHistory.slice(length)
        const f = notIn(speakers)
        return randomPick(this.students.filter(f))
    }
    build(s) {
        //const symbolString = '^[@#](\\w+)\\s+([^]+?)\\n\\n|\\n'
        //const symbolRE = RegExp(symbolString, 'm')

        const items1 = splitLinesTwice(s)
        const items2 = items1.map((item, i) => {
            let lines = items1[i]
            let first = lines[0]
            if (isSymbolTag(first)) {
                let tag = first.slice(1)
                return this[tag](lines.slice(1))
                /* returns an array of items */
            } else {
                const value1 = this.chunkParser.parse(lines)
                const value2 = addSpeakers.call(this, value1)
                return value2
            }
        })
        return items2
    }
}
function stringDialogueParser(s) {
    /* there will be cases when it is not a string.
        when u are dealing with a nested object or an array
    
    */
    assert(isString(s), 'todo')

    if (isString(s)) {
        if (isQuestion(s)) {
            this.questionSpeaker = this.nextSpeaker
            this.indexCountFromQuestion = 0
        }
        let nextSpeaker
        let value = s.replace(/\$([a-zA-Z]*)/g, (_, x) => {
            nextSpeaker = true
            switch (x) {
                case '':
                    this.nextSpeaker = this.lastSpeaker
                    return this.lastSpeaker
                case 'self':
                case 'self':
                case 'qs':
                case 'qa':
                    this.overrideSpeaker = this.getPoolSpeaker()
                    return this.questionSpeaker
            }
        })
        if (!nextSpeaker) {
            this.nextSpeaker = this.getPoolSpeaker()
        }
        return value
    }
}
function addSpeakers(items) {
    this.speakerHistory = []
    const value = items.map((item, i) => {
        let r = /^(#\w*) */
        let speaker

        let [text, overrideSpeaker] = mget(r, item)
        if (overrideSpeaker) {
            if (overrideSpeaker == '#') {
                speaker = this.getPoolSpeaker()
            } else {
                speaker = overrideSpeaker.slice(1)
            }
        } else {
            speaker = this.nextSpeaker
        }
        this.speakerHistory.push(speaker)
        let s = stringDialogueParser.call(this, text)

        if (this.overrideSpeaker) {
            speaker = this.overrideSpeaker
            this.overrideSpeaker = null
        }
        this.lastSpeaker = speaker
        return [speaker, s]
    })
    console.log(value)
    throw ''
    return value
}

//runClass(Dialogue, splitThePage(read("counting1.dialogue.math.txt")))

function getMathText(f) {
    return splitThePage(read(f + '.math.txt'))
}

// 07-27-2022
function isWordTag(s) {
    const list = ['fooo', 'list', 'table', 'convo']
    return list.includes(s)
}
class TempState {
    list(lines) {
        return {
            type: 'list',
            value: lines,
        }
    }
    constructor() {
        this.chunkParser = new ChunkParser()
    }
}

function aggMathStory(s) {
    const state = new TempState()
    const items1 = splitLinesTwice(s)
    const items2 = items1.map((item, i) => {
        let lines = items1[i]
        let first = lines[0]
        if (isSymbolTag(first)) {
            let tag = first.slice(1)
            return state[tag](lines.slice(1))
        } else if (isWordTag(first)) {
            let tag = first
            return state[tag](lines.slice(1))
        } else {
            return state.chunkParser.parse(lines)
        }
    })
    return items2
}

function bringToLifeRecursiveEquation(s) {
    runDemo(bringToLifeRecursiveEquation)(1)
    /* kind of works */
    /* b2 = b1 + b0 */
    let acc = 0
    let count = 0
    let r = /[a-z]\d+/g
    let m = match(r, s)
    let length = m.length - 1
    let store = []
    let e = getLongest(split(s, /=/))
    e = e.replace(r, (x) => {
        let n = getNumber(x)
        return `store[store.length - ${n + 1}]`
    })
    e = '() => ' + e
    e = eval(e)

    function lambda(x) {
        count++
        if (count < length) {
            store.push(x)
            return x
        }
        let value = e()
        store.push(value)
        return value
    }

    return lambda
}

function patternParser(pattern, from, missing, n, reverse) {
    if (!from) from = rng()
    if (!missing) missing = 1
    if (!n) n = 5

    let numbers = range(from, from + n)
    let lambda = hasEquals(pattern)
        ? bringToLife(pattern)
        : bringToLifeRecursiveEquation(pattern)

    let store = numbers.map(lambda)
    if (reverse) store.reverse()

    const indexes = selectIndexes(store, missing, 0, 0)
    return store.map(blankf(indexes))
}

function seriesParser(operator, a, b, reverse) {
    let store = []
    let temp = [a]
    for (let i = a + 1; i < b; i++) {
        temp.push(i)
        const value = copy(temp)
        if (reverse) value.reverse()
        store.push(value.join(' ' + operator + ' '))
    }
    return reverse ? store.reverse() : store
}

const homeworkRef = {
    sudoku(level, amount) {
        const ref = {
            easy: '4 by 4',
            medium: '6 by 6',
            hard: '9 by 9',
        }
        const key = ref[level]
        const n = key[0]
        const prefix = addSpacesToEnd(key)
        const instructions = `Fill in each empty box with a number from 1 to ${n}. Each column and each row must add up to ${sum(
            range(n)
        )}.`
        return {
            title: prefix + 'Sudoku',
            instructions,
            value: range(amount, generateSudoku, level),
        }
    },
}

//console.log(fourthGradeAdditionAndMultiplication(3, 4))

//mathQuestions = shuffle(
//filter(map(generateNumbers({ start: 1, end: 10 }), f78))
//)
//console.log(mathQuestions); throw '';
//mathdata is somehting

function loremer2() {
    const pairs = generateNumbers({
        start: 3,
        end: 8,
        amount: 0,
    })
    const a1 = map(
        pairs,
        partial(fourthGradeAdditionAndMultiplication)
    )
    return a1
}

function numberToWord(num) {
    num = Number(num)
    var ones = [
        '',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
    ]
    var tens = [
        '',
        '',
        'twenty',
        'thirty',
        'forty',
        'fifty',
        'sixty',
        'seventy',
        'eighty',
        'ninety',
    ]
    var teens = [
        'ten',
        'eleven',
        'twelve',
        'thirteen',
        'fourteen',
        'fifteen',
        'sixteen',
        'seventeen',
        'eighteen',
        'nineteen',
    ]

    function convert_millions(num) {
        if (num >= 1000000) {
            return (
                convert_millions(Math.floor(num / 1000000)) +
                ' million ' +
                convert_thousands(num % 1000000)
            )
        } else {
            return convert_thousands(num)
        }
    }

    function convert_thousands(num) {
        if (num >= 1000) {
            return (
                convert_hundreds(Math.floor(num / 1000)) +
                ' thousand ' +
                convert_hundreds(num % 1000)
            )
        } else {
            return convert_hundreds(num)
        }
    }

    function convert_hundreds(num) {
        if (num > 99) {
            return (
                ones[Math.floor(num / 100)] +
                ' hundred ' +
                convert_tens(num % 100)
            )
        } else {
            return convert_tens(num)
        }
    }

    function convert_tens(num) {
        if (num < 10) return ones[num]
        else if (num >= 10 && num < 20) return teens[num - 10]
        else {
            return (
                tens[Math.floor(num / 10)] +
                ' ' +
                ones[num % 10]
            )
        }
    }

    if (num == 0) return 'zero'
    let value = convert_millions(num)
    if (len(value) == 2) {
        return value.replace(/ /, '-')
    }
    return value
}
//console.log(numberToWord(311))
function loremer1() {
    s = `
    123 + 145
    167 + 234
    10000 + 1000
    1232 + 100
    100000000 + 1000 + 10000 + 10
    `
    s = linegetter(s)
        .map((x) => {
            let val = x.replace(/\d+/g, numberToWord)
            return x + '    |   ' + val
        })
        .join('\n')
    ofile('hi.js', s)
}

//const addEqualSign = endAdderF('=')
//const addComma = endAdderF(/[,!.?]$/, ',')
//const fx = compose(transformChunks, combineChunks, exporter(ChunkParser))

function nerdCheck(a, b) {
    if (isWord(b)) {
        return a == b
    }

    if (isArray(a)) {
        return a.some((x) => nerdCheck(x, b))
    }

    a = normalizeMath(a)
    b = normalizeMath(b)
    if (a == b) return true

    a = prepareNerdCheck(a)
    b = prepareNerdCheck(b)

    if (hasVariable(b.toString())) {
        const dict = reduce(
            getVariables(b.toString()),
            (x) => char2n(x) + 2
        )
        const nerda = nerdsub(a, dict)
        const nerdb = nerdsub(b, dict)
        return String(nerda) == String(nerdb)
    } else {
        if (a.toString() == b.toString()) return true
        const answera = nerdEval(a)
        const answerb = nerdEval(b)
        return answera == answerb
    }
}

function prepareNerdCheck(b) {
    if (hasLatex(b)) {
        try {
            b = nerdamer.convertFromLaTeX(b)
            return b
        } catch (e) {
            return 'error: nerdamer-syntax'
        }
    }
    return b
}

function hasLatex(s) {
    return test(/\\/, s)
}
function nerdsub(s, dict) {
    let nerd = nerdamer(s)
    for (let [k, v] of Object.entries(dict)) {
        nerd = nerd.sub(k, v)
    }
    return nerd
}

function toStandardLinearEquation(s) {
    return nerdSolver(s, 'y')
}
//console.log(toStandardLinearEquation('y + 4 = x'))

//console.log(items)
function getPolynomialDegree(s) {
    s = s.toString()
    let m = search(/\^\(?(\w+)/, s)
    if (m) return Number(m)
    m = search(/x/, s)
    if (m) return 1
    return 0
}

function orderByPolynomialDegree(equation) {
    if (!equation.includes('^')) return equation
    const items = schemaMatch(
        '^$mathop?$mathvar|$mathop$mathvar',
        equation
    )
    sorted(items, ([a, b]) => getPolynomialDegree(b), true)
    let s = ''
    for (let i = 0; i < items.length; i++) {
        let [a, b] = items[i]

        if (i == 0) {
            if (a == '-') s += a
            else if (a == '/') s += a
            s += b
        } else {
            s += ' ' + a + ' ' + b
        }
    }
    //console.log(s)
    return s.trim()
}

function getStringVariable(s) {
    return search(/\b[abcxyzmn]\b/, s) || 'x'
}
function functionFromString(s) {
    s = s.replace(/^y, *= */g, '')
    return nerdamer(s).buildFunction()
}

//import itersearch
//x = orderByPolynomialDegree('- b + x^2 + 5x + 7x')
//console.log(x)
//console.log(arg)
//console.log(nerdSolver("y=x^3", "y =x"))
function equationSolver(f1, f2) {
    f1 = normalizeEquation(f1)
    f2 = normalizeEquation(f2)
    const equation = `${f1} = ${f2}`
    const variable = itersearch(equation, /\b[xabc]\b/)
    const value = nerdamer.solve(equation, variable).toString()
    return toNumericalArray(value)
}
function toNumericalArray(x) {
    return x.toString().slice(1, -1).split(/, */).map(Number)
}

function normalizeEquation(s) {
    return s.replace(/^\w+ *= */, '')
}

/* 12-31-2021 fixNerdamer */
function isBrowser() {
    return !isNode()
}

function isNode() {
    return typeof window === 'undefined'
}
//qm QuestionMakerGenerator

const mathOperatorRE = / *([\+\-\*\=]) */

let hardMathOperators = ['*', '-', '+', '/']
let mathOperators = ['*', '-', '+']
let easyMathOperators = ['*', '-', '+']
let weightedMathOperators = ['*', '*', '-', '+']

function looksLikeMixedAnswer(x) {
    return /[A-Z]/.test(x) && mathOperatorRE.test(x)
}

const simpleNumberRE = /\d+(?:\.\d+)?/g
function pairup(items, target) {
    let [number, word] = isNumber(items[0][0]) ? [0, 1] : [1, 0]

    let a = items[0][word]
    let [two, three] =
        depluralize(target[word]) == depluralize(a)
            ? [target[number], items[2][number]]
            : [items[2][number], target[number]]

    let args = [items[0][number], items[1][number], two, three]
    return args
}

function splitApart(arr, fn) {
    let found
    let store = []
    for (let item of arr) {
        if (!found && fn(item)) {
            found = item
        }
        store.push(item)
    }
    return found ? [found, store] : null
}

function toUpperCase(s) {
    return s.toUpperCase()
}

function getLast(arr) {
    return arr[arr.length - 1]
}


function addRandomParentheses(s) {
    let items = getnumbers(s)
    let indexes = pickIndexes(items, 2)
    if (
        indexes[0] == 0 &&
        getLast(indexes) == items.length - 1
    ) {
        indexes[0] = 1
    }
    let delimiters = [(s) => '(' + s, (s) => s + ')']
    let count = 0
    return replace(
        /\d+/g,
        (x) => {
            if (!exists(delimiters)) return x
            if (count++ == indexes[0]) {
                indexes.shift()
                return delimiters.shift()(x)
            }
            return x
        },
        s
    )
}

function pickIndexes(items, n) {
    let length = items.length - 1
    let numbers = range(0, length)
    shuffle(numbers)
    return sorted(numbers.slice(0, n))
}

function splitThreeWays(s, ...indexes) {
    const store = []
    indexes.unshift(0)
    indexes.push(s.length)

    for (let i = 0; i < indexes.length - 1; i++) {
        let [a, b] = indexes.slice(i, i + 2)
        store.push(s.slice(a, b))
    }

    return store
}

function isDoubleIterable(x) {
    return isNestedArray(x) || isObject(x)
}

function datedname(s, e = 'json') {
    return s + datestamp() + '.' + e
}

function booleanToNumber(x) {
    if (isNumber(x)) {
        return x
    }
    if (x === true) return 1
    if (x === false) return -1
}

class BaseGenerator {
    constructor(numbergen, watcher) {
        this.limit = 20
        this.config = {
            level: 0,
            index: 0,
        }
        this.numbergen = numbergen || new Numbergen()
        this.watcher = watcher || new Watcher()
    }

    run(items) {
        return items.map((item) => this._generate(item))
    }

    _generate(...args) {
        let count = 0
        while (count++ < this.limit) {
            let value = this.f(...args)
            if (value == null) {
                continue
            }
            if (!this.validator(value, count)) continue
            if (!this.watcher.isFresh(value)) continue
            return value
        }
        return null
        console.log(
            'error here because same value was generated over and over _generate'
        )
        throw ''
    }

    validator(x, count) {
        if (
            this.config.useVariablesInAnswer &&
            looksLikeMixedVariableAnswer(x.answer)
        ) {
            return true
        }

        if (
            this.config.onlyIntegerAnswers &&
            isFraction(x.answer)
        ) {
            return false
        }

        if (
            this.config.onlyPositiveAnswers &&
            parseInt(x.answer) <= 0
        ) {
            return false
        }
        return true
    }
}

//function modularIncrement(arr, item, increment = 1) {
//const i = arr.indexOf(item)
//return arr[(i + increment) % arr.length]
//}

function infuseProunciations(s) {
    const r = '"(.*?)"'
    const ref = {
        beta: 'bay-tuh',
        dog: 'doggi-e',
    }

    function parse(ref, x) {
        let s = ref[x] || x
        return parens(
            'pronounced ' + conditional(s, toUpperCase, '-')
        )
    }

    return replace(
        r,
        (s, x) => {
            let extra = ref[x]
            return ref.hasOwnProperty(x)
                ? s + ' ' + parse(ref, x)
                : s
        },
        s
    )
}
function toggleForward(obj, key) {
    if (obj[key]) {
        obj[key] = false
        return true
    }
}

const MasterConfig = [
    {
        withVariables: false,
        onlyPositiveAnswers: true,
        onlyIntegerAnswers: true,
        //answerAsDecimal: representDecimalsAsFractions: convertDecimalsToFractions
    },
]
const NUMBER_RANGES = {
    answers: [
        [1, 9],
        [5, 20],
    ],
    addZeroes: [
        [1, 2],
        [2, 4],
        [4, 6],
    ],
    addDecimals: [
        [-2, -1],
        [-3, -2],
        [-4, -3],
    ],
    addZerosOrDecimals: [
        [1, 3],
        [-2, 3],
        [-3, 4],
    ],
    levels: [
        [2, 9],
        [2, 18],
    ],
    numbers: [
        [2, 9],
        [2, 18],
        [30, 50],
        [50, 75],
    ],
    //numbers: [[2, 9], [2, 18], [30, 50], [50, 75], [76, 100], [30, 1000], [900, 1000], [2000, 2500], [2600, 3000]],
}

//const mhsa = mhfactory('+')
//const mhss = mhfactory('-')
//const mhsm = mhfactory('*')
//const mhsd = mhfactory('/')
//const mhse = mhfactory('=')

function mhsr(a, b) {
    if (!a || !b) return null
    return a + ':' + b
}
//const t = ehfactory()

function iteration(x, fn, split, join) {
    const dict = {
        '': ['', ''],
        '\n': ['\n', '\n'],
        '\n+': [/\n\n+/, '\n'],
    }
    if (!join) [split, join] = dict[split]
    return x.split(split).map(fn).join(join)
}

function ehfactory() {
    return (s = 'boop') => {
        throw s
    }
}

let __debug__ = true

function debugit(items) {
    const [fail, pass] = partitioned(items, (x) =>
        JSON.stringify(x).includes('undef')
    )
    console.log(items)
    console.log('number of pass', pass.length)
    console.log('number of fail', fail.length)
    throw ''
}

function setLevel(obj, level) {
    if (obj.config) obj.config.level = level
    if (obj.numbergen) obj.numbergen.config.level = level
}

function hasEquals(s) {
    return test(/=/, s)
}

function hasVariableX(s) {
    return test(/[a-z]x/, s)
}

function mhparse(s) {
    return search(/\S+/, s)
}
function reshapeQuestionAndAnswer(item) {
    const regex = /how many (\w+)( are in)?/i
    if (test(regex, item.question)) {
        if (eval(mhparse(item.question) < 1)) {
            return {
                question: item.question.replace(
                    regex,
                    (x, extra) => {
                        extra = extra ? ' is' : ''
                        return 'What fraction of a ' + x + extra
                    }
                ),
                //answer: item.answer.replace(/\w+$/, x => {
                //
                //})
                answer,
            }
        }
    }
    return item
}

function editArray(arr, fn, condition) {
    arr.forEach((item, i) => {
        if (condition(item)) {
            arr[i] = fn(item)
        }
    })
}

function hasJavascript(s) {
    const items = ['[a-zA-Z]{4,}']
    return test(ncg(items), s)
}

function toggle(obj, key, mode) {
    if (mode == 'both') {
        obj[key] = !obj[key]
    } else if (obj[key]) {
        obj[key] = false
        return true
    }
}

function fixNumberPluralization(s) {
    let verb = ''
    let noun = ''
    let ignore = ['to', 'are', 'and', 'of', 'how', 'by']

    s = s.replace(/(?<=(\d+|how many) )(\w+)/gi, (_, a, b) => {
        if (ignore.includes(b)) return b
        if (isNumber(a))
            return a == 1 ? depluralize(b) : pluralize(b)
        return pluralize(b)
    })

    //return s

    s = s.replace(
        /(makes?|made) (\d+) (\w+)/,
        (_, tense, amount, word) => {
            //console.log(word)
            verb = randomPick(
                verblib[
                    findKey(
                        verbfoodconnectorlib,
                        depluralize(word)
                    )
                ]
            )
            verb = toTense(verb, tense)
            const adj = getAdjectiveForNoun(word)
            if (amount > 1) word = pluralize(word)
            noun = word
            return [verb, amount, adj, word]
                .filter(exists)
                .join(' ')
        }
    )

    if (verb) {
        s = s.replace(/makes?|made/g, (x) => {
            return toTense(verb, x)
        })

        s = replace(noun + '?', (x) => noun, s) // normalizes pluralization
    }
    return s
}
function toTense(verb, tense) {
    console.log(verb, tense)
    if (!tense) return verb
    if (tense.endsWith('s')) return pluralize(verb)
    return depluralize(verb)
}

const setupRE = '(is )?what (\\w+)(?: of)?'
const allMathNumberRE = '-?\\d+\\.?\\d*%?'
const allMathNumberItemRE =
    '-?\\d+\\.?\\d*%? \\w+|[a-zA-Z]+-[a-zA-Z]+ \\w+'
const allMathNumberItemCRE =
    '(-?\\d+\\.?\\d*%?) (\\w+)|([a-zA-Z]+-[a-zA-Z]+) (\\w+)'
const allNumbersRE = /-?\d+(?:\.\d+)?(?:\/\d+(?:\.\d+)?)?/g

const mathShapes = {
    circle: {
        circumference: '2 * pi * r',
        area: 'pi * r^2',
    },
    sector: {
        angle: '',
    },
}

const mathFormulas = {
    distance: 'd = rt',
    'pythagorean theorem': 'a^2 + b^2 = c^2',
    interest: 'eeee',
    area: {
        circle: 'pir^2',
        square: 's^2',
        rectangle: 'l*w',
    },
    perimeter: {},
    distance: 'd = rt',
}
const fractionWordRE = /[a-z]+-[a-z]+/gi

//const nerdamer = require("nerdamer/all.min")
function isAnyMathNumber(s) {
    return test(allMathNumberRE, s)
}

function findKey(dict, key) {
    for (let [k, v] of Object.entries(dict)) {
        if (v.includes(key)) return k
    }
}

function findEntry(dict, fn) {
    for (let [k, v] of Object.entries(dict)) {
        if (fn(k, v)) return [k, v]
    }
}

const globaladjectivelib = {
    food: [
        'mama mia',
        'tremendous',
        'once-in-a-lifetime',
        'mouth-watering',
        'sumptious',
        'extravagant',
        'delish',
        'delicious',
        'out-of-this-world',
        'absolutely cray-cray',
        'one-of-a-kind',
    ],
}
function getAdjectiveForNoun(item) {
    item = depluralize(item)
    const key = findKey(itemadjectiveconnectorlib, item)
    if (!key) return
    const adjective = randomPick(globaladjectivelib[key])
    return adjective
}

function randomizer(items) {
    let choices = prepareIterable(items, 'values')
    let choice = randomPick(choices)
    if (isIterable(choice)) {
        return randomizer(choice)
    }
    return choice
}

function getNearbyUnit(s, mode) {
    s = depluralize(s)
    let ref = getTypeFromReferenceLib(s, Array)
    let index = ref.indexOf(s)
    let isStart = index == 0
    let isEnd = index == ref.length - 1

    function runner() {
        switch (mode) {
            case 'bigger':
                if (isEnd) return index
                return index + 1

            case 'smaller':
                if (isStart) return index
                return index - 1

            default:
                //console.log(index, 'hi')
                return [
                    index - 2,
                    index - 1,
                    index + 1,
                    index + 1,
                ]
        }
    }

    let $index = runner()
    function runner2() {
        if (isArray($index)) {
            return randomPick(
                $index.map((i) => ref[i]).filter(exists)
            )
        } else {
            return ref[$index]
        }
    }

    return pluralize(runner2())
}

function normalizeFractions(...args) {
    return args.map(globaleval)
    let n
    let d
    for (let arg of args) {
        if (isFraction(arg)) {
            ;[n, d] = arg.split('/')
        }
    }
}

const unitreferencelib = {
    //time: ['second', 'minute', 'hour', 'day'],
    time: [
        'second',
        'minute',
        'hour',
        'day',
        'week',
        'month',
        'year',
        'decade',
    ],
    //time: {items: ['millisecond', 'second', 'minute', 'hour']}
}

function stringfactory(x) {
    if (x == toFraction) return (a, b) => a + '/' + b
    if (x == toPercentage)
        return (a, b) => '100 * ' + parens(a + '/' + b)
    if (x == toRatio)
        return (a, b) => a + ':' + parens(b + ' - ' + a)
}

function toNiceNumber(n) {
    return roundToNearest(n)
}
const xfracRE = /x\/[a-z]/

function generatepathmap(obj, fn) {
    return prepareIterable(obj, 'entries').reduce(
        (acc, [k, v]) => {
            let key = fn(k, v)
            acc[key] = v
            return acc
        },
        {}
    )
}

const standardNumberRanges = [
    [51, 100],
    [1, 5],
    [1, 9],
    //[9, 50],
]

const numberRanges = [
    [1, 5],
    [51, 100],
    //[9, 50],
]

const fractionRanges = [
    [1, 5, 2, 5],
    [1, 5, 2, 5],
    [1, 9, 2, 9],
    [1, 9, 25, 50],
    [9, 50, 50, 100],
]
const longDivisionRanges = [
    [2, 4, 5, 9],
    [3, 9, 200, 300],
    [2, 10, 50, 100],
    [101, 199, 101, 199],
]

const masterNumberRange = {
    'long-division': longDivisionRanges,
    'fraction-addition': fractionRanges,
    default: numberRanges,
}

function isMyError(e) {
    const name = e.constructor.name
    return name == 'Error' || name == 'String'
}

function hasNaN(s) {
    return s.toString().includes('NaN')
}

function matheval(s) {
    return eval(s)
}

function getTypeFromReferenceLib(s, mode) {
    //console.log(s)
    s = depluralize(s)
    //console.log(s, 'adsf')

    for (let [k, v] of Object.entries(unitreferencelib)) {
        if (v.includes(s)) return mode == Array ? v : k
    }
}

function orderedSort(items, order) {
    let store = []
    for (let i = 0; i < order.length; i++) {
        if (items.indexOf(order[i]) > -1) {
            store.push(order[i])
        }
    }
    return store
}

function isNiceAnswer(n) {
    return n > 0 && isInteger(n) && n <= 10
}

function isFactoryFunction(fn) {
    const regex = 'return (?:\\(\\w|function|parser|runner)'
    return test(regex, fn.toString())
}

function wordToNumber(s) {
    return numberWords.indexOf(s.toLowerCase())
}

const operationlib = {
    betweenNumbers: [
        'more than',
        'less than',
        'times',
        //'difference',
        //'sum'
    ],
    betweenAnything: ['more than', 'less than', 'of'],
}

operationlibconnector = {
    'more than': ['more than', nerdMoreThanHelper],
    'less than': ['less than', nerdLessThanHelper],
    of: ['of', nerdOfHelper],
    times: ['times', nerdTimesHelper],
    difference: [
        mathproseDifferenceWriter,
        nerdDifferenceHelper,
    ],
    sum: [mathproseSumWriter, nerdSumHelper],
}

function mathproseDifferenceWriter(...args) {
    return 'the difference between ' + mathproseJoinArgs(args)
}

function mathproseJoinArgs(args) {
    if (args.length == 2) return args.join(' and ')
    return (
        args.slice(0, -1).join(', ') +
        ', and ' +
        args[args.length - 1]
    )
}
function mathproseSumWriter(...args) {
    return 'the sum of ' + mathproseJoinArgs(args)
}

function hasTerminatingDecimal(s) {
    return len(s) < 6 || isRepeatingDecimal(s)
}

function isRepeatingDecimal(s) {
    s = s.toString()
    if (!s.includes('.')) return
    const decimal = s.split('.')[1]
    return (
        (((decimal[0] == decimal[1]) == decimal[2]) ==
            decimal[5]) ==
        decimal[6]
    )
}

class UniqueStorage3 {
    constructor(seenFn, checkFn) {
        this.seenFn = seenFn
        this.checkFn = checkFn
        this.reset()
    }

    reset() {
        this.store = []
        this.seen = []
    }
    add(fn, ...args) {
        let count = 0

        while (++count < 50) {
            let value = fn(...args)
            let seenValue = this.seenFn(value)
            if (this.seen.includes(seenValue)) {
                continue
            } else {
                this.seen.push(seenValue)
            }

            if (this.checkFn && !this.checkFn(value)) {
                continue
            }

            this.store.push(value)
            return value
        }
        throw ''
    }
}

class UniqueStorage2 {
    constructor(condition) {
        this.condition = condition
        this.reset()
    }

    reset() {
        this.store = []
    }
    add(fn, ...args) {
        let value
        let count = 0
        //if (this.store.length > 5) {
        //console.see('booooo')
        //this.reset()
        //}
        while (++count < 50) {
            value = fn(...args)
            if (this.store.includes(value)) {
                continue
            }
            if (this.condition && !this.condition(value)) {
                console.log('failed condition', value)
                continue
            }
            this.store.push(value)
            return value
        }
        throw ''
    }
}

const div = ' ÷ '
const mathOrdinals = [
    '1st',
    '2nd',
    '3rd',
    '4th',
    '5th',
    '6th',
    '7th',
    '8th',
    '9th',
    '10th',
]
function factorList(number) {
    var factors = []
    for (var i = 1; i <= number; i++) {
        if (number % i == 0) factors.push(i)
    }
    return factors
}
function getprimefactors(n) {
    const p = factorList(n).filter(isPrime)
    return p
}
function getdigits(x) {
    return String(x).split('').map(Number)
}
function findCommonFactors(args) {
    let common_factors = [1]
    let min_val = Math.min(...args)
    for (let fx = 2; fx <= min_val; fx++)
        if (args.every((arg) => (arg / fx) % 1 === 0))
            common_factors.push(fx)
    return common_factors
}
function listify(items) {
    if (items.length == 2) {
        return items.join(' and ')
    }
    return (
        items.slice(0, -1).join(', ') +
        ', and ' +
        items.slice(-1)
    )
}
function numbersort(arr) {
    arr.sort((a, b) => a - b)
    return arr
}
function dictgetter(dict, key, level) {
    if (!level) level = 0
    const items = dict[key]
    if (!items) {
        console.log(key)
        throw 'not here'
    }
    const ref = items[level]
    return isArray(ref) ? randomPick(ref) : ref
}

function spreadout(fn, args) {
    return isArray(args) ? fn(...args) : fn(args)
}

function roundStudentLevel(level) {
    switch (level) {
        case 4:
        case 5:
        case 6:
            return 1
        case 7:
        case 8:
        case 9:
            return 2
        default:
            return 0
    }
}
function rangegetter(levels, studentLevel) {
    const ref = isString(levels)
        ? NUMBER_RANGES[levels]
        : levels
    const level =
        ref[studentLevel] == null
            ? ref[ref.length - 1]
            : ref[studentLevel]
    return level.length == 2
        ? level
        : paired(level).map((x) => rng(...x))
}

function mathTruncate(answer, degree) {
    // given shit ... and it was just taken.
    s = answer.toString()
    //console.log(s, 's')
    // truncation is actually kind of important
    let match = search(/(^.*?\.0+)(.+)/, s)
    if (match) {
        let [a, b] = match
        return a + b.slice(0, 2)
    } else {
        return isDecimal(answer)
            ? answer.toFixed(2).replace(/0+$/, '')
            : answer
    }
}

function divided(a, b) {
    return mathTruncate(a / b)
}

function modifyNumbersInTemplate(s) {
    //convertify
    const store = []
    const value = s.replace(/\d+/g, (x) => {
        const p = rngAround(Number(x))
        store.push(p)
        return p
    })
    return [value, store]
}

function stringmathlist(a) {
    console.log(a, type(a))
    sorted(a, identity)
    const comma = a.length > 2 ? ',' : ''
    let x =
        a.slice(0, -1).join(', ') +
        comma +
        ' and ' +
        a.slice(-1)
    return x
}
function isCommonError(e) {
    const name = e.constructor.name
    if (name == 'Error') throw 'my error'
    const names = ['SyntaxError', 'ReferenceError']
    return names.includes(name)
}

function isNumericalStringFraction(s) {
    return isString(s) && test(/^\d+\/\d+$/, s)
}

function changeAnswer(n, i, index) {
    function changeNumber(n) {
        let number = parseInt(n)
        let increment

        if (number < 10 || isPrime(number)) {
            increment = 1
        } else {
            for (let i of [
                1000, 100, 10, 9, 8, 7, 6, 5, 4, 3,
            ]) {
                if (number % i == 0) {
                    if (number - index * i <= 0) {
                        increment = Math.floor(i / 2)
                        if (number - index * increment <= 0) {
                            increment = Math.floor(i / 4)
                        }
                    } else {
                        increment = i
                    }
                    break
                }
            }
        }
        return number + (i - index) * increment
    }
    function changeDecimal(n) {
        if (/^0\./.test(n)) {
            return fixFloatingPoint(n * Math.pow(10, i - index))
        }
        let [front, decimal] = search(/(\d+)\.(\d+)/, String(n))
        let base = Math.pow(10, decimal.length - 1)
        let number = rng(base - 1, 1 + base * 10)
        return rngAround(front) + '.' + number
    }
    function changeFraction(n) {
        let [a, b] = parseArithmetic(n)
        if (a == 1) {
            return toFraction(a + i, b + i)
        }
        a += rng(1, rngAround(a))
        b += rng(1, rngAround(b))
        return toFraction(a, b)
    }

    if (isFraction(n)) {
        return changeFraction(n)
    }

    if (hasDecimal(n)) {
        return changeDecimal(n)
    }
    return changeNumber(n)
}

function getItems(input) {
    if (isArray(input)) {
        return input
    }

    const text = removeComments(read(input)).trim()

    if (test(/###/, text)) {
        return text
            .split(/\n*###\n*/g)
            .filter(String)
            .map(createQuestionObject)
    }

    if (test(/\?\n.*?\?(?:\n|$)/, text)) {
        return text
            .split(/\n+/g)
            .filter(String)
            .map((item) => {
                return {
                    question: item,
                    type: 'wordsolver',
                }
            })
    }

    if (true) {
        return text
            .split(/\n\n+/g)
            .filter(String)
            .map((item) => {
                const [question, answer] = item
                    .split('\n')
                    .map(trimmed)
                return {
                    question,
                    answer,
                    type: 'default',
                }
            })
    }
}

const mathtranslationlib = {
    'times more than': 'translation',
    'times less than': 'translation',
}

function studentgetter(name) {
    return {
        name,
    }
}

function removeNonLetters(s) {
    return s.replace(/[^a-zA-Z]/g, '')
}

function randomXDigitNumber(digits) {
    let base = Math.pow(10, digits - 1)
    let next = base * 10
    let a = base + 1
    let b = next - 1
    return rng(a, b)
}

function Counter() {
    let count = 0
    return (arg) => {
        console.log(count)
        count++
        if (count == 3) {
            br()
            console.log(arg)
            br()
            throw ''
        }
    }
}
function br() {
    console.log('-'.repeat(20))
}
function getprimefactorization(n) {
    return getfactors(n).join(' * ')
}
function notPrime(n) {
    return !isPrime(n)
}
const weekdays = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
]

function rngAround(n) {
    function runner(n) {
        n = Number(n)
        if (n < 5) return rng(2, 5)
        if (n < 10) return rng(6, 13)
        if (n < 20) return rng(15, 30)
        if (n < 100) return rng(n - 10, n + 10)
        if (n < 200) return rng(n - 50, n + 50)
        if (n < 300) return rng(n - 75, n + 75)
        if (n < 500) return rng(n - 100, n + 100)
        if (n < 1000) return rng(n - 250, n + 250)
        if (n < 1500) return rng(n - 300, n + 300)
        let x = percentOf(n, 0.1)
        return rng(n - x, n + x)
    }
    let value = runner(n)
    return hasDecimal(n) ? value + addRandomDecimals(n) : value
}

function addRandomDecimals(n) {
    console.log('adding random decimals')
    let length = getDecimalLength(n)
    let range = [length, length - 1].map(power10)
    return '.' + rng(...range)
}

function power10(n) {
    return Math.pow(10, n)
}

function getDecimalLength(n) {
    return search(/\.(.+)/, n).length || 0
}
const ambiguousNames = [
    'casey',
    'jamie',
    'lee',
    'jaime',
    'jessie',
    'morgan',
    'rene',
    'robin',
    'devon',
    'kerry',
    'alexis',
    'guadalupe',
    'blair',
    'kasey',
    'jean',
    'marion',
    'aubrey',
    'shelby',
    'jan',
    'shea',
    'jade',
    'kenyatta',
    'kelsey',
    'shay',
    'lashawn',
    'trinity',
    'regan',
    'jammie',
    'cassidy',
    'cheyenne',
    'reagan',
    'shiloh',
    'marlo',
    'andra',
    'devan',
    'rosario',
    'lee',
]

function fixEvalArguments(s) {
    return s.replace(/(?<=\().*?(?=\)$)/, (x) => {
        //return x.replace(/.*?(?=, *|$
    })
}
function prepareForEval(x) {
    if (isNumber(x)) {
        return x
    }
    if (isObjectLike(x)) {
        return x
    }
    return quotify(x)
}

function isObjectLike(x) {
    return test(/^[\[\{]/, x)
}

const maleNames = {
    wil: 'liam,lie,lard,lis,liams,bur,son,bert,fred,fredo',
    fre: 'd,derick,ddie,drick,ddy',
    mar: 'cus,co,cos,cel,k,tin,vin,io,shall,ty,lon,lin',
    dar: 'rell,ryl,ren,rel,rin,yl,in,nell,win,ius',
    fra: 'nk,ncis,ncisco,nklin,nkie',
    ter: 'ry,rance,rence,rell,ence',
    ran: 'dy,dall,dolph,dal',
    bra: 'dley,dford,dy,ndon,in',
    jef: 'frey,fery,fry',
    joh: 'n,nny,nnie,nathan',
    gre: 'gory,gg,gorio',
    car: 'l,los,lton,roll,y,ey',
    ken: 'neth,t,ny,dall,drick',
    har: 'old,ry,vey,ley,lan,rison',
    ste: 'ven,phen,ve,wart,phan,rling',
    jer: 'ry,emy,ome,emiah,maine,ald',
    mic: 'hael,heal,ah,key,hel',
    dan: 'iel,ny,e',
    ric: 'hard,ky,ardo,k,key',
    cli: 'fford,nton,fton,nt,ff',
    cla: 'rence,ude,yton,rk,y',
    ben: 'jamin,nie,ny,ito',
    rod: 'ney,erick,olfo,ger',
    rob: 'ert,erto,bie',
    gar: 'y,ry,rett,land',
    sam: 'uel,my,mie',
    and: 'rew,re,y,res',
    jos: 'eph,e,hua,h',
    joe: 'l,y,sph',
    leo: 'nard,n,nardo',
    tom: 'my,as,mie',
    bry: 'an,ant,ce,on',
    ant: 'hony,onio,oine,on',
    jac: 'k,ob,kson',
    cha: 'rles,d,rlie,se',
    sha: 'wn,ne,un',
    bre: 'nt,tt,ndan,t',
    jes: 'se,us,s',
    alb: 'ert,erto',
    ala: 'n',
    all: 'en,an',
    alf: 'red,redo,onso',
    ale: 'xander,x,jandro',
    alv: 'in,aro',
    alt: 'on',
    alo: 'nzo',
    ron: 'ald,nie',
    rog: 'er,elio',
    rol: 'and,ando',
    ros: 's,coe',
    roo: 'sevelt',
    rom: 'an',
    roc: 'ky',
    roy: 'ce',
    ror: 'y',
    den: 'nis,is',
    der: 'ek,rick',
    dea: 'n',
    del: 'bert',
    dev: 'in',
    dew: 'ey,ayne',
    dex: 'ter',
    dem: 'etrius',
    des: 'mond',
    jam: 'es,al',
    jas: 'on,per',
    jar: 'ed,rod',
    jav: 'ier',
    jak: 'e',
    elm: 'er',
    ell: 'is,iot,iott',
    elb: 'ert',
    eli: 'as,jah',
    eld: 'on',
    elt: 'on',
    elv: 'in',
    elw: 'ood',
    mat: 'thew,hew,t',
    man: 'uel',
    mau: 'rice',
    mal: 'colm',
    mac: 'k',
    mas: 'on',
    don: 'ald,nie',
    dou: 'glas,g',
    dom: 'inic,ingo,inick',
    doy: 'le',
    eri: 'c,k,ck',
    ern: 'est,esto,ie',
    erv: 'in',
    erw: 'in',
    ray: 'mond',
    ral: 'ph',
    ram: 'on,iro',
    raf: 'ael',
    rau: 'l',
    rap: 'hael',
    edw: 'ard,in',
    edd: 'ie',
    edg: 'ar',
    edu: 'ardo',
    edm: 'und,ond',
    cor: 'ey,y,nelius',
    cod: 'y',
    col: 'in',
    con: 'rad',
    ler: 'oy',
    lew: 'is',
    les: 'ter',
    lel: 'and',
    lev: 'i',
    lou: 'is,ie',
    lon: 'nie',
    lor: 'enzo,en',
    low: 'ell',
    log: 'an',
    dav: 'id,e',
    dal: 'e,las',
    dam: 'on,ian,ien',
    jon: 'athan,athon',
    jor: 'ge,dan',
    joa: 'quin',
    rus: 'sell,sel,ty',
    rub: 'en',
    rud: 'olph,y',
    ruf: 'us',
    kev: 'in',
    kei: 'th',
    kel: 'vin',
    ker: 'mit',
    art: 'hur,uro',
    arn: 'old',
    arm: 'ando,and',
    arc: 'hie',
    reg: 'inald,gie',
    rey: 'naldo',
    reu: 'ben',
    geo: 'rge,ffrey',
    ger: 'ald,ard,ardo',
    gen: 'e',
    lar: 'ry',
    law: 'rence',
    lan: 'ce',
    lau: 'rence',
    lam: 'ar,ont',
    mor: 'ris',
    mos: 'es',
    mon: 'te,ty',
    moi: 'ses',
    jua: 'n',
    jus: 'tin',
    jul: 'io,ian,ius',
    jun: 'ior',
    pet: 'er,e',
    ped: 'ro',
    per: 'ry,cy',
    tra: 'vis',
    tro: 'y',
    tre: 'vor,nt',
    hen: 'ry',
    her: 'bert,man',
    hec: 'tor',
    hea: 'th',
    nor: 'man,bert',
    noe: 'l',
    noa: 'h',
    nol: 'an',
    ema: 'nuel',
    emi: 'l,lio',
    emm: 'ett,anuel',
    wal: 'ter,lace',
    way: 'ne',
    war: 'ren',
    wad: 'e',
    mik: 'e',
    mig: 'uel',
    mil: 'ton,es',
    mit: 'chell',
    sal: 'vador,vatore',
    san: 'tiago,tos',
    sau: 'l',
    chr: 'istopher,is,istian',
    che: 'ster',
    chu: 'ck',
    pau: 'l',
    pat: 'rick',
    pab: 'lo',
    sta: 'nley,n',
    stu: 'art',
    hug: 'h,o',
    hub: 'ert',
    hum: 'berto',
    bri: 'an',
    bru: 'ce',
    vic: 'tor,ente',
    vin: 'cent',
    vir: 'gil',
    cal: 'vin,eb',
    cam: 'eron',
    gui: 'llermo',
    gus: 'tavo',
    lui: 's',
    lut: 'her',
    luk: 'e',
    luc: 'as',
    gra: 'nt,dy,ham',
    gro: 'ver',
    nei: 'l',
    nel: 'son',
    nea: 'l',
    tho: 'mas',
    tim: 'othy,my',
    tod: 'd',
    ton: 'y',
    the: 'odore',
    tyl: 'er',
    tyr: 'one',
    tay: 'lor',
    tob: 'y',
    ted: 'dy',
    tys: 'on',
    sco: 'tt,tty',
    sea: 'n',
    sid: 'ney',
    ser: 'gio',
    set: 'h',
    spe: 'ncer',
    she: 'rman,ldon',
    syl: 'vester',
    sim: 'on',
    sol: 'omon',
    rya: 'n',
    nic: 'holas,k,olas',
    nat: 'han,haniel',
    ada: 'm',
    aar: 'on',
    adr: 'ian',
    aus: 'tin',
    ang: 'elo',
    abr: 'aham',
    amo: 's',
    abe: 'l',
    agu: 'stin',
    aug: 'ust',
    ado: 'lfo',
    bil: 'ly,l,lie',
    bob: 'by',
    bar: 'ry,t',
    ber: 'nard,t',
    byr: 'on',
    bla: 'ke,ine',
    boy: 'd',
    bud: 'dy',
    bur: 'ton',
    eug: 'ene',
    ear: 'l,nest',
    eve: 'rett',
    enr: 'ique',
    eva: 'n',
    efr: 'ain',
    eth: 'an',
    est: 'eban',
    how: 'ard',
    hom: 'er',
    hor: 'ace',
    han: 's',
    phi: 'llip,lip,l',
    pre: 'ston',
    pie: 'rre',
    cra: 'ig',
    cur: 'tis,t',
    cly: 'de',
    cec: 'il',
    ces: 'ar',
    ced: 'ric',
    cle: 'veland',
    jim: 'my,mie',
    gle: 'nn,n',
    gor: 'don',
    gil: 'bert,berto',
    gab: 'riel',
    mel: 'vin',
    myr: 'on',
    mer: 'le',
    mur: 'ray',
    kyl: 'e',
    kar: 'l',
    kur: 't',
    kir: 'k',
    kri: 'stopher',
    osc: 'ar',
    oti: 's',
    oli: 'ver',
    orl: 'ando',
    oma: 'r',
    owe: 'n',
    orv: 'ille',
    ott: 'o',
    llo: 'yd',
    lyl: 'e',
    lio: 'nel',
    flo: 'yd',
    fer: 'nando',
    fel: 'ix,ipe',
    for: 'rest',
    fab: 'ian',
    fid: 'el',
    wes: 'ley',
    wen: 'dell',
    woo: 'drow',
    win: 'ston',
    dus: 'tin',
    dua: 'ne',
    dwa: 'yne',
    dwi: 'ght',
    dre: 'w',
    dyl: 'an',
    zac: 'hary',
    ver: 'non',
    van: 'ce',
    iva: 'n',
    isa: 'ac',
    irv: 'ing,in',
    ism: 'ael',
    ign: 'acio',
    que: 'ntin',
    qui: 'nton',
    xav: 'ier',
}

const femaleNames = {
    mar: 'ia,ie,ilyn,ian,ianne,ina,issa,ibel,isa,isol,itza,garet,gie,garita,guerite,gret,go,y,tha,jorie,cia,lene,sha,yann,cella,ta,la,cy,tina',
    klo: 'e',
    kri: 'sten,stin,stina,sti,stine,sty,sta,stie',
    jea: 'nette,nne,nnette,nnie,nine,nnine',
    chr: 'istine,istina,isty,istie,ista,isti',
    ang: 'ela,elica,elina,elia,eline,ie',
    fra: 'nces,ncine,ncisca',
    kat: 'hleen,herine,hy,hryn,harine,ie,rina,e',
    she: 'rry,rri,ryl,ri,rrie,lly,lley,lia,ila,ena',
    car: 'ol,olyn,oline,ole,olina,men,rie,la,a,mela',
    dia: 'ne,na,nne,nna',
    jen: 'nifer,nie,ny,na,ifer',
    luc: 'ille,ia,inda,ile,y',
    kel: 'ly,li,ley,lie',
    ros: 'a,alie,alind,emary,emarie,etta,ie',
    jan: 'ice,ie,is,ine,et,elle,ette,a',
    sta: 'cy,cey,cie,ci',
    lau: 'ra,ren,rie,rel',
    tra: 'cy,cey,ci,cie',
    bet: 'ty,tie,te,tye,h,hany,sy',
    joa: 'n,nne,nn,nna',
    lor: 'i,raine,etta,a,ena,ene,na,ie',
    sha: 'ron,nnon,ri,wna,nna,na,una',
    dor: 'othy,is,a,een,thy,othea',
    cla: 'ra,udia,ire,rice,udette',
    eli: 'zabeth,sa,sabeth,se,za',
    kar: 'en,la,a,i,in',
    tam: 'my,ara,i,mie,ika',
    ann: 'a,e,ie,ette',
    mel: 'issa,anie,inda',
    ali: 'ce,cia,son,sha,sa',
    bri: 'ttany,dget,ttney,dgette',
    lyn: 'n,da,ne,ette',
    del: 'ores,la,ia,oris',
    ter: 'esa,ri,i',
    son: 'ia,ya,ja,dra',
    deb: 'orah,ra,bie,ora',
    jac: 'queline,kie,quelyn,lyn',
    lat: 'oya,asha,onya,isha',
    che: 'ryl,lsea,ri,rie',
    vic: 'toria,ki,kie,ky',
    sus: 'an,ie,anne,ana',
    rob: 'erta,yn',
    est: 'her,elle,ella,er',
    lea: 'h,nne,nn',
    lil: 'lian,lie,a,y',
    mau: 'reen,de',
    mat: 'tie,ilda',
    max: 'ine',
    mab: 'el,le',
    mad: 'eline',
    mag: 'gie,dalena',
    mam: 'ie',
    man: 'dy,uela',
    may: 'ra',
    mav: 'is',
    joy: 'ce',
    jos: 'ephine,efina,ie',
    jod: 'i,y,ie',
    joh: 'anna',
    joc: 'elyn',
    jol: 'ene',
    jon: 'i',
    bev: 'erly',
    ber: 'tha,nice,nadette',
    bea: 'trice,triz',
    bes: 'sie',
    bec: 'ky',
    bel: 'inda',
    beu: 'lah',
    cat: 'herine,hy,hleen',
    cas: 'sandra,sie',
    can: 'dace,dice',
    cam: 'ille',
    cai: 'tlin',
    cal: 'lie',
    les: 'lie,ley',
    len: 'a,ora',
    leo: 'na,la',
    let: 'icia',
    lei: 'gh,la',
    lel: 'a',
    ela: 'ine',
    ell: 'en,a',
    ele: 'anor,na',
    els: 'ie,a',
    elo: 'ise',
    elv: 'ira,a',
    elm: 'a',
    san: 'dra,dy',
    sar: 'ah,a',
    sal: 'ly,lie',
    sam: 'antha',
    sab: 'rina',
    sad: 'ie',
    mic: 'helle,hele',
    mil: 'dred,lie',
    min: 'nie,dy',
    mir: 'iam,anda',
    mis: 'ty',
    con: 'nie,stance,suelo',
    col: 'leen',
    cou: 'rtney',
    cor: 'a,inne,nelia',
    jul: 'ie,ia',
    jud: 'ith,y',
    jua: 'nita,na',
    jus: 'tine',
    daw: 'n',
    dan: 'ielle,a',
    dar: 'lene,la',
    dai: 'sy',
    dap: 'hne',
    reb: 'ecca,ekah,a',
    ren: 'ee,a',
    alm: 'a',
    all: 'ison',
    alb: 'erta',
    ale: 'xandra',
    aly: 'ssa',
    alt: 'a',
    rac: 'hel,hael,helle',
    ram: 'ona',
    raq: 'uel',
    and: 'rea',
    ani: 'ta',
    ant: 'oinette,onia',
    ger: 'aldine,trude',
    geo: 'rgia,rgina',
    gen: 'evieve',
    den: 'ise,a',
    dea: 'nna,na',
    des: 'iree',
    jas: 'mine',
    jay: 'ne',
    lul: 'a',
    lup: 'e',
    lue: 'lla',
    lui: 'sa',
    jes: 'sica',
    jew: 'ell',
    jer: 'i',
    adr: 'ienne,iana',
    add: 'ie',
    ade: 'le,line',
    pat: 'ricia,sy,ty,ti,rice,rica',
    pam: 'ela',
    pau: 'la,line,lette',
    pai: 'ge',
    ken: 'dra',
    ker: 'ri,i',
    kei: 'sha',
    mon: 'ica,ique,a',
    mol: 'ly,lie',
    lou: 'ise',
    loi: 's',
    lol: 'a',
    hel: 'en,ene,ena',
    hea: 'ther',
    hei: 'di',
    hen: 'rietta',
    meg: 'an,han',
    mer: 'cedes,edith',
    mea: 'gan',
    wil: 'ma,la',
    win: 'nie',
    gai: 'l',
    gay: 'le',
    gab: 'riela,rielle',
    gal: 'e',
    eri: 'n,ca,ka',
    erm: 'a',
    ern: 'estine',
    cec: 'ilia,elia,ile',
    cel: 'ia,este',
    kay: 'la,lee',
    olg: 'a',
    oli: 'via',
    oll: 'ie',
    lin: 'da,dsay,dsey',
    lis: 'a',
    liz: 'zie',
    nan: 'cy',
    nat: 'alie,asha',
    nao: 'mi',
    nad: 'ine',
    lav: 'erne',
    lan: 'a',
    lad: 'onna',
    lar: 'a',
    vir: 'ginia',
    viv: 'ian',
    vio: 'la',
    har: 'riet',
    han: 'nah',
    peg: 'gy',
    pea: 'rl',
    pen: 'ny',
    pet: 'ra',
    bre: 'nda',
    bra: 'ndi',
    bro: 'oke',
    kim: 'berly,berley',
    kir: 'sten',
    aud: 'rey,ra',
    aut: 'umn',
    bon: 'nie,ita',
    bob: 'bie,bi',
    don: 'na',
    dol: 'ores,ly',
    dom: 'inique',
    glo: 'ria',
    gla: 'dys',
    gle: 'nda,nna',
    tri: 'cia,na,sha',
    tru: 'dy',
    tar: 'a',
    tan: 'ya',
    tas: 'ha',
    tab: 'itha',
    rox: 'anne',
    roc: 'helle',
    ron: 'da',
    ama: 'nda',
    amb: 'er',
    ame: 'lia',
    fay: 'e',
    fan: 'nie',
    nic: 'ole,hole',
    nin: 'a',
    nik: 'ki',
    ver: 'onica,a,na',
    vel: 'ma',
    gra: 'ce,ciela,cie',
    gre: 'tchen',
    bar: 'bara,bra',
    bla: 'nca',
    bia: 'nca',
    rut: 'h',
    rit: 'a',
    rho: 'nda',
    shi: 'rley',
    ste: 'phanie,lla,fanie',
    syl: 'via',
    suz: 'anne',
    sop: 'hia,hie',
    sil: 'via',
    sum: 'mer',
    sel: 'ma',
    soc: 'orro',
    syb: 'il',
    sim: 'one',
    cyn: 'thia',
    cry: 'stal',
    cin: 'dy',
    cha: 'rlene',
    cri: 'stina',
    cle: 'o',
    eve: 'lyn',
    emi: 'ly',
    edn: 'a',
    edi: 'th',
    eth: 'el',
    emm: 'a',
    eil: 'een',
    eun: 'ice',
    eul: 'a',
    ess: 'ie',
    eff: 'ie',
    ett: 'a',
    eug: 'enia',
    ash: 'ley',
    apr: 'il',
    agn: 'es',
    arl: 'ene',
    aim: 'ee',
    abi: 'gail',
    aid: 'a',
    abb: 'y',
    ail: 'een',
    the: 'resa,lma,rese',
    tin: 'a',
    tif: 'fany',
    ton: 'ya,i,ia',
    ire: 'ne',
    irm: 'a',
    isa: 'bel,belle',
    ine: 'z',
    ing: 'rid',
    imo: 'gene',
    wan: 'da',
    wen: 'dy',
    whi: 'tney',
    phy: 'llis',
    pri: 'scilla',
    pol: 'ly',
    nor: 'ma,a',
    nel: 'lie,l',
    net: 'tie',
    flo: 'rence,ra',
    fel: 'icia',
    fre: 'da',
    fer: 'n',
    fri: 'eda',
    val: 'erie',
    van: 'essa',
    jil: 'l,lian',
    yvo: 'nne',
    yol: 'anda',
    yve: 'tte',
    gin: 'a',
    gwe: 'ndolyn,n',
    gol: 'die',
    lyd: 'ia',
    myr: 'tle,a,na',
    mur: 'iel',
    hil: 'da',
    opa: 'l',
    ofe: 'lia',
    kry: 'stal',
    dix: 'ie',
    din: 'a',
    urs: 'ula',
}

function usefulRemergeNames(names) {
    let keys = Object.keys(names)
    let l = keys.length
    let store = new SimpleStorage()
    for (let i = 0; i < l; i++) {
        const arr = names[keys[i]].split(/,+/)
        for (let i2 = 0; i2 < arr.length; i2++) {
            let name = keys[i] + arr[i2]
            let [a, b] = slicesplit(name, 3)
            store.add(a, b)
        }
    }

    editDict(store.store, (x) => x.join(','))
    return store.store
}

const studentfacts = [
    {
        student: 'Kloe',
        interest: 'mathematics',
        food: ['avocado', 'sushi'],
    },
    { student: 'Aaron', interest: 'basketball', food: 'sushi' },
    {
        student: 'Kaylee',
        interest: 'candle-making',
        food: 'donuts',
    },
    { student: 'Elina', interest: 'cat', food: 'icecream' },
    { student: 'Lynn', interest: 'running', food: 'sushi' },
    { student: 'Danny', interest: 'scooter', food: 'sushi' },
].map((x) => ({
    ...x,
    ['interests']: { sport: [x.interest, x.food] },
}))

const foodNames = ['apples', 'bananas']
const locations = [
    'Hawaii',
    'California',
    'Sunset Park',
    'New York',
    'Tokyo',
]
const holidays = ['Mid-Autumn Mooncake Festival', 'Christmas']
const animalNouns = ['dogs', 'cats', 'pigs', 'chickens']
const foodNouns = ['cakes', 'donuts', 'donuts', 'donuts']
const nouns = [...animalNouns, ...foodNouns]

const itemadjectiveconnectorlib = {
    food: ['sushi', 'avocado', 'icecream', 'donut'],
}
const verbfoodconnectorlib = {
    delicate: ['sushi'],
    grow: ['avocado'],
    bakery: ['donut'],
}
const verblib = {
    delicate: ['create', 'handcraft', 'pull out of thin air'],
    grow: ['grow', 'farm', 'produce'],
    bakery: ['bake', 'farm', 'forge over a hot fire'],
}

const BIGLIB = {
    animal: animalNouns,
    holiday: holidays,
    sport: [
        'basketball',
        'soccer',
        'baseball',
        'golf',
        'football',
        'soap-making',
    ],
    food: foodNames,
    location: locations,
    holiday: holidays,
}

const wordnetdict = {
    golf: {
        league: ['association', 'club'],
        player: ['member'],
    },
    'soap-making': {
        league: 'class',
        player: 'student',
        team: 'group',
    },

    'icecream-making': {
        league: 'club',
        player: 'chefs',
    },
}

var IRREGULAR_PAST_TENSE_VERBS = {
    were: 'are',
    ate: 'eat',
    went: 'go',
    had: 'have',
    inherited: 'inherit',
    was: 'is',
    ran: 'run',
    sat: 'sit',
    visited: 'visit',
    edited: 'edit',
}

function isPastTense(s) {
    return (
        IRREGULAR_PAST_TENSE_VERBS.hasOwnProperty(s) ||
        test(/[det]$/, s)
    )
}

function replaceAdverb(s) {
    let base = nlp(s)
    let adj = base.adjectives().text()
    let adverb = base.verbs().adverbs().text()
    let items = [adj, adverb]

    for (let item of items) {
        let replacement = getSynonym(item)
        s = replace(item, replacement, s, '')
    }
    return s
}

function stepwise(i, boundary) {
    return i
}

class Verb {
    constructor(s) {
        ;[this.s, this.tense] = getVerbAndTense(s)
    }
}

const studentlib = {
    Kloe: {
        words: {
            sport: 'mathematics',
        },
        blurbs: {
            sport: 'Prepare yourself everyone! It is time to math!',
        },
    },

    Elina: {
        words: {
            sport: ['cat-watching', 'icecream'],
        },
        blurbs: {
            sport: {
                'cat-watching':
                    'Everybody! No walking! Run to the stars!',
                icecream:
                    'Everybody! No walking! Run to the stars!',
            },
        },
    },

    Kaylee: {
        words: {
            sport: ['soap-making', 'donut'],
        },
        blurbs: {
            sport: 'Everybody! No walking! Run to the stars!',
        },
    },

    Aaron: {
        words: {
            sport: 'basketball',
        },
        blurbs: {
            sport: 'Everybody! No walking! Run to the stars!',
        },
    },

    Danny: {
        words: {
            sport: 'scooter',
        },
        blurbs: {
            sport: 'Everybody! No walking! Run to the stars!',
        },
    },

    Kaylee: {
        words: {
            sport: 'soap-making',
        },
        blurbs: {
            sport: 'Everybody! No walking! Run to the stars!',
        },
    },

    Lynn: {
        words: {
            sport: 'running',
        },
        blurbs: {
            sport: 'Everybody! No walking! Run to the stars!',
        },
    },
}

class MathWorksheet2 {
    constructor(questions, student) {
        this.load('questions', questions)
        this.load('template', student)
        // The questions will be filtered based on difficulty
        // The number range will also be filtered on difficulty
        //worksheet.load('questions', $questions)
        //worksheet.load('template', 'Mooncake')
        //worksheet.create()
    }
    load(key, value) {
        if (key) this[key] = value
    }

    run() {
        let type = MathWorksheet2.getMakerType(
            this.questions[0]
        )
        switch (type) {
            case 'standard':
                return this.runStandard()
            case 'z':
                return this.runZ()
        }
    }

    get value() {
        //return this.questions.map({question, answer} => this.maker(question, answer, this.letter)
    }

    static getMakerType(question) {
        if (isObject(question)) {
            if (
                question.question &&
                question.answer &&
                !question.choices
            ) {
                return 'standard'
            }
        }
    }
    //
}
function incrementUntil(x, condition) {
    while (true) {
        counter(100)
        if (condition(x)) {
            return x
        } else {
            x += 1
        }
    }
}

function usefulRangeFromLetter(s) {
    const dict = {
        a: [3, 10],
        b: [3, 10],
        c: [3, 10],
        m: [50, 100],
        '': [50, 100],
    }
    return dict[s] || dict['']

    let range
    switch (s) {
        case 'a':
        case 'b':
        case 'c':
            range = [3, 10]
            break
        case 's':
            range = [1, 10]
            break
        case 'm':
            range = [50, 100]
            break
        case 'l':
            range = [100, 200]
            break
        case 'l':
            range = [1, 10]
            break
        default:
            range = [50, 100]
    }
    return range
}

function hasLetter(s) {
    return test(/[a-zA-Z]/, s)
}

function makeNumber(...args) {
    return shuffle(permute(args))[0].join('')
}
function permute(arr) {
    const store = []

    function runner(len) {
        if (len === 1) store.push(arr.slice(0))
        for (let i = 0; i < len; i++) {
            runner(len - 1)
            len % 2
                ? ([arr[0], arr[len - 1]] = [
                      arr[len - 1],
                      arr[0],
                  ])
                : ([arr[i], arr[len - 1]] = [
                      arr[len - 1],
                      arr[i],
                  ])
        }
    }

    runner(arr.length)
    return store
}
function getTextItemsAt(n, s, mode = Number) {
    let part
    if (mode == Number) part = '-?\\d+(?:\\.\\d+)?'
    let regex = '^.*?'
    for (let i = 0; i < n; i++) {
        if (i == n - 1) {
            regex += parens(part)
        } else {
            regex += part + '.*?'
        }
    }
    return findall(regex, s, 'gm').map(toNumber)
}

function getAllShared(a, b) {
    const store = []
    for (let i = 0; i < b.length; i++) {
        if (a.includes(b[i])) store.push(pop(a, b[i]))
    }
    return store
}

function multiply(...args) {
    return args.reduce((acc, n) => {
        return acc * n
    }, 1)
}

function getMostCommonlyShared(a, b) {
    for (let i = 0; i < a.length; i++) {
        for (let j = 0; j < b.length; j++) {}
    }
}
function infiniterange(fn) {
    let infinity = 100
    for (let i = 0; i < infinity; i++) {
        if (fn(i)) return i
    }
    return 0
}

function mathTransmutation(s) {
    //convertify
}

const mathmakerquestions = [
    {
        question:
            'On a test, $name scores $m points out of $n. What is his score percentage?',
        answer: '${100 * $1/$2}%',
    },

    {
        question:
            "$name only eats $food dumplings. $name's mom buys a box of $m dumplings and $name eats $n of them. What percentage of the box was NOT $food?",
        answer: '${100 * (($1 - $2) / $1)}%',
    },

    {
        //question: '$1 boys and $2 girls are in a class. After a certain number of girls leave, the percentage of girls in the class is now $3%. How many girls left?',
        //numbers(answer) {
        //let c = rng(answer * 2, 100, null, 10)
        //}
    },

    {
        question:
            'Every day, $name gives away $RNG(40, 90)% of her flowers. At the end of the $ordinal(3,5) day, $name only has $a flowers left. How many flowers did she start with?',
        answer: '${$3 * (100/$1)^$2}',
        tag: 'percent2',
    },
    {
        question:
            '$x% of A is $x. $x% of B is $x. What is A + B?',
        answer: '${($2 / ($1/100)) + ($4 / ($3/100))}',
        difficulty: 1,
        // has decimals still
    },

    {
        question: 'What percent of $rng(20,100) is $rng(5,15)?',
        answer: '${100*($2/$1)}%',
        difficulty: 1,
    },

    {
        question:
            'After a $y% discount, the new price of cake is $y dollars. What was the original price?',
        answer: '${$2 * (100/(100 - $1))} dollars',
    },

    {
        question:
            '$name has $a apples, $b bananas, and $c oranges. What percentage of his fruits are apples?',
        answer: '${$1/($1+$2+$3) * 100}%',
    },

    {
        question:
            '$name has $a apples, $b bananas, and $c oranges. What ratio of his fruits are oranges?',
        answer: '${toRatio($3, $1 + $2)}',
    },

    {
        question: '$a/$b is equivalent to what percentage?',
        answer: '${100 * $1/$2}%',
    },

    {
        question:
            'What is $RNG(0, 85)% more than $RNG(0, 70)% less than $RNG(0, 400)?',
        answer: '${($1 + 100) * (100 - $2) * $3 / 10000}',
    },

    {
        question:
            'What is $RNG(0, 85)% of $RNG(1, 70)% of $RNG(0, 100)?',
        answer: '${$1 * $2 * $3 / 10000}',
    },

    {
        question:
            'x percent less than $RNG(0, 85) equals ${$1 * (1 - 0.1 * $rng(2,10))}. What is x?',
        answer: '${100 * ($1 - $2) / $1}%',
    },

    {
        question:
            'x percent more than $RNG(0, 85) equals ${$1 * $rng(2,10)}. What is x?',
        answer: '${100 * ($2 - $1) / $1}%',
    },

    {
        question:
            "Each side of a square is increased by $RNG(0, 60, 10)%. By what percent does the square's area increase?",
        answer: '${(($1 + 100)/100)^2 * 100 - 100}%',
        difficulty: 3,
    },

    {
        question:
            'A square has an perimeter of $pick(16, 64, 100). Each side of the square is now increased by $pick(50, 100, 200, 300, 400)%. What is the new area of the square?',
        answer: '${(($1*0.25 * (1 + $2/100))^2)}',
        tag: 'percent2',
    },

    {
        question:
            'A square has an area of $pick(16, 64, 100). Each side of the square is now increased by $pick(50, 100, 200, 300, 400)%. What is the new area of the square?',
        answer: '${(($1^0.5 * (1 + $2/100))^2)}',
        tag: 'percent2',
    },
]

function sumBy(n, numbers) {
    const store = []
    for (let i = 1; i < n; i++) {
        store.push([i, n - i])
    }
    return store
}
function countinclusive(a, b) {
    return Math.abs(a - b) + 1
}
function createArgsForQuestion(s, regex = numberRE) {
    //convert
    //if (test(/\$\w+/, s)) {
    //console.log('already has dollar. early return')
    //return s
    //}
    const numbers = []
    const template = s.replace(regex, (x) => {
        const [A, B] = x > 5 ? [0.75 * x, 1.25 * x] : [2, 9]

        const value = rng(A, B)
        numbers.push(value)
        return value
    })
    return [numbers, template]
}
function countPrimeNumbersBetween(a, b) {
    let count = 0
    for (let i = a; i <= b; i++) {
        if (isPrime(i)) count += 1
    }
    return count
}

function getbiggestprimefactor(n) {
    let primes = getfactors(n).filter(isPrime)
    return primes[primes.length - 1]
}
const commonfractions = [
    [1, 4],
    [1, 6],
    [1, 8],
    [1, 9],
    [1, 10],
    [2, 4],
    [2, 6],
    [2, 8],
    [2, 9],
    [2, 10],
    [3, 4],
    [3, 6],
    [3, 8],
    [3, 9],
    [3, 10],
    [4, 6],
    [4, 8],
    [4, 9],
    [4, 10],
    [5, 6],
    [5, 8],
    [5, 9],
    [5, 10],
    [6, 8],
    [6, 9],
    [6, 10],
    [7, 8],
    [7, 9],
    [7, 10],
    [8, 9],
    [8, 10],
    [9, 10],
]
const niceNumbers = [
    42, 48, 54, 56, 60, 63, 66, 70, 72, 78, 80, 84, 88, 90, 96,
    98, 99,
]

function getfactorpairs(n) {
    if (isPrime(n)) {
        return [[1, n]]
    }
    const store = []
    for (let i = 1; i < Math.sqrt(n); i++) {
        let c = n / i
        let d = Math.floor(c)
        if (c == d) {
            store.push([c, i])
        }
    }
    return store
}

function getallfactors(n) {
    const store = []
    for (let i = 1; i <= n; i++) {
        if (n % i == 0) {
            store.push(i)
        }
    }
    return store
}

function factorOf(n) {
    const factors = []
    let divisor = 2

    while (n >= 2) {
        if (n % divisor == 0) {
            n = n / divisor
            factors.push(n)
        } else {
            divisor++
        }
    }
    return randomPick(factors)
}

function subtractNumberIntoTwo(n) {
    if (n < 2) throw ''
    let b = rng(Math.floor(n / 4), Math.ceil((3 * n) / 4))
    let c = n - b
    return [c, b]
}

function randomfrac() {
    return randomPick(commonfractions)
}

function randommod() {
    return randomPick(commonMods)
}

function largerFirst(arr) {
    console.log(arr)
    arr.sort((a, b) => b - a)
    return arr
}

function subtractALittle(n) {
    let offset = rng(0.25 * n, 0.75 * n)
    return [offset, n - offset]
}

function numberconvertify(s) {
    if (test(/\$\w/, s)) return s
    let count = 1
    return s.replace(numberRE, (x) => {
        return '$' + count++
    })
}

const introducers = ['find', 'how many']
const connectors = [
    'are in',
    'is (?:equivalent|equal) to',
    'equals',
    'is the same as',
    'the number of',
]
const operationTranslationLib = {
    and: '+',
    'subtracted from': (a, b) => b - a,
    'subtracted from': '-',
    'added to': '+',
    'is added to': '+',
    plus: '+',
    'multiplied by': '*',
    'divided by': '/',
    'are in': '=',
    equals: '=',
    'is the same as': '=',
}
const numberRE = /-?\d+(?:\.\d+)?/g
const numberLargeRE = /-?\d\d+(?:\.\d+)?/g
const numberREGEX = /-?\d+(?:\.\d+)?/g
const unitNumberRegex = /\d+ \w+/g
const unitREGEX = /\d+ \w+/g
const unitNumberCRE = /(\d+) (\w+)/g
let tempflag = 0
let __count__ = 0
function counter(n, ...args) {
    //if (!n) n =
    n = 10
    if (__count__++ > n - 10) {
        if (__count__ > n) {
            //console.log(args)
            console.log('error')
            throw 'Surpassed count of ' + n
        }
    }
}

function getUnitPairs(s) {
    const regex = /(\d+) (\w+)/g
    return findall(regex, s)
}

function endsWithNumber(s) {
    return test(/\d+$/, s)
}

function depluralize(s) {
    if (!s.endsWith('s')) return s
    return s.plural(true)
}

function doubletry(a, b) {
    return (...args) => {
        try {
            return a(...args)
        } catch {
            return b(...args)
        }
    }
}

function incrementFrom(key, items) {
    const currentIndex = items.indexOf(key)
    const newIndex = (currentIndex + 1) % items.length
    const p = items[newIndex]
    //console.log(p)
    return p
}

String.prototype.plural = function (revert) {
    var plural = {
        '(quiz)$': '$1zes',
        '^(ox)$': '$1en',
        '([m|l])ouse$': '$1ice',
        '(matr|vert|ind)ix|ex$': '$1ices',
        '(x|ch|ss|sh)$': '$1es',
        '([^aeiouy]|qu)y$': '$1ies',
        '(hive)$': '$1s',
        '(?:([^f])fe|([lr])f)$': '$1$2ves',
        '(shea|lea|loa|thie)f$': '$1ves',
        sis$: 'ses',
        '([ti])um$': '$1a',
        '(tomat|potat|ech|her|vet)o$': '$1oes',
        '(bu)s$': '$1ses',
        '(alias)$': '$1es',
        '(octop)us$': '$1i',
        '(ax|test)is$': '$1es',
        '(us)$': '$1es',
        '([^s]+)$': '$1s',
    }

    var singular = {
        '(quiz)zes$': '$1',
        '(matr)ices$': '$1ix',
        '(vert|ind)ices$': '$1ex',
        '^(ox)en$': '$1',
        '(alias)es$': '$1',
        '(octop|vir)i$': '$1us',
        '(cris|ax|test)es$': '$1is',
        '(shoe)s$': '$1',
        '(o)es$': '$1',
        '(bus)es$': '$1',
        '([m|l])ice$': '$1ouse',
        '(x|ch|ss|sh)es$': '$1',
        '(m)ovies$': '$1ovie',
        '(s)eries$': '$1eries',
        '([^aeiouy]|qu)ies$': '$1y',
        '([lr])ves$': '$1f',
        '(tive)s$': '$1',
        '(hive)s$': '$1',
        '(li|wi|kni)ves$': '$1fe',
        '(shea|loa|lea|thie)ves$': '$1f',
        '(^analy)ses$': '$1sis',
        '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$':
            '$1$2sis',
        '([ti])a$': '$1um',
        '(n)ews$': '$1ews',
        '(h|bl)ouses$': '$1ouse',
        '(corpse)s$': '$1',
        '(us)es$': '$1',
        s$: '',
    }

    var irregular = {
        move: 'moves',
        foot: 'feet',
        goose: 'geese',
        sex: 'sexes',
        child: 'children',
        man: 'men',
        tooth: 'teeth',
        person: 'people',
    }

    var uncountable = [
        'sheep',
        'fish',
        'deer',
        'moose',
        'series',
        'species',
        'money',
        'rice',
        'information',
        'equipment',
    ]

    // save some time in the case that singular and plural are the same
    if (uncountable.indexOf(this.toLowerCase()) >= 0)
        return this

    // check for irregular forms
    for (word in irregular) {
        if (revert) {
            var pattern = new RegExp(irregular[word] + '$', 'i')
            var replace = word
        } else {
            var pattern = new RegExp(word + '$', 'i')
            var replace = irregular[word]
        }
        if (pattern.test(this))
            return this.replace(pattern, replace)
    }

    if (revert) var array = singular
    else var array = plural

    // check for matches using regular expressions
    for (reg in array) {
        var pattern = new RegExp(reg, 'i')

        if (pattern.test(this))
            return this.replace(pattern, array[reg])
    }

    return this
}

const mathendignorewords = [
    'equals',
    'to',
    'means',
    'as',
    'is',
    'for',
]

function sliceFrom(delimiter, s) {
    let index = s.search(RegExp(delimiter))
    return s.slice(index)
}

function stylemath(s) {
    s = addMathComma(s)
    if (test(/x/, s)) return dreplace(s, 'utfmath2', 'eorbg') //escape or boundary
    return dreplace(s, 'utfmath', 'eorbg') //escape or boundary
}

function randomOperator() {
    return parens(randomPick(mathOperators), ' ')
}

function slicesplit(s, n) {
    return [s.slice(0, n), s.slice(n)]
}
function getGender(name) {
    const femaleNameExceptions = []
    if (femaleNameExceptions.includes(name)) return 'male'
    if (test(/[ae]$/, name)) return 'female'
    let [key, value] = slicesplit(name.toLowerCase(), 3)
    let ref = femaleNames[key]
    if (ref && ref.includes(value)) return 'female'
    return 'male'
}

function displaymath(s) {
    const answer = eval(s)
    return s + ' = ' + answer
}

const unitlib = {
    time: ['seconds', 'minutes', 'hours'],
    time: ['seconds', 'minutes', 'hours', 'weeks'],
    meter: ['millimeters', 'centimeters', 'meters'],
    timeExtra: ['days', 'weeks', 'months', 'years'],
    art: ['points', 'inches'],
}

function unitGetterFactory() {
    let unitIndex = 0
    let $copy = copy(unitlib)

    function unitgetter(s, n) {
        const ref = unitlib[s]
        if (unitIndex == 0) {
            shuffle(ref)
        }
        const unit = ref[unitIndex++]
        if (n) {
            //let unitAmount = math.unit('1 ' + unit).toNumber($copy[s][ref.length - 1])
            let unitAmount = unitConversion(unit, null)

            //console.log(unitAmount)
            unitAmount = 1 / unitAmount
            //console.log(unitAmount)

            let a
            let b
            let boundary
            if (unitAmount == 1) {
                a = 1
                b = 10
                boundary = null
                //extension-possibility
            } else {
                a = unitAmount / 2
                b = unitAmount * 2
                boundary = unitAmount
            }

            unitAmount = rng(a, b, null, boundary)
            //console.log(unitAmount)
            return unitAmount + ' ' + unit
        } else {
            return unit
        }
    }
    return unitgetter
}

function multiplencg(template, items) {
    return templater(
        template,
        items.map((el) => prepareIterable(el, 'keys').join('|'))
    )
}

function getGenderWord(name, type) {
    getCaller()
    const gender = getGender(name)
    switch (gender) {
        case 'male': {
            switch (type) {
                case 'he':
                case 'his':
                    return type
            }
        }
        case 'female': {
            switch (type) {
                case 'he':
                    return 'she'
                case 'his':
                    return 'her'
            }
        }
    }
}

function randomTemplate(n = 3) {
    let s = ''
    let count = 0
    let chance = 0.2

    while (count++ < n) {
        s += randomLetter('abcd')
        s += randomOperator()
    }
    s += randomLetter('abcd')
    return s
}

const sampleClassroomState = {
    // MathTemplater

    enforceLength: 20,
    studentNames: ['Sam', 'Bob'],

    // QuestionGenerator

    onlyPositiveAnswers: null,
    onlyIntegerAnswers: null,

    // both
}
class Classroom2 {
    syncState(state) {
        syncState(this.mt, state)
        syncState(this.qg, state)
    }
    static debug(x, state, debug = 1) {
        const room = new Classroom2(sat9am)
        room.debug = debug
        room.syncState(state)
        if (!isArray(x)) x = [x]
        const payload = room.run(x)
    }
    static simple(...args) {
        const room = new Classroom2(sat9am)
        room.debug = 'simple'
        const payload = room.run(...args)
        return payload
    }

    static create(classRoom, ...questionArrays) {
        const room = new Classroom2(classRoom)
        const payload = room.run(...questionArrays)
        console.log(payload)
    }

    constructor(studentObjectArray) {
        this.students = studentObjectArray
        this.config = {
            numberOfQuestions: 20,
        }

        this.mt = new MathTemplater({
            studentNames: this.students.map((x) => x.name),
            enforceLength: this.config.numberOfQuestions,
        })

        //this.qg = new QuestionGenerator()
        //this.worksheet = new MathWorksheet()
        //this.lettermaker = new LetterInfusion()
    }

    load(student) {
        this.worksheet.reset()
        this.syncState({ level: student.level })
        this.lettermaker.load(
            student.name,
            this.config.numberOfQuestions
        )
    }
    run(...args) {
        console.log(this.makeTransaction)
        console.log(this.qg)
        throw ''
        const runner = (student) => {
            //this.load(student)

            const items = flat(
                args.filter(exists).map((arg) => {
                    return questionmaker2(arg, this.mt, this.qg)
                })
            ).filter(exists)

            if (this.debug == 1) debugit(items)
            if (this.debug == 'simple') {
                return items.map((x) => x.question)
            }

            const payload = items.map(
                ({ question, answer }) => {
                    return this.worksheet.maker(
                        question,
                        answer,
                        this.lettermaker.next()
                    )
                }
            )

            const value = {
                questions: payload,
                name: student.name,
                templateWords: this.lettermaker.templateWords,
            }

            if (this.debug === 2) {
                tl(value)
            }

            return value
        }

        return this.students.map((student) => runner(student))
    }
}
class oldClassroom {
    static createWorksheet() {
        const classroom = new Classroom()
        const students = classroom.studentNames
        const queries = ['[', 'x']

        s = getMathText('squareroots')[0].text
        s = stylemath(s)
        s = globalSpellcheckMathText(s)

        const items = mathsplit2(s, queries)
        const blankify = test(/\ x\w/, items[0] + items[1])

        function runner(items, student) {
            const length = count(items, (x) => x.answer)
            const letterRunner = getLetterFactory(
                'peanut',
                length
            )
            const worksheet = new MathWorksheet()

            return items.map((s, i) => {
                const isStudent =
                    students[i % students.length] == student
                //console.log(isStudent)
                //console.log(student)
                let questionAnswerSplitRE = / *\[([^]+?)\] */
                let [$question, $answer] = force(
                    s.split(questionAnswerSplitRE)
                )
                //console.log(s)
                //console.log($answer)

                $question = editlines(
                    $question,
                    MathWorksheet.questionFn
                )
                if ($answer)
                    $answer = editlines(
                        $answer,
                        MathWorksheet.answerFn
                    )
                //console.log([$question, $answer])

                if (blankify) {
                    $question = isStudent
                        ? blankifyText($question)
                        : unblankifyText($question)
                }

                const letter = letterRunner.runner($answer)
                //console.log(letter)
                const { question, answer, choices } =
                    worksheet.maker($question, $answer, letter)
                //console.log(choices)

                const payload = {
                    index: i + 1,
                    question: question,
                }

                if (answer) payload.answer = answer
                if (choices) payload.choices = choices
                return payload
            })
        }

        return students.reduce((acc, name, i) => {
            acc[name] = runner(items, name)
            return acc
        }, {})
    }
    constructor(grade, classroom) {
        this.loadStudents(grade, classroom)
    }

    get studentNames() {
        return this.students.map((x) => x.name)
    }
    run() {
        this.assembler = new WorksheetAssembler(this.students)
    }

    loadStudents(grade, classroom) {
        if (!grade) grade = 6
        if (!classroom) classroom = 'sat9am'

        const classrooms = {
            sat9am: sat9am,
        }

        const students = classrooms[classroom]
            .filter((x) => x.grade == grade)
            .map((x) => x.name)

        shuffle(students)

        let override = getNearbyHoliday()
        let templates = congratulatefactory(
            students,
            20,
            true,
            override
        )
        this.students = students.map((x, i) => {
            return { name: x, template: templates[i] }
            return {
                name: x,
                template: removeSpaces(templates[i]),
                templateWords: templates[i].split(' '),
            }
        })
    }
}

function getNearbyHoliday() {
    return false
    return 'Happy Mooncake Festival'
    //td
}

function splitSentences(s) {
    return findall(/.*?[\.?!](?: |$)/g, s).filter(hasValue)
}

function splitarray(
    arr,
    delimiter = null,
    options = { once: false, before: false }
) {
    if (isFunction(delimiter)) {
        let count = 0
        let store = new SimpleStorage()
        if (!options.before) {
            for (let item of arr) {
                store.add(count, item)

                if (options.once && count > 0) {
                    continue
                }

                if (delimiter(item)) {
                    count += 1
                }
            }
        } else {
            for (let item of arr) {
                if (options.once && count > 0) {
                    store.add(count, item)
                } else if (delimiter(item)) {
                    count += 1
                    store.add(count, item)
                } else {
                    store.add(count, item)
                }
            }
        }
        return Object.values(store.value)
    }

    if (isNumber(delimiter)) {
        const a = arr.slice(0, delimiter)
        const b = arr.slice(delimiter)[0]
        return [a, b]
    }
    const a = []
    const b = []
    let destination = a
    for (let item of arr) {
        if (item === delimiter) {
            destination = b
        } else {
            destination.push(item)
        }
    }
    return [a, b]
}

function countParentheses(s) {
    return count(/(?<!\\)[()]/g, s)
}
function removeLookaround(s) {
    let items = s.split(/(?=\(\?<?[!=])/)
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        // console.log( item )
        if (/\(\?<?[!=]/.test(item)) {
            let count = 0
            for (;;) {
                item = item.replace(/.*?(?<!\\\\)\)/, '')
                even = isEven(countParentheses(item))
                if (even) break
                if (count++ > 5)
                    throw 'error at splitting something'
            }

            items[i] = item
        }
    }

    return items.join('')
}
function linerun(s, regex, fn) {
    let r = regex.toString().slice(1, -1)
    let join = r.startsWith('\\n') ? '\n' : removeLookaround(r)
    return s.trim().split(regex).map(fn).join(join)
}

const abcbackrefRE = /([abc])\1{0,2}/

function simplelineeditmath(s) {
    const parser = (x) => linerun(x, /(?<=\. )/, usefuledit)
    return linerun(s, /\n+/, parser)
}

function usefuledit(s) {
    s = mathcapitalize(addQuestionMarkOrPeriod(s))
    return s
}

class MathWorksheet {
    reset() {
        this.index = 0
    }

    static answerFn(line) {
        if (!startsWithVariable(line) && isVeryWordy(line)) {
            line = addQuestionMarkOrPeriod(capitalize(line))
        }
        line = fixmathhandler(line)
        line = toItalicAndBold(line)
        return line
    }

    static questionFn(line) {
        if (isVeryWordy(line)) {
            line = mathcapitalize(line)
            line = saysParser(line)
            line = addQuestionMarkOrPeriod(line)
            line = toItalicAndBold(line)
            line = line.replace(fixMathRE, (_, x) => fixmath(x))
        }
        return line
    }

    getLetter() {}
    getBins() {
        let i = char2n(this.letter)
        if (i == 24 || i == 25) {
            return this.length == 4
                ? ['W', 'X', 'Y', 'Z']
                : ['V', 'W', 'X', 'Y', 'Z']
        }
        while (i % this.length != 0) {
            i--
        }
        return ALPHABET.slice(i, i + this.length)
    }

    generateChoices() {
        let ref = char2n(this.letter)
        if (ref == 24) ref -= 1
        if (ref == 25) ref -= 2
        let index = ref % this.length
        let store = []
        let increment

        for (let i = 0; i < this.length; i++) {
            const value =
                i == index
                    ? this.answer
                    : modifyNumber(
                          this.answer,
                          changeAnswer,
                          i,
                          index
                      )

            store[i] = value
        }

        if (
            this.config.onlyPositive &&
            isInteger(store[0]) &&
            parseInt(store[0]) < 0
        ) {
            //return this.generateChoices()
        }

        return [store, index]
    }

    constructor() {
        this.config = {
            length: 'DYNAMIC',
            onlyPositive: true,
        }

        this.student = null
        this.onlyPositive = true
        this.letters = null
        this.letter = null
        this.length = null
        this.answer = null
        this.question = null
        this.index = 0
    }

    getChoiceLength(answer) {
        if (this.config.length == 'FOO') return 4
        try {
            const lines = linecount(answer)
            if (this.config.length == 'DYNAMIC') {
                return Math.max(4, lines)
            } else if (isNumber(this.config.length)) {
                return this.config.length
            }
        } catch {
            this.config.length == 'FOO'
            return 4
        }
    }

    getChoiceLetter(letter) {
        if (!letter) {
            this.letters = ALPHABET.slice(0, this.length)
            return randomPick(this.letters)
        } else {
            return letter.toUpperCase()
        }
    }

    maker(question, answer, letter) {
        if (!answer) {
            return { question }
        }

        this.question = question
        this.answer = stripExtraLines(answer)
        this.length = this.getChoiceLength(answer)
        this.letter = this.getChoiceLetter(letter)

        let index = ++this.index
        let value

        if (isSingleLine(this.answer)) {
            const bins = this.getBins()
            const [choices, answerIndex] =
                this.generateChoices()
            value = {
                question,
                choices: zip(bins, choices),
                answer: this.answer,
                index,
            }
        } else {
            const choices = this.answer
                .trim()
                .split(/\n/)
                .map(trimmed)
            const answerRef = choices[0]
            sortChoices(choices)

            if (!letter) {
                letter = n2char(
                    choices.indexOf(answerRef)
                ).toUpperCase()
            }

            const bins = letterMatch(letter, answerRef, choices)
            if (!bins.includes(letter)) {
                console.log(answerRef, 'aref')
                console.log(bins, letter, 'bins', 'letter')
                throw 'bin error'
            }

            let verified =
                choices.indexOf(answerRef) ==
                bins.indexOf(letter.toUpperCase())
            if (!verified) {
                console.log(tempflag, 'tempflag')
                console.log(choices, 'choices')
                console.log(bins, 'bins')
                console.log(letter, 'letter')
                console.log(answerRef, 'answerRef')
            }
            value = {
                question,
                choices: zip(bins, choices),
                answer: answerRef,
                index,
            }
            if (!exists(value.choices)) {
                console.log(answerIndex, 'answerIndex')
                console.log(answerIndex, 'ai')
                console.log(choices)
                console.log(a)
                // the index is 3. The alphabetletter index is ... -1.
                console.log(b)
                console.log(alphabetLetterIndex)
                console.log(bins)
                throw 'bin error'
            }
        }
        return value
    }
}

class WorksheetAssembler {
    constructor(students, grade = 6) {
        const outpath = 'math' + datestamp() + '.json'
        this.items = getMathText('warmup', 'homework')
        this.warmup = findAndGet(this.items, 'warmup', 'text')
        this.homework = findAndGet(
            this.items,
            'homework',
            'text'
        )
        this.assignments = {}

        for (let student of students) {
            const [template, homework] = prepareWarmup(
                this.homework,
                student.template
            )

            if (!this.assignments[student.name])
                this.assignments[student.name] = {}
            this.assignments[student.name]['homework'] = {
                template: student.template,
                homework: homework,
                student: student.name,
            }

            const warmup = prepareWarmup(this.warmup, null)
            this.assignments[student.name]['warmup'] = warmup
        }
        fwrite(outpath, this.assignments)
        openfile(outpath)
    }
}

function getMathText(...queries) {
    if (queries.length == 0) queries = ['overflow']
    const queryRE = ncg(queries)

    const datestampRE = '\\d+-\\d+-\\d+'
    let regex = createAccumulateRegex(
        parens(datestampRE),
        '(.+)'
    )
    //console.log(regex)
    let file = 'd.txt'
    let items = findall(regex, read(file), 'g')
    const store = []

    for (let [date, tag, text] of items) {
        //console.log(date, tag)
        if (!todayOrYesterday(date)) continue
        if (!test(queryRE, tag)) continue
        store.push({ date, tag: tag.trim(), text: text.trim() })
    }

    if (store.length > 0) {
        return store
    }

    console.log('Couldnt find text based on date.')
    console.log('now searching for text independent of date.')
    console.log('returning first match in store-object format')
    console.log('retrieval will be via store[0].text')
    // store-object means [{obj}]

    for (let [date, tag, text] of items) {
        if (!test(queryRE, tag)) continue
        store.push({ date, tag, text })
        return store
    }
    console.log('couldnt find anything')
}

function prepareWarmup(s, template) {
    let answerFn = (s) => {
        if (!startsWithVariable(s) && isVeryWordy(s)) {
            s = addQuestionMarkOrPeriod(capitalize(s))
        }
        s = fixmathhandler(s)
        s = toItalicAndBold(s)
        return s
    }

    answerFn = LineEdit.factory(answerFn)
    const questionFn = LineEdit.factory(
        mapConditional(isVeryWordy, [
            mathcapitalize,
            saysParser,
            addQuestionMarkOrPeriod,
            toItalicAndBold,
        ])
    )

    //questionFn = identity
    //answerFn = identity
    //(s) => s.replace(fixMathRE, (_, x) => fixmath(x))]))

    const maker = new MathWorksheet()
    const builder = TextBuilder.prepareMathPage(s)
    const store = []
    let capitalized = null

    let items = mathsplit1(builder.text)

    if (template) {
        items = items.slice(0, removeSpaces(template).length)
    }

    const getLetter = getLetterFactory(template, items.length)
    console.log(getLetter.template)
    if (
        getLetter.template &&
        removeSpaces(getLetter.template).length != items.length
    )
        throw ''
    else {
        console.log('lenths mat')
    }

    for (let [q, a] of items) {
        letter = getLetter.runner()
        if (template && !letter) {
            console.log(template)
            throw 'no letter'
        }
        capitalized = null
        let $question = questionFn(q)
        let $answer = answerFn(a)
        let value = maker.maker(
            $question,
            $answer,
            letter,
            null
        )
        if (template && !(letter in value.choices)) {
            console.log(value)
            console.log(letter)
            throw 'letter not present'
        }
        store.push(value)
    }

    return getLetter.template
        ? [getLetter.template, store]
        : store
}

function toItalicAndBold(s) {
    return s
    function parser(x) {
        const p = letterdict.italic[x]
        return p
    }
    const regex =
        /(?<![a-zA-Z])[bcxyzBCXYZnm](?=[^\w]|$)|\b[Aa](?=$| [+÷×-])/gm
    return s.replace(regex, parser)
}
abc = 'abcde'.split('')

function mathcapitalize(s) {
    function has(items, s) {
        return test(ncg(items) + '$', s)
    }

    if (startsWithVariable(s) || has(mathendignorewords, s)) {
        //console.log('has it', s)
        return s
    }
    return s[0].toUpperCase() + s.slice(1)
}

function saysParser(line) {
    const ref =
        's(?:a(?:y|id)|hout)|p(?:ok|eak)|cr(?:ie|y)|repl'
    const regex = ncg('^[\\w ]+(?=$1)', ref)

    return replace(
        regex,
        (s) => {
            const comma = s.endsWith('?') ? '' : ','
            return (
                doublequote(capitalize(s.trim())) + comma + ' '
            )
        },
        line,
        ''
    )
}

function sortChoices(choices) {
    return shuffle(choices)

    function runner(a) {
        let x = search(/[\d.-]+/, a)
        if (isNumber(x)) x = Number(x)
        else {
            x = 100 + a.length
        }
        return x
    }

    choices.sort((a, b) => runner(a) - runner(b))
}

function fixPluralization(s) {
    return s
    return s.replace(/\ba(?= [aeiou])/g, 'an')
}

function fixVowels(s) {
    return s.replace(/\ba(?= [aeiou])/g, 'an')
}
class TextBuilder {
    static prepareMathPage(s) {
        const builder = new TextBuilder(s)
        //builder.trimEnd()
        builder.removeComments()

        const parsers = [
            trimmed,
            LineEdit.generator({
                eq: inlineEquationMaker,
                '': mathemmet,
            }),
        ]

        //builder.text = doctor(builder.text)

        const foopmnb = {
            '(': '[',
            ')': ']',
        }
        builder.text = dreplace(builder.text, foopmnb, 'ge')
        //builder.text = new LineEdit(parsers).run(builder.text).getValue()
        builder.text = dreplace(builder.text, pmwb, 'gbl')
        builder.text = builder.text.replace(
            /\d+(?::\d+)?(?:am|pm)/g,
            fixTimeString
        )
        builder.text = builder.text.replace(
            /(?<=[a-zA-Z][!\.?] )[a-z]/g,
            capitalize
        )
        builder.text = replace(
            '' + '\\*' + '',
            (x) => mathdict[x],
            builder.text
        )

        builder.prepareText({
            fn: (a, b, dict) => a + ' ' + pluralize(dict[b], a),
            template: '(\\d+)($1)\\b',
            items: mathProseDict,
        })

        builder.smartText(
            {
                '(?<=following )except': (s) => s.toUpperCase(),
                '(?<=choose )all': (s) => s.toUpperCase(),
            },
            'gi'
        )

        return builder
    }
    removeComments() {
        this.text = removeComments(this.text)
    }
    smartText(obj, flags) {
        const regexes = []
        const dict = reduce(obj, (k, v) => {
            regexes.push(k)
            return [replaceLookAround(k), v]
        })
        this.text = this.text.replace(
            RegExp(regexes.join('|'), flags),
            (x) => {
                return dict[x] ? dict[x](x) : x
            }
        )
    }
    constructor(text) {
        this.text = text
    }
    trimEnd() {
        function pagesplit(s, query = 'end', delimiter = '//') {
            return replace(
                '^' + delimiter + '\\s*' + query + '[^]+',
                '',
                s,
                'msi'
            )
        }
        this.text = pagesplit(this.text)
    }

    LineEdit(fn) {
        this.text = new LineEdit(fn).run(this.text).getValue()
    }

    replaceText(input, flags) {
        if (isObject(input)) {
            this.text = dreplace(this.text, input, flags)
        } else if (isRegExp(input)) {
            this.text = this.text.replace(input, flags)
        }
    }
    commander(...parsers) {
        for (let parser of parsers) {
            this.text = parser(this.text)
        }
    }
    prepareText(input, fn) {
        if (input === LineEdit) {
            this.text = new LineEdit(fn).run(this.text)
        } else if (isFunction(input)) {
            this.text = input(this.text)
        } else if (fn) {
            this.text = replace(input, fn, this.text)
        } else if (input.template) {
            const regex = templater(
                input.template,
                Object.keys(input.items).join('|')
            )
            if (input.items && !input.fn) {
                this.text = replace(
                    regex,
                    (x) => input.items[x],
                    this.text
                )
            } else if (input.items && input.fn) {
                this.text = replace(
                    regex,
                    (...args) => {
                        args =
                            args.length == 3
                                ? args[0]
                                : args.length == 4
                                ? args[1]
                                : args
                                      .slice(1, -2)
                                      .filter(String)

                        return input.fn(...args, input.items)
                    },
                    this.text
                )
            }
        } else {
            throw 'too hard'
            const prepare = dictfactory(input)
            this.text = prepare(this.text)
        }
    }
    extract(regex, ...args) {
        let s
        let extraction

        if (isFunction(regex)) {
            ;[s, extraction] = regex(this.text, ...args)
        } else {
            ;[s, extraction] = mreplace(regex, this.text)
        }

        this.text = s
        return extraction
    }
}

function inlineEquationMaker(line) {
    const [a, operator, b] = s.split(/ *[-+×] */)
    const length = Math.max(a.length, b.length + 2)
    const lineSeparator = '_'.repeat(length)
    const spacegap =
        length == a.length ? a.length - b.length : 2
    let value = [
        a,
        operator + ' '.repeat(spacegap) + b,
        lineSeparator,
    ].join('\n')
    return indent(value)
}

function mathemmet(line) {
    let [template, b] = splitlast(line)
    b = Number(b.slice(1))
    let store = iterate(b, (i) => {
        return fixmath(template.replace(/i/g, i))
    })
    return store.join('\n')
}

function fixTimeString(s) {
    if (s.includes(':')) return s.toUpperCase()
    let [digits, ampm] = numberboundarysplit(s)

    digits = digits.toString()

    if (digits.length == 3) {
        return (
            digits[0] +
            ':' +
            digits.slice(1) +
            ampm.toUpperCase()
        )
    }

    if (digits.length < 3) {
        return (
            digits.slice(0, digits.length) +
            ':00' +
            ampm.toUpperCase()
        )
    }
}

function mathsplit2(s, queries) {
    let r = createAccumulateRE(
        '\\w',
        '(?: ' + ncg(queries, 'e') + '.+|equals(?=\\n|$))'
    )
    return s.match(RegExp(r, 'g')).map(trimmed)
}

function mathsplit1(s) {
    let items = s
        .trim()
        .split(/ *\n\n+ */)
        .map((item) => {
            if (item.includes('\n')) {
                return splitonce(item, '\n')
            }
            let rr = / (?=\S+$)/m
            return item.trim().split(rr)
        })
    return items
}

function getTemplateOfLength(template, length) {
    return 'peanut'
}

function congratulatefactory(
    names,
    maxlength = 100,
    caps = true,
    override
) {
    //let exclamation =  '!'
    let exclamation = ''
    let got = false
    let minlength = 15
    const congratulationStatements = mixAndMatch(
        congratAdjectives,
        congratJobs
    )
    let cnames = names.map((name) => {
        let statement = override
            ? override
            : randomPick(congratulationStatements)
        let s = statement + ' ' + name + exclamation
        x = removeSpaces(s)
        if (got || override) return s
        else {
            while (
                x.length > maxlength ||
                x.length < minlength
            ) {
                s =
                    randomPick(congratulationStatements) +
                    ' ' +
                    name +
                    exclamation
                x = removeSpaces(s)
            }
        }
        //console.log(s)
        return s
    })
    let longest = getLongest(cnames)
    let rnames = cnames.map((item, i) => {
        let length = item.length
        let ref = names[i]
        let value = item.replace(ref, (x) =>
            extendName(x, longest - length)
        )
        return caps
            ? value.toUpperCase()
            : capitalizeTitle(value)
    })
    //console.log(rnames[0].length) // The difficulty has to be culled and culled.
    return rnames
    //const longest = getLongest(names)
    //let newnames  = names.map(name => extendName(name, longest - name.length))
    // doing something here
    //let cache = zip(names, newnames)

    return (name) => {
        //return 'Nice Job' + cache[name] + '!'

        const statement = tryagain(
            congratulationStatements,
            (statement) => {
                return (
                    (statement + name).length < requiredLength
                )
            }
        )

        let value = coinflip()
            ? statement + ' ' + name
            : name + ' ' + statement
        return value.toUpperCase()
    }
}

class LetterInfusion {
    constructor() {}

    load(student, length) {
        const holiday = getNearbyHoliday()
        const congratulationStatements = mixAndMatch(
            congratAdjectives,
            congratJobs
        )

        function createRandomMessage() {
            return null
            //return iterate(length, () => randomPick(['A', 'B', 'C', 'D'])).join('')
        }

        const createTemplate = () => {
            return 'foo'
            const statement = randomPick(
                congratulationStatements
            )
            const statementLength =
                removeSpaces(statement).length
            if (statementLength + student.length > length) {
                //return createTemplate()
                if (length == 20) {
                    console.log('length is long')
                    return createTemplate()
                }
            }

            const extensionLength =
                length - statementLength - student.length
            const name = extendName(student, extensionLength)
            const value = coinflip()
                ? statement + ' ' + name
                : name + ', ' + statement
            return value.toUpperCase()
        }

        this.template = student
            ? createTemplate()
            : createRandomMessage()
        this.letters = removeNonLetters(this.template).split('')
        this.templateWords = this.template.split(/,? /)
        this.index = 0
    }
    next() {
        if (!this.template) return
        return this.letters[this.index++]
    }
}
function getLetterFactory(template, length) {
    if (!template) {
        return {
            runner: () => {},
            template: null,
        }
    } else if (template.length > length) {
        template = getTemplateOfLength(template, length)
    }
    //let name = getStudentName(student)
    //let delta = length - name.length - 2
    //name = extendName(name, delta)
    //name = 'Go ' + name
    //let template = name
    let letters = removeSpaces(template)
    let index = 0
    return {
        runner: (val = true) => (val ? letters[index++] : null),
        template: template,
    }
}

function dialogue4() {
    const students = [
        'Aaron',
        'Elina',
        'Kloe',
        'Kaylee',
        'Lynn',
    ]
    const runner = (x) => {
        for (let studentName of prepareIterable(
            students,
            'keys'
        )) {
            if (test('^' + x, studentName, 'i')) {
                return studentName
            }
        }
    }

    const { text, date, tag } = getMathText('dialog')[0]
    let s = text

    s = dreplace(s, read('words.json'), 'gw')
    s = dreplace(s, pmnb, 'g')
    s = s.replace(/\d+(?::\d+)?(?:am|pm)/g, fixTimeString)
    s = s.replace(/(?<=[a-zA-Z][!\.?] )[a-z]/g, capitalize)
    s = s.replace(/  /g, ' ')
    s = s.replace(/(?<=[a-z])1/g, '!')
    s = addMathComma(s)
    s = doctor(s)

    let regex = /^(@|#|\w+) ?(.+)/gm
    let matches = findall(regex, s)
    let value = matches.map(([a, b]) => {
        if (a == '@') {
            let url = '/kdog3682/CWF/posing.jpg'
            if (b == 'catpic') {
                return ['', url]
                name = ''
            }
        }

        let name = runner(a) || capitalize(a)
        let text = b

        return [name, periodify(text)]
    })
    let name = tag + date + '.json'
    write(name, value)
    openfile(name)

    return value
    //outpath = 'dialogue' + datestamp() + '.json'
    //console.log(outpath)
}

function letterMatch(letter, answer, choices) {
    let cn = char2n(letter)
    if (cn > 22 || cn < 2) {
        let b = cn < 2 ? choices.length : 26
        let a = cn < 2 ? 0 : 26 - choices.length
        //console.log(a, b)
        let bins = ALPHABET.slice(a, b)
        indexSwap(
            choices,
            bins.indexOf(letter),
            choices.indexOf(answer)
        )
        //console.log(choices)
        return bins
    }
    let letterIndex
    let answerIndex
    let a
    let b
    let length = choices.length

    function runner(second) {
        tempflag = 1
        answerIndex = choices.indexOf(answer)
        letterIndex = char2n(letter)
        a = letterIndex - answerIndex
        b = letterIndex + choices.length - answerIndex
        if (b > 26 || a < 0) {
            if (second) {
                tempflag = 2

                answerIndex = choices.indexOf(answer)
                letterIndex = char2n(letter)
                console.log('letter', letter)
                console.log('a', answerIndex, 'l', letterIndex)
                console.log(choices)
                indexSwap(choices, letterIndex, answerIndex)
                console.log(choices)
                if (a < 0) {
                    a = 0
                    b = length
                } else {
                    b = 26
                    a = 26 - length
                }
            } else {
                //shuffle(choices)
                runner(true)
            }
        }
    }
    runner()
    return ALPHABET.slice(a, b)
}

function globalSpellcheckMathText(s) {
    //if (!spellcheck) spellcheck = new Spellcheck()
    //s = dreplace(s, read('words.json'), 'gw')
    s = dreplace(s, pmnb, 'g')
    s = s.replace(/\d+(?::\d+)?(?:am|pm)/g, fixTimeString)
    s = s.replace(/(?<=[a-zA-Z][!\.?] )[a-z]/g, capitalize)
    s = s.replace(/  /g, ' ')
    s = s.replace(/(?<=[a-z])1(?!\d)/g, '!')
    s = doctor(s)

    return s
    //return spellcheck.check(s)
}

function unblankifyText(s) {
    return s.replace(/ xx?(?=\w+)/g, ' ')
}

function blankifyText(s) {
    s = s.replace(/ xx.+?(?= *\[)/, '')
    return s.replace(/ x.*?(?=[,.?])/g, ' ________')
}

function kayleemod(s) {
    const dict = {
        //'least': '
        //'I
    }
    //
    // there is a feeling that you might be learning more than you realize
    // deposits withdrawals transfers. checkings /savings
    // increasing the size of the numbers
    // everything becomes a gigantic mess
    // In their mind, they're kind of getting a good deal.
    // To check your answer,
    // Instructions, to check your answer, everyone has the exact same answers.
    // Everyone has the exact same answers. To check your answers, share with your classmates.
    return dreplace(s, dict, 'iglb')
}
function selfedit(key, payload, mode = 'full') {
    file = 'classroom.js'
    if (!exists(payload)) {
        console.log('no payload')
        return
    }
    rpw(file, (s) => insertionReplace(s, key, payload, mode))
}
function self(f, ...args) {
    let currentFile = require('./node-utils.js').currentFile()
    let s = read(currentFile)
    return s
    let fString = f.toString()
    let value = f(s, ...args)
    if (!value) return 
    let m = search('/\\* *(read|append|write) *\\*/', fString)
    switch (m) {
        case 'append':
          append(currentFile, createVariable('temp', value, ''))
    }
}

function appendReplace(s, key, payload) {
    return s.replace(key, key + payload)
}

const movementlist = [
    'mathendignorewords',
    'stylemath',
    'Classroom',
    'MathWorksheet',
    'modifyNumber',
    'WorksheetAssembler',
    'prepareQuestions',
    'getMathText',
    'prepareWarmup',
    'fixmathhandler',
    'fixMathRE',
    'fixmath',
    'toItalicAndBold',
    'mathcapitalize',
    'saysParser',
    'sortChoices',
    'TextBuilder',
    'inlineEquationMaker',
    'mathemmet',
    'fixTimeString',
    'mathsplit2',
    'mathsplit1',
    'getTemplateOfLength',
    'getLetterFactory',
    'dialogue4',
    'letterMatch',
    'globalSpellcheckMathText',
    'unblankifyText',
    'blankifyText',
    'selfedit',
    'appendReplace',
    'self',
    'selfappend',
    'movementlist',
    'movementlist2',
    'createBodyRE',
    'appendBeforeLastLine',
    'veryclose',
    'getFunctionsAndRemove',
]
const movementlist2 = ['selfedit', 'self', 'selfappend']

function createBodyRE(names) {
    const bodyItems = [
        //'= *(?:[\\[\\{] *\\n[^]+?\\n[\\]\\}]|/+)',
        '= *[\\[\\{] *\\n[^]+?\\n[\\]\\}]',
        '= *.+',
        '[^]+?\\n[\\}\\]]',
    ]
    let start = '(?:\\n|^)'
    //let start = ''
    let end = ''
    let regex =
        start +
        '(?:(?:async )?function|const|class) (?:$1) *' +
        ncg(bodyItems) +
        end
    regex = ncg(regex, names)
    return regex
}

function appendBeforeLastLine(text, s) {
    return text.trim().replace(/(?=.*$)/, s.trimEnd() + '\n')
}

function veryclose(a, b) {
    A = a.length
    B = b.length
    return Math.abs(A - B) < 100
}

function getFunctionsAndRemove(file, names) {
    s = read(file)
    const initialLength = s.length
    const regex = createBodyRE(names)
    //console.log(regex)
    let [textA, store] = mreplace(regex, '', s, 'gm')
    const names2 = store.map(trialrun(getWord, 2))
    const finalLength = textA.length
    if (veryclose(initialLength, finalLength)) {
        throw ''
    }
    if (store.length < names.length) {
        console.log(store.length)
        console.log(names.length)
        console.log(filtered(names, names2))
        throw 'missing items'
    }

    depositLocation =
        'getWord, addQuestionMarkOrPeriod, periodify, '
    importLocation = depositLocation
    if (names.includes('self'))
        importLocation = 'writeopen, append, '
    textA = appendReplace(
        textA,
        importLocation,
        names.join(', ') + ','
    )
    textA = stripExtraLines(textA)

    outpath = 'newhelpers.js2'
    if (names.includes('self')) outpath = 'nodehelpers.js'
    if (names.includes('self'))
        depositLocation = 'module.exports = { '
    textB = read(outpath)
    textB = appendReplace(
        textB,
        depositLocation,
        names.join(', ') + ','
    )
    textB = appendBeforeLastLine(textB, store.join('\n\n'))

    write(file, textA)
    write(outpath, textB)
}

const removedCommentRE = /(?<=\/\/).*|(?<=\/\*)[^]*?(?=\*\/)/g
const commentRE = /^(?:\/\/|\/\*[^]*?\*\/).*\n?/gm

function mathBreakdownMultiple(s) {
    const store = new SimpleStorage()
    s.replace(/\d+/g, (x, offset) => {
        x = Number(x)
        for (let i = 1; i <= Math.ceil(x / 2); i++) {
            let y = x - i
            store.add(offset, mathjoin(i, y, '+'))
        }
    })
    console.log(store)
    throw ''
}
function mathBreakdown(s) {
    return s.replace(/\d+/g, (x) => {
        x = Number(x)
        z = rng(1, x - 1)
        yplus = x - z
        yminus = x + z
        return parens(mathjoin(yplus, z, '+'))
        return parens(mathjoin(yminus, z, '-'))
    })
}
function mathjoin(...args) {
    const operator = ' ' + args.pop() + ' '
    return args.join(operator)
}

function getnumber(s) {
    if (isString(s)) return search(/\d+/, s)
    return filtered(s, isNumber)
}
function getNumbersWithOperators(s) {
    const regex = /(?:- ?)?\d+\.?\d*/g
    return s.match(regex).map(toNumber)
    return findall(regex, s)
}
function calculate(s) {
    return Calculation.calculate(s)
}
const abcRE = /[a-z]/g
function incrementEachLetter(s, n = 1) {
    return s.replace(abcRE, (x) => {
        return n2char(char2n(x) + n)
    })
}
function mathDistribute(...args) {
    let operators
    let s
    if (args.length < 4) {
        if (!test(/\d/, args[0])) {
            operators = getOperators(args[0])
            args = args[0].match(/[a-z]/g)
            console.log(operators)
        } else {
            s =
                args[0].length < 15
                    ? mathBreakdown(args[0])
                    : args[0]
            args = getnumbers(s)
            operators = getOperators(s)
        }
    }

    let [o1, o2] = [operators[0], operators[2]]
    let [a, b, c, d] = args
    const runner = (x, y, o) => parens(mathjoin(x, y, '*'))
    function pairedmathjoin(a, b) {
        let ref = a
        let s = ''
        while (ref.length > 0) {
            s += ref.shift()
            if (ref == a) ref = b
            else ref = a
        }
        return s
    }
    function fixOperator(s) {
        if (s.length == 1) return parens(s, ' ')
        let items = s.split('').map((x) => (x == '+' ? 1 : -1))
        let answer = items[0] * items[1]
        return parens(answer > 0 ? '+' : '-', ' ')
    }
    const facts = [
        [a, c],
        [a, d],
        [b, c],
        [b, d],
    ].map((x) => runner(...x))
    const value = pairedmathjoin(
        facts,
        [o1, o2, o1 + o2].map(fixOperator)
    )
    const pp = value
    return pp
    const dict = {
        '+ (- ': '- (',
        '+ -': '-',
    }
    const p = dreplace(value, dict, 'eg')
    return p
}
function mathMultiplication({
    a = 3,
    b = 5,
    skip = true,
    amount = 1,
} = {}) {
    const store = []
    for (let i = a; i <= b; i++) {
        for (let j = i; j <= b; j++) {
            if (skip) if (i % 10 == 0) continue

            const value = mathjoin(i, j, '*')
            store.push(value)
        }
    }
    if (amount == 1) return randomPick(store)
    return store
}

function mathMultiplicationOrdered() {
    const values = mathMultiplication({
        a: 4,
        b: 8,
        skip: true,
    })
    values.sort(sortfactory(eval))
    return values
}

function uniqueGenerator(fn, ...args) {
    const store = new GatedArray()

    for (let i = 0; i < 3; i++) {
        store.push(fn(...args))
    }

    return store.value
}
function generateMathVariableQuestion() {
    let templates = [
        '(a + b) * (c + d)',
        '(a + b) * c',
        '(a * b) * c * d',
    ]
    let template = templates[0]
    return mathDistribute(
        incrementEachLetter(template, rng(0, 3))
    )
}

function gmt(s) {
    const p = getMathText(s)[0].text
    //console.log(p)
    return p
}

function mathExpand(s, mode) {
    const [base, power] = search(/(\d+)\^(\d+)/, s)
    if (mode == String)
        return (
            (base + parens('*', ' ')).repeat(Number(power)) +
            base
        )
    else {
        return Math.pow(base, power)
    }
}
const fnlib = {
    mathMultiplication,
    mathBreakdown,
    mathDistribute,
    expand: mathExpand,
}
function fnrunner() {
    let store = []
    let commands = gmt('math').trim().split('\n')
    let dict = {
        fn: (x) => fnlib[x],
    }

    let a
    let value

    for (let command of commands) {
        if (!command) {
            a = ''
            continue
        }

        let [key, val, args] = search(
            /(\w+).(\w+) *(.*)/,
            command
        )
        args = parseArgs(args)
        let method = dict[key](val)
        if (isFunction(method)) {
            if (a) {
                value = method(a)
            } else {
                value = args ? method(args) : method()
            }
        }

        if (value) {
            a = value
            store.push(value)
        }
    }
    const p = store
    console.log(p)
    return p
}

function toArgument(s) {
    if (isNumber(s)) return toNumber(s)
    if (s == 'false') return false
    if (s == 'true') return true
    if (s == 'null') return null
    if (s == 'Number') return Number
    if (s == 'String') return String
    return s
}

function parseArgs(s) {
    if (s.startsWith('{')) {
        return reduce(
            paired(s.replace(/[{}]/g, '').split(/ *[:,] ?/)),
            (k, v) => [k, toArgument(v)]
        )
    }
    return toArgument(s)
}

function solve(s) {
    const p = fixFloatingPoint(eval(s))
    return p
}

function vimtemplater(s) {
    //const regex = /\${.*?\}/g
    const regex = /\$\{(\w+)\((.*?)\)\}/g
    return s.replace(regex, runner)
    function runner(_, fn, arg) {
        let args = arg.split(/, /).map(parseArgs)
        console.log(args)
        return fnlib[fn](...args)
    }
}

function mathListify(template, answerExpression) {
    let tree = parseExpression(answerExpression)
}
function parseExpression(s) {
    const items = s.split(mathOperatorRE)
    for (let i = 0; i < items.length - 1; i++) {
        let [a, b] = items.slice(i, i + 2)
        if (isMathOperator(b)) {
        }
    }
}

function isMathOperator(s) {
    const r = /[\=\+\-\*]/
    return test(r, s)
}

function removeComments(s) {
    return s.replace(
        /^ *(<!--[^]*?-->|\/\/|\/\*[^]*?\*\/).*\n?/gm,
        ''
    )
    return s.replace(/^(\/\/|\/\*[^]*?\*\/).*\n/gm, '')
    return s.replace(/^ *(\/\/|\/\*[^]*?\*\/).*\n/gm, '')
}

function cleanupEmmetFile(s) {
    const parsers = []
    const regexes = []
    const items = query.split(', ')
    for (let item of items) {
        if (item == 'comments') {
            parsers.push(removeComments)
        } else {
            regexes.push(rescape(item))
        }
    }
    const regex = ncg('^(?:$1).+\n?', regexes)
    parsers.push((s) => replace(regex, '', s, 'gm'))

    for (let parser of parsers) {
        s = parser(s)
    }
}

function lineRepl() {
    const { Transform, Writable } = require('stream')
    const process = require('process')

    class LineUnitizer extends Transform {
        constructor(delimiter = '\n') {
            super()
            this.buffer = ''
            this.delimiter = delimiter
        }
        _transform(chunk, enc, done) {
            this.buffer += chunk.toString()
            var lines = this.buffer.split(this.delimiter)
            this.buffer = lines.pop()
            lines.forEach((line) => this.push(line))
            done()
        }
    }

    class Repl extends Writable {
        _parse(line) {
            var [cmd, ...args] = line.split(/\s+/)
            return { cmd, args }
        }
        _write(line, enc, done) {
            var { cmd, args } = this._parse(line.toString())
            this.emit(cmd, args)
            done()
        }
    }

    process.stdin.pipe(new LineUnitizer()).pipe(
        new Repl()
            .on('add', function (args) {
                var sum = args
                    .map(Number)
                    .reduce((a, b) => a + b, 0)
                console.log('add result: %d', sum)
            })
            .on('shout', function (args) {
                var allcaps = args
                    .map((s) => s.toUpperCase())
                    .join(' ')
                console.log(allcaps)
            })
            .on('exit', function (args) {
                console.log('kthxbai!')
                process.exit()
            })
    )
}

function filecontroller() {
    const { argv } = require('process')

    let [inputfile, fn, ...args] = argv.slice(2)
    //args = args.map(parseArgs)
    console.log(inputfile)
    console.log(args)
    s = read(inputfile)
    out = fn(s, ...args)
    write('temp', out)
    openfile('temp')
}

function isNegativeAnswer(s) {
    return String(s).trim().startsWith('-')
}

function getMedleyArgs(a) {
    if (a.length == 0) return [1, 4, 1, 1]
    if (a.length == 1) return [1, a[0], 1, 2]
    if (a.length == 2) return [1, a[0], 1, a[1]]
    if (a.length == 3) return [a[0], a[1], a[2] - 1, a[2]]
    return a
}

const abcdeFractionRE = /[a-v]+(?:\/[a-e])?/g
const abcdeRE = /[a-e]/g

function nerdsub(expr, x, y) {
    if (isDoubleIterable(x)) {
        x = prepareIterable(x, 'entries')
        for (let [a, b] of x) {
            expr = nerdamer(expr).sub(a, b)
        }
    } else if (y != null) {
        expr = nerdamer(expr).sub(x, y)
    }

    return expr
}

function conditionalMerge(a, b) {
    for (let [k, v] of Object.entries(b)) {
        if (!a.hasOwnProperty(k)) a[k] = v
    }
}

function isLatexOperator(s) {
    const r = /[\+\-\*]/
    return test(r, s)
}

function findClosingBracketIndex(s, pos) {
    let leftOperator = '{'
    let rightOperator = '}'
    let depth = 1
    if (!pos) pos = s.indexOf(leftOperator)

    for (let i = pos + 1; i < s.length; i++) {
        switch (s[i]) {
            case leftOperator:
                depth++
                break
            case rightOperator:
                if (--depth == 0) {
                    return [pos, i]
                }
                break
        }
    }
    return -1
}

function isLatexFraction(s) {
    return test('frac', s)
}

function isLatexExponent(s) {
    return /^\w+\^/.test(s)
}

function editDict(dict, fn) {
    for (let [k, v] of Object.entries(dict)) {
        dict[k] = fn(v)
    }
    return dict
}

function setattrs(a, b) {
    if (!b) {
        return
    } else {
        //Object.assign(a, b)
    }

    for (let [k, v] of Object.entries(b)) {
        a[k] = isFunction(v) ? v.bind(a) : v
    }
}

function isFraction(s) {
    if (isString(s)) {
        return s.includes('/')
    }
}

class Infusion {
    constructor(level) {
        this.config = {
            useVariablesInAnswer: false,
            onlyIntegerAnswers: false,
            name: 'infusion',
            level: 1,
            index: 0,
        }
        Object.assign(this, StringMixins)
        this.numbergen = new NumberGen()
    }

    withNumbers() {
        const runnerA = (s) =>
            isFraction(s)
                ? this.numbergen.getRandomFraction()
                : s == 'n'
                ? NumberGen.getNumber(this.config.level)
                : this.config.useVariablesInAnswer &&
                  coinflip(0.35) &&
                  !this.numbergen.cache.has(s)
                ? s.toUpperCase()
                : this.numbergen.getCached(s)

        const runnerB = (s) =>
            this.config.addZerosOrDecimals
                ? zeroify(
                      s,
                      rangegetter(
                          this.config.addZerosOrDecimals,
                          this.config.level
                      )
                  )
                : s

        this.replace(abcdeFractionRE, (s) => {
            if (s.length == 1) {
                //if (test(/[xyz]/, s)) return s
                return runnerB(runnerA(s))
            }
            //let [front, x] = s.split(/(x.*)/)
            let p = iteration(s, runnerA, '', '*')
            p = runnerB(matheval(p))
            return p
        })
        //console.blue(this.s)
    }

    withVariables(letter = 'x') {
        if (test(letter, this.s)) return
        const matches = this.s.match(abcdeRE)
        const match = randomPick(matches)
        this.replace(match, letter, 'g')
    }

    getAnswer(s) {
        //console.log('getting the answeadfasdfr')

        let answer = MathSolver.evaluate(s)
        let value = this.config.asDecimal
            ? fixFloatingPoint(answer)
            : fractionize(answer)
        if (isInteger(value) && this.mode == 'question')
            value = randomlyAddZeroes(value)
        return value
    }
    getAnswer2(s) {
        let isDivision = false
        let asDecimal = this.config.answerAsDecimal

        if (test('÷', s)) {
            s = s.replace(/ ?÷ ?/g, '/')
            isDivision = true
        }

        let answer
        let prelim = tryval(s)
        if (isNumber(prelim)) {
            answer = prelim
        } else if (test(/x/, s)) {
            answer = nerdsolver(s)
        } else {
            answer = nerdamer(s).evaluate().toString()
            asDecimal = false
        }

        if (isDivision) {
            if (this.config.mode == 'terminating-decimal') {
                if (hasTerminatingDecimal(answer)) {
                    return answer
                } else {
                    return
                }
            } else {
                return mathTruncate(answer)
            }
        }

        let value = asDecimal
            ? fixFloatingPoint(answer)
            : fractionize(answer)
        if (isInteger(value) && this.sMode == 'question')
            value = randomlyAddZeroes(value)
        return value
    }

    withEquals() {
        if (test(/=/, this.s)) {
            this.answer = fractionize(nerdsolver(this.s))
        } else if (!test(/x/, this.s)) {
            let answer = this.getAnswer(this.s)
            if (!this.isValidAnswer(answer)) {
                return this.doItAgain()
            }
            this.s += ' = '
            this.answer = answer
        } else if (test(xfracRE, this.s)) {
            let value = this.numbergen.getRandomFraction()
            let expr = replace(xfracRE, value, this.s)
            this.replace(xfracRE, 'x')
            let answer = this.getAnswer(expr)
            if (!this.isValidAnswer(answer))
                return this.doItAgain()
            this.s += ' = ' + answer
            this.answer = value
        } else {
            let value = this.numbergen.getRandomNumber()
            let expr = replace('x', value, this.s)
            let answer = this.getAnswer(expr)
            if (!this.isValidAnswer(answer))
                return this.doItAgain()
            this.s += ' = ' + answer
            this.answer = value
        }
        this.config.mode = null
    }

    isValidAnswer(answer) {
        if (answer == null) return false
        if (this.config.onlyPositive && answer < 0) return false
        return true
    }

    get value() {
        return {
            question: stylemath(this.s),
            answer: this.answer,
        }
    }

    loadTemplate(template) {
        if (!template) {
            //console.throw()

            throw ''
            console.log('no template')
            return
        }
        this.s = template
        this.original = template
        this.numbergen.reset()
    }

    next(template) {
        this.loadTemplate(template)

        /* -------------------------------------- New Addition */
        if (
            this.config.onlyIntegerAnswers &&
            this.config.level > 1
        ) {
            this.numbergen.templateRef = this.original
        } else {
            this.numbergen.templateRef = null
        }
        /* -------------------------------------- New Addition */

        if (hasVariableX(this.s)) {
            if (!hasEquals(this.s)) this.s += ' = 0'
            this.populate()
            this.answer = nerdsolver(this.s)
        } else {
            if (this.config.withVariables) this.withVariables()
            this.withNumbers()
            this.withEquals()
        }

        return this.value
    }

    populate() {
        this.replace(/[abcdefg]/g, (key) =>
            this.numbergen.getCached(key)
        )
    }

    doItAgain() {
        return this.next(this.original)
    }

    static repopulateNumbers(s) {
        return s.replace(simpleNumberRE, (x) => {
            return rngAround(x)
        })
    }
}

class InfusionGenerator extends BaseGenerator {
    constructor(...args) {
        super(...args)
        Object.assign(this, StringMixins)
    }

    withNumbers() {
        const runnerA = (s) =>
            isFraction(s)
                ? this.numbergen.getRandomFraction()
                : s == 'n'
                ? NumberGen.getNumber(this.config.level)
                : this.config.useVariablesInAnswer &&
                  coinflip(0.35) &&
                  !this.numbergen.cache.has(s)
                ? s.toUpperCase()
                : this.numbergen.getCached(s)

        const runnerB = (s) =>
            this.config.addZerosOrDecimals
                ? zeroify(
                      s,
                      rangegetter(
                          this.config.addZerosOrDecimals,
                          this.config.level
                      )
                  )
                : s

        this.replace(abcdeFractionRE, (s) => {
            if (s.length == 1) {
                return runnerB(runnerA(s))
            }
            let p = iteration(s, runnerA, '', '*')
            p = runnerB(matheval(p))
            return p
        })
    }

    withVariables(letter = 'x') {
        if (test(letter, this.s)) return
        const matches = this.s.match(abcdeRE)
        const match = randomPick(matches)
        this.replace(match, letter, 'g')
    }

    getAnswer(s) {
        let answer = MathSolver.evaluate(s)
        let value = this.config.asDecimal
            ? fixFloatingPoint(answer)
            : fractionize(answer)
        if (isInteger(value) && this.mode == 'question')
            value = randomlyAddZeroes(value)
        return value
    }
    getAnswer2(s) {
        let isDivision = false
        let asDecimal = this.config.answerAsDecimal

        if (test('÷', s)) {
            s = s.replace(/ ?÷ ?/g, '/')
            isDivision = true
        }

        let answer
        let prelim = tryval(s)
        if (isNumber(prelim)) {
            answer = prelim
        } else if (test(/x/, s)) {
            answer = nerdsolver(s)
        } else {
            answer = nerdamer(s).evaluate().toString()
            asDecimal = false
        }

        if (isDivision) {
            if (this.config.mode == 'terminating-decimal') {
                if (hasTerminatingDecimal(answer)) {
                    return answer
                } else {
                    return
                }
            } else {
                return mathTruncate(answer)
            }
        }

        let value = asDecimal
            ? fixFloatingPoint(answer)
            : fractionize(answer)
        if (isInteger(value) && this.sMode == 'question')
            value = randomlyAddZeroes(value)
        return value
    }

    withEquals() {
        if (test(/=/, this.s)) {
            this.answer = fractionize(nerdsolver(this.s))
        } else if (!test(/x/, this.s)) {
            let answer = this.getAnswer(this.s)
            if (!this.isValidAnswer(answer)) {
                return this.doItAgain()
            }
            this.s += ' = '
            this.answer = answer
        } else if (test(xfracRE, this.s)) {
            let value = this.numbergen.getRandomFraction()
            let expr = replace(xfracRE, value, this.s)
            this.replace(xfracRE, 'x')
            let answer = this.getAnswer(expr)
            if (!this.isValidAnswer(answer))
                return this.doItAgain()
            this.s += ' = ' + answer
            this.answer = value
        } else {
            let value = this.numbergen.getRandomNumber()
            let expr = replace('x', value, this.s)
            let answer = this.getAnswer(expr)
            if (!this.isValidAnswer(answer))
                return this.doItAgain()
            this.s += ' = ' + answer
            this.answer = value
        }
        this.config.mode = null
    }

    isValidAnswer(answer) {
        if (answer == null) return false
        if (this.config.onlyPositive && answer < 0) return false
        return true
    }

    get value() {
        return {
            question: stylemath(this.s),
            answer: this.answer,
        }
    }

    loadTemplate(template) {
        if (!template) {
            throw ''
            return
        }
        this.s = template
        this.original = template
        this.numbergen.reset()
    }

    create(template) {
        this.loadTemplate(template)

        /* -------------------------------------- New Addition */
        if (
            this.config.onlyIntegerAnswers &&
            this.config.level > 1
        ) {
            this.numbergen.templateRef = this.original
        } else {
            this.numbergen.templateRef = null
        }
        /* -------------------------------------- New Addition */

        if (hasVariableX(this.s)) {
            if (!hasEquals(this.s)) this.s += ' = 0'
            this.populate()
            this.answer = nerdsolver(this.s)
        } else {
            if (this.config.withVariables) this.withVariables()
            this.withNumbers()
            this.withEquals()
        }

        return this.value
    }

    populate() {
        this.replace(/[abcdefg]/g, (key) =>
            this.numbergen.getCached(key)
        )
    }

    doItAgain() {
        return this.next(this.original)
    }

    static repopulateNumbers(s) {
        return s.replace(simpleNumberRE, (x) => {
            return rngAround(x)
        })
    }
}

const InfusionMasterConfig = {
    4: {
        solveForX: ['a + b', 'a - b', 'a * b'],

        solve: [
            'a + b',
            'a - b',
            'a * b',
            'a + b * c',
            'a + b - c',
            'a + b + c',
            'a * b * c',
            'a - b + a * a + d',
        ],
    },

    5: {
        solveForX: [
            'a + b * c',
            'a + b - c',
            'a + b + c',
            'a * b * c',
            'a - b + a * a + d',
        ],

        solve: [
            'a + b * c',
            'a + b - c',
            'a + b + c',
            'a * b * c',
            'a - b + a * a + d',
            'a/b + c/d',
            'a/b - c/d',
            'a/a + a/b',
            'a/b * c',
        ],
    },

    6: {
        solveForX: [
            'a + b * c',
            'a + b - c',
            'a + b + c',
            'a * b * c',
            'a - b + a * a + d',
            'a/a + a/b',
            'a/b * c',
            'a * b/c',
            'a + b * c + d',
            '(a + b) * (c + d)',
            '(a - b) * (c + d)',
            '(a + b) * (c - d)',
            '(a + b) * (c + d)',
            'a * (b - c * d)',
            'a + (b + c * d)',
        ],

        solve: [
            'a * b * c',
            'a * b * c * d',
            'a - b + a * a + d',
            'a/b + c/d',
            'a/b - c/d',
            'a/a + a/b',
            'a/b * c',
            'a/b + c/d',
            'a/b - c/d',
            'a/a + a/b',
            'a/b * c',
            'a * b/c',
            'a + b * c + d',
            '(a + b) * (c + d)',
            '(a - b) * (c + d)',
            '(a + b) * (c - d)',
            '(a + b) * (c + d)',
            'a * (b - c * d)',
            'a + (b + c * d)',
        ],
    },
}

const infusionlib = {
    random: [['ax + b = x^2']],
    populate: [
        ['ax + b = cx + d', 'ax + b = c'],
        '(ax + b)/c = dx + e',
    ],
    addition: [['a + a + a', 'a + a + a + a', 'a + b']],
    'fraction-addition': ['a/b + c/d'],
    division: [
        //'a ÷ b',
        '(a ÷ b) ÷ c',
    ],

    'long-division': [
        { template: 'a ÷ b', mode: 'terminating-decimal' },
        { template: 'a ÷ b', mode: 'long-division' },
    ],
}
const InfusionTemplates = [
    'a ÷ b',
    'a + b',
    'a - b',
    'a * b',
    'a + b * c',
    'a + b - c',
    'a + b + c',
    'a * b * c',
    'a - b + a * a + d',
    '(a + b * c) - d * e + c',
    'a/b + c/d',
    'a/b - c/d',
    'a/a + a/b',
    'a/b * c',
    'a * b/c',
    'a + b * c + d',
    '(a + b) * (c + d)',
    '(a - b) * (c + d)',
    '(a + b) * (c - d)',
    '(a + b) * (c + d)',
    'a * (b - c * d)',
    'a + (b + c * d)',
    'a/b - c/d + a/d',
]

class OldQuestionGenerator {
    isFresh(item) {
        if (!this.watcher)
            this.watcher = new Watcher((x) => x.question)
        return this.watcher.isFresh(item)
    }
    constructor(key) {
        this.loadGenerator(key)
        this.config = {
            useVariablesInQuestion: null,
            onlyPositiveAnswers: null,
            onlyIntegerAnswers: null,
            level: 1,
        }
        this.index = 0
    }

    next(template) {
        return this.generator.next(template)
    }

    loadGenerator(key) {
        const dict = {
            infusion: Infusion,
        }
        const Generator = dict[key || 'infusion']
        this.generator = new Generator()
    }

    setRequirement(requirement) {
        this.tempRequirement = requirement
    }
    allow() {
        //return
        this.bypassValidationCheck = true
    }
    validationcheck(x, count) {
        if (count > 5) {
            console.log(x)
        }

        if (count > 10) {
            //tl(  )
        }
        if (this.tempRequirement) {
            console.log('has temp requirement')
            if (this.tempRequirement(x.answer ? x.answer : x)) {
                console.log('passed')
                this.tempRequirement = null
                return true
            }
            return false
        }
        //return true

        if (count > 18) {
            //console.log(count, x)
            if (this.bypassValidationCheck) {
                console.log('bypassing validation')
                this.bypassValidationCheck = false
                console.log('bypassing and allowing')
                return true
            }
        }

        if (
            this.config.useVariablesInAnswer &&
            looksLikeMixedVariableAnswer(x.answer)
        ) {
            return true
        }

        if (this.config.onlyIntegerAnswers) {
            if (isFraction(x.answer)) {
                return false
            }
        }

        if (
            this.config.onlyPositiveAnswers &&
            parseInt(x.answer) <= 0
        ) {
            return false
        }

        return true
        if (test(/percentage/, x.question)) return true
        if (parseInt(x.answer) == 0) {
            console.log('equals zero')
            return false
        }

        if (test(/\d+\/\d+/, x.answer)) {
            if (test(/fraction/i, x.question)) return true
            if (isInfusionTemplate(x.question)) return true
            console.log('no fractions')
            return false
        }

        return true
    }
}
function medley(obj, ...args) {
    const generator = new obj()
    const store = []

    let [a, b, c, d] = getMedleyArgs(args)
    for (
        let i = a;
        i <= Math.min(b, generator.templates.length - 1);
        i++
    ) {
        generator.index = i
        for (let j = c; j <= d; j++) {
            //console.log(i, j)
            generator.difficulty = j
            store.push(generator.next())
            if (
                generator.config.medleyLimit &&
                store.length == generator.config.medleyLimit
            ) {
                return store
            }
        }
    }
    return store
}

function fractionrng() {
    let a = rng(2, 9)
    let temp = rng(1, 5)
    let b = Math.abs(a - temp)
    if (b == 0) b = 1
    if (b == a) {
        a += rng(1, 5)
    }

    return toFractionString(b, a)
}

function fgen(fn, n = 5, ...args) {
    const store = []

    function create() {
        let value = fn(...args)
        store.includes(value) ? create() : store.push(value)
    }

    for (let i = 0; i < n; i++) {
        create()
    }

    return store
}

function mathmaker(questions) {
    function valid(answer) {
        if (isNull(answer)) return true
        answer = parseFloat(answer)
        if (answer == 0) return false
        if (answer == 100) return false
        if (isDecimal(answer)) return false
        return true
    }

    function creator(item) {
        const question = mathtemplater2(item.question)
        console.log(getnumbers(question))
        const answer = mathtemplater2(
            item.answer,
            getnumbers(question)
        )
        return { question, answer }
    }

    function runner(item) {
        let count = 0
        while (count++ < 10) {
            const payload = creator(item)
            if (valid(payload.answer)) {
                console.log(count, 'count')
                return payload
            }
        }
        throw 'count too much'
    }

    return questions.map(runner)
}

const studenttutoringdict = [
    {
        student: 'Alan Tsoy',
        parent: 'Andrei Huzak',
        parentEmail: 'omfg83@gmail.com',
        parentPhone: '508-292-0954',
        studentPhone: '408-551-0570',
        studentGrade: 11,
        subject: 'SAT Prep',
        rate: '40$/90min',
    },
]
function payroll() {
    const fetch = require('node-fetch')
    if (!isEndOfMonth()) {
        console.log('not time yet for payroll')
        return
    }
    const W = wrapfactory(request)
    for (let item of tutoringlist) {
        const { rate, student, parentEmail, subject } = item
        const to = parentEmail
        const name = getStudentName(studentName)
        const title = studentName + ' ' + subject
        const money = calculateInvoice()
        const body = new HtmlTable([
            ['date', 'time'],
            ...calculateTutoringHours(name),
            ['total', 'rate'],
        ])
        W({ to, title, body: body.toString() })
    }
}

function calculateGradeFromStudentReference(student) {
    const year = new Date().getFullYear()
    const { startDate, grade } = ref[student]
    return grade + year - startDate
}
function calculateGradeFromBirthYear(birthyear) {
    const [month, year] = getMonthAndYear()
    if (month < 6) year -= 1
    console.log(year, 'adf')
    return year - 5 - birthyear
}

function namePasswordCipher(name) {
    name = name.toLowerCase()
    //school
    const length = name.length
    return name
        .split('')
        .map((x) => {
            let n = char2n(x) + length
            //console.log(n)
            if (n > 26) n -= 26
            n %= 26
            //console.log(n)
            const p = n2char(n)
            //console.log(p, 'p')
            return p
        })
        .join('')
}

function namePasswordDecipher(name) {
    name = name.toLowerCase()
    //school
    const length = name.length
    return name
        .split('')
        .map((x) => {
            let n = char2n(x) - length
            if (n < 0) n += 26
            return n2char(n)
        })
        .join('')
        .toUpperCase()
}

function getRandomColor() {
    var letters = '0123456789ABCDEF'
    var color = '#'
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)]
    }
    return color
}

function svgShapeMaker() {
    const toHtml = ([x, y]) => {
        const fill = getRandomColor()
        const r = 3
        return `<circle cx=${x} cy=${y} r=${r} fill=${fill}></circle>`
    }
    const coordinates = [
        [0, 0],
        [0, 2],
        [2, 0],
        [0, -2],
        [-2, 0],
        [1, 1],
        [1, -1],
        [-1, 1],
        [-1, -1],
    ]
        .map(multiplier(10))
        .map(translater(0, 0))
        .map(toHtml)
    return coordinates
}

function translater(a, b) {
    return (x) => x.map((el, i) => (i == 0 ? el + a : el + b))
}

function multiplier(n) {
    return (x) => x.map((el) => el * n)
}

function solveFractionExpression(s) {
    //console.log(s)
    let parts = s.split(/ ([\+\-\*]) /)
    let operator
    let store = []
    for (let part of parts) {
        if (part.length == 1) {
            operator = part
        } else {
            store.push(...getnumbers(part))
            if (store.length == 4) {
                let [a, b, c, d] = store
                let A = a * d
                let B = b * c
                let bottom = b * d
                let top = operator == '+' ? A + B : A - B
                store = simplifyFraction(top, bottom)
            }
        }
    }
    return store
}

function toLatex(s) {
    return s.replace(/\w+[\/^]\w+|[×·*]/g, (x) => {
        if (x == '*' || x == '×') return '\\times'
        if (x == '·') return '\\cdot'
        if (x.includes('/')) {
            let [a, b] = x.split('/')
            return `\\frac{${a}}{${b}}`
        }

        if (x.includes('^')) {
            let [a, b] = x.split('^')
            return `${a}^{${b}}`
        }
    })
}
function gcd(a, b, ...args) {
    if (args.length > 0) {
        return [a, b, ...args].reduce((acc, item) =>
            gcd(acc, item)
        )
    }
    if (a == 0) return b

    while (b != 0) {
        if (a > b) a = a - b
        else {
            b = b - a
        }
    }
    return a
}
function gcd(a, b, ...args) {
    if (args.length > 0)
        return [a, b, ...args].reduce((acc, item) =>
            gcd(acc, item)
        )
    a = Math.abs(a)
    b = Math.abs(b)
    if (b > a) {
        var temp = a
        a = b
        b = temp
    }
    while (true) {
        counter(a, b, args)
        if (b == 0) return a
        a %= b
        if (a == 0) return b
        b %= a
    }
}

function simplifyRatio(a, b) {
    let g = gcd(a, b)
    return [a, b].map((x) => x / g)
}

function simplify(a, b) {
    let g = gcd(a, b)
    return [a, b].map((x) => x / g)
}

function simplifyFraction(a, b) {
    if (hasDecimal(a)) {
        let factor = Math.pow(10, countDecimalPlaces(a))
        a *= factor
        b *= factor
    }
    if (hasDecimal(b)) {
        let factor = Math.pow(10, countDecimalPlaces(b))
        b *= factor
        a *= factor
    }
    let g = gcd(a, b)
    return [a, b].map((x) => x / g)
}

function fractiongetter(args) {
    if (isArray(args[0])) {
        return args[0]
    }

    if (args.length == 2) {
        return args
    }
    if (isString(args[0])) {
        return args[0].split('/')
    }
    if (args.length == 1) {
        if (isArray(args[0])) {
            return args[0]
        }
    }
}

function toFractionString(...args) {
    let [a, b] = fractiongetter(args)
    if (a == 0) return 0
    if (b == 0) throw ''
    if (a == b) return 1
    if (a % b == 0) return a / b
    return latex.dfrac(a, b)
    return a + '/' + b
}

function isFractionString(expr) {
    return expr.includes('/')
}

const formulas = {
    distance(r, t) {
        return r * t
    },
    rectangle: {
        perimeter: (a, b) => 2 * (a + b),
        area: (a, b) => a * b,
    },

    triangle: {
        area: (b, h) => (b * h) / 2,
    },

    square: {
        perimeter: (a, b) => 2 * a * b,
        area: (a, b) => a * b,
    },

    prism: {
        surfaceArea: (a, b, c) => 2 * (a * b + b * c + c * a),
        volume: (a, b, c) => a * b * c,
    },

    circle: {
        area: (r) => Math.PI * r * r,
        perimeter: (r) => Math.PI * r * 2,
    },

    sphere: {
        surfaceArea: (r) => 4 * Math.PI * r * r,
        volume: (r) => ((4 * Math.PI) / 3) * r * r * r,
    },

    cylinder: {
        surfaceArea: (r, h) => 2 * (a * b + b * c + c * a),
        volume: (r, h) => Math.PI * r * r * h,
    },
}

function geometryEquality() {
    a = 1
    b = 10
    for (let i = a; i <= b; i++) {
        for (let j = i; j <= b; j++) {
            let p = formulas.rectangle.perimeter(i, j)
            let a = formulas.rectangle.area(i, j)
            console.log({ p, a, i, j })
        }
    }
}
function extracterOfCss() {
    s = read('layout.css')
    r = /(\w+) {([^]+?)\}/g
    r2 = /([\w-]+) *: *([\w\W]+?)(?=$|[\w-]+ *:)/g
    store = {}
    let items = findall(r, s).forEach((x) => {
        const items = findall(r2, x[1].trim()).map(([a, b]) => {
            return [a.trim(), b.trim().replace(/;/g, '')]
        })
        //return {[x[0]]: zip(items)}
        store[x[0]] = zip(items)
    })
    console.log(stringify(store))
    return
    console.log(stringify(items))
}

function syllabify(words) {
    const syllableRegex =
        /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi
    return words.match(syllableRegex)
}

function hasDecimal(x, n = 0) {
    return test('\\.' + '\\d'.repeat(n), String(x))
    // n is the number of decimal places to match.
}

function isSquare(x) {
    return !hasDecimal(Math.sqrt(x))
}

function isCube(x) {
    return !hasDecimal(Math.cbrt(x))
}

class MathTextLexer {
    // too hard.
    constructor(s) {
        this.s = s
        this.run()
    }
    run() {
        const ofRE = /(\w+) of (\d+|(?:a|its) \w+)/g
        const isEqualToRE = / is equal to /
        this.children = this.s.split(isEqualToRE)
        for (let child of this.children) {
            const matches = findall(ofRE, child).map((x) => {
                let [adj, noun] = [
                    x[0],
                    x[1].replace(/(?:a|its) /g, ''),
                ]
                return [adj, noun]
            })
            console.log(matches)
        }
    }
}

class BaseTokenizer {
    mreplace(...regexes) {
        for (let r of regexes) {
            ;[this.s, this.match] = mreplace(
                r,
                '',
                this.s,
                'gi',
                true
            )
            if (this.match) break
        }
    }
    findall(r) {
        this.matches = findall(r, this.s, 'gi')
    }

    static tokenize(s, Tokenizer) {
        const tokenizer = new Tokenizer(s)
        tokenizer.run()
        return tokenizer.value
    }
    getValue() {
        this.run()
    }
    get value() {
        return this.store
    }

    constructor(s) {
        this.s = s.trim()
        this.store = []
        this.nullCount = 0
    }

    trimSpaces() {
        this.s = this.s.trim()
    }

    replace(regex, replacement) {
        this.s = this.s.replace(regex, replacement)
    }

    eat(regex, mode) {
        const r = RegExp(
            '^' + (isString(regex) ? regex : regex.source)
        )
        //console.log(r)
        const match = this.s.match(r)
        if (match) {
            this.nullCount = 0
            this.s = this.s.slice(match[0].length)
            this.match = matchgetter(match)
            //this.trimSpaces()
            if (mode == 'join') {
                appendLast(this.store, this.match)
            } else {
                this.store.push(this.match)
            }
            return this.match
        } else {
            this.nullCount += 1
            return null
        }
    }
}

class Tokenizer2 {
    static tokenize(s) {
        const tokenizer = new Tokenizer2(s)
        tokenizer.run()
        return tokenizer.value
    }
    get value() {
        return this.store
    }
    constructor(s) {
        this.s = s
        this.store = []
    }

    trimSpaces() {
        this.s = this.s.trim()
    }

    run() {
        const mathOperatorRE =
            / *([\+\-\*]) *|(?<=\d)(?=\\)| *and */
        const items = this.s
            .split(mathOperatorRE)
            .filter((x) => x)
        for (let item of items) {
            this.parser(item)
        }
    }
    parser(item) {
        this.store.push(item)
    }
}

class Tokenizer {
    static tokenize(s) {
        if (!s.includes('{')) s = toLatex(s)
        const tokenizer = new Tokenizer(s)
        tokenizer.run()
        return tokenizer.value
    }
    get value() {
        return this.store
    }
    constructor(s) {
        this.s = s
        this.store = []
    }

    trimSpaces() {
        this.s = this.s.trim()
    }

    run() {
        const mathOperatorRE =
            / *([\+\-\*]) *|(?<=\d)(?=\\)| *and */
        const items = this.s
            .split(mathOperatorRE)
            .filter((x) => x)
        for (let item of items) {
            this.parser(item)
        }
    }

    parser(s) {
        function runner(s) {
            if (s == 'exponent' || s == 'fraction') {
                return s
            }

            if (isLatexExponent(s)) {
                const [a, b] = findClosingBracketIndex(s)
                const parts = [
                    s.slice(0, a - 1),
                    s.slice(a + 1, b),
                ]
                parts.push('exponent')
                return parts.map(runner)
            } else if (isLatexOperator(s)) {
                return s
            } else if (isNumber(s)) {
                return s
            } else {
                console.log(s)
                const indexes = findClosingBracketIndex(s)
                const [start, end] = indexes
                const parts = [
                    s.slice(start + 1, end),
                    s.slice(end + 2, -1),
                ]
                parts.push('fraction')
                return parts.map(runner)
            }
        }

        const tree = runner(s)
        this.store.push(tree)
    }

    parse() {
        let regex = /\\.*?\} | *[\+\-\*] */
        let match = search(regex, this.s)
        if (match) {
            this.s = this.s.slice(match.length)
            this.trimSpaces()
            console.log(match, 'm')
        }
    }
}

let calculation

class Mathstuff {
    constructor(templates) {
        this.cache = {}
    }
    predeterminedAnswer(answer) {}
}

function doubletemplater(
    template,
    minValue,
    maxValue,
    predeterminedAnswer
) {
    if (typeof calculation === 'undefined') {
        calculation = new Calculation()
    }

    const mathDollarRE = /\$({.*?}|[\w-^*]+|\[.*?\])/g
    const cache = new Cache()
    let [question, answer] = template.split(/(?<=\?) /)
    if (exists(predeterminedAnswer)) {
        cache.set('a', predeterminedAnswer)
    }

    const rangedletterdict = {
        a: [1, 5],
        b: [2, 7],
        c: [5, 9],
    }

    function runner(_, x) {
        if (x.startsWith('[')) return randomStringPick(x)
        if (!hasMathOperation(x)) return x

        let e = x.startsWith('{') ? x.slice(1, -1) : x
        e = e.replace(/[abcde]/g, (letter) => {
            return cache.get(
                letter,
                rng(...rangedletterdict[letter])
            )
        })
        //console.log(e)

        let calculated = calculation.calculate(e)

        //return calculated
        if (
            (maxValue && calculated > maxValue) ||
            (minValue && calculated < minValue)
        ) {
            console.log('do it agian')

            cache.reset()

            if (maxValue && calculated > maxValue) {
                editDict(rangedletterdict, (v) => [
                    v[0],
                    v[1] - 1,
                ])
            } else if (minValue && calculated < minValue) {
                editDict(rangedletterdict, (v) => [
                    v[0] - 1,
                    v[1],
                ])
            }

            return runner(null, x)
        }
        return calculated
    }

    question = question.replace(mathDollarRE, runner)

    if (predeterminedAnswer) {
        answer = predeterminedAnswer
    } else {
        console.log('replacing answer')
        answer = answer.replace(mathDollarRE, runner)
    }
    return { question, answer }
}

function hasMathOperation(x) {
    return test(/[^*+-]/, x)
}

function randomStringPick(x) {
    return randomPick(
        x.trim().slice(1, -1).split(/, ?/).map(toNumber)
    )
}

function templater(template, minValue, maxValue) {
    if (typeof calculation === 'undefined') {
        calculation = new Calculation()
    }

    const mathDollarRE = /\$({.*?}|[\w-^*]+|\[.*?\])/g
    const cache = new Cache()

    function templateRunner(_, x) {
        if (x.startsWith('[')) {
            return randomPick(
                x.trim().slice(1, -1).split(/, ?/)
            )
        }
        if (!test(/[^*+-]/, x)) {
            return x
        }

        let e = x.startsWith('{') ? x.slice(1, -1) : x
        //console.log(e, 'e')
        //e = e.replace(mathDollarRE, e)
        e = e.replace(/[abcde]/g, (letter) => {
            let value = cache.get(
                letter,
                rng(...rangedletterdict[letter])
            )
            console.log(letter, value)
            return value
        })

        let calculated = calculation.calculate(e)

        if (__count__++ == 20) tl()

        if (
            (maxValue && calculated > maxValue) ||
            (minValue && calculated < minValue)
        ) {
            console.log('do it agian')

            cache.reset()

            if (maxValue && calculated > maxValue) {
                editDict(rangedletterdict, (v) => [
                    v[0],
                    v[1] - 1,
                ])
            } else if (minValue && calculated < minValue) {
                editDict(rangedletterdict, (v) => [
                    v[0] - 1,
                    v[1],
                ])
            }

            return templateRunner(null, x)
        }
        return calculated
    }

    const rangedletterdict = {
        a: [1, 5],
        b: [2, 7],
        c: [5, 9],
    }

    let calculated = template.replace(
        mathDollarRE,
        templateRunner
    )
    __count__ = 0
    return calculated
}

function mathWorkBackwardsFromAnswer(answer, template) {
    // doesnt work
    answer = 5
    template = '$e - $b - $c'
    console.log('adfasdf')
    console.log(Tokenizer2.tokenize(template))
    tl()
    while (true) {
        s = template.replace(mathDollarRE, () => rng())
        console.log(s)
        console.log(eval(s))
        if (eval(s) == answer) return s
        else {
            counter(1000)
        }
    }
    console.log(s)
}

const mathDollarRE = /\$({.*?}|[\w-^*]+|\[.*?\])/g

function randomlyAddZeroes(n) {
    tl('adding zeroes')
    return coinflip(0.1) ? n + '.' + '0'.repeat(rng(3, 5)) : n
}

function tryval(s) {
    try {
        return eval(s)
    } catch {
        return null
    }
}

function mathjsSolver(s, asDecimal, truncate) {
    // i feel like therea re better alternatives
    s = s.replace(/ *= *\?$/, '')

    if (test('÷', s)) {
        s = s.replace(/ ?÷ ?/g, '/')
        asDecimal = true
        if (!truncate) truncate = true
    }

    const answer = hasJavascript(s) ? eval(s) : nerdeval(s)

    if (truncate) return mathTruncate(answer)
    let value = asDecimal
        ? fixFloatingPoint(answer)
        : fractionize(answer)
    if (isInteger(value)) value = randomlyAddZeroes(value)
    return value
}

const EXPRESSIONS = {
    fractions: [
        '3/4 - 2/5',
        '1/3 + 324',
        '1/3 * 324',
        '1 - 1/3 * 2/3',
    ],
    nerdamer: [
        'x^3-3*x^2-10x + x',
        'x^3-3*x^2-10x',
        'x^2-3*x^1-10',
        'x^2 - y^2',
        'x^2 - 100',
        '100 - a^2',
    ],
}

function anytest(s, re) {
    const items = re.split('')
    return test(ncg(items, 'e'), String(s))
}

const mathExpressionDict = {
    'times more than': 'x',
    'times less than': 'x',
    'more than': 'x',
    'less than': 'x',
    less: '-',
    of: '*',
    difference: '*',
    sum: '*',
    times: '*',
}
function mathWordProblemToExpression(s) {
    //s = dreplace(s, mathExpressionDict)
    s = '10% more than 5 more than 7'
    s = '10% more than 5 less than 20% of 100 times 50'
    a = (7 + 5) * 1.1
    //items = s.split(/ (?!than)/)
    function parser(_, a, b, c) {
        if (a.includes('%')) {
            if (b == 'more') a = (100 + parseInt(a)) / 100
            else if (b == 'less') a = (100 - parseInt(a)) / 100
        }
        c = parentParser(c)
    }
    function parentParser(s) {
        return s.replace(
            /(\S+(?: times)?) (more|less) than (.+)/,
            parser
        )
    }

    s = parentParser(s)
    tl(s)
    let temp
}

function math0916(withVariables = false) {
    const g = new QuestionGenerator('infusion')
    g.generator.config.withVariables = withVariables
    const items = g.medley(20, 2)
    console.log(items)
    return items
}

function mathReverse(s) {
    if (test(/[xyz]$/, s)) return reverse(s)
    return s
    // it needs to be a little bit more nuanced than this because 10 is getting placed as 01.
    // additionally, sometimes the reversal is not happening
    // the API did the job, but it did not make it clean.
}
function mathSortByExponent(s) {
    let match = search(/[a-zA-Z]\^(\d+)/, s)
    if (match) return Number(match)
    else if (isNumber(s.replace(/^[-+]/, ''))) return 0
    else {
        return 1
    }
}
function formatNerdamer(s) {
    return fixNerdamerExpression(s)
}

function fixNerdamer(s) {
    //return s
    s = s.replace(/(\d+) \\cdot (\{?x)/g, (_, a, b) => a + b)
    return s
    const items = s.split(/ *(\+|-|\\cdot) */).filter(exists)
    console.log(items)
    items.reverse()
    return items.join(' ')
}
function fixNerdamerExpression(s) {
    if (!isString(s)) {
        s = s.toString()
    }
    const sorter = sortfactory(
        mathSortByExponent,
        true /* reverse */
    )
    let original = s
    console.log(original, 'original')
    s = s.replace(/abs\((.*?)\)/g, (_, x) => x)
    const operators = ['+', '-', '*']
    s = s.replace(/sqrt\((.*?)\^2\)/g, '$1')

    s = s.replace(/-\d+\+/g, (x) => x.slice(1, -1) + '-')
    s = s.replace(/(?<=\().*?(?=\))/g, mathReverse)

    if (s.includes('undef') || s.length < original - 3) {
        tl('um no undef')
        s = original
        s = s.replace(/(?<=\().*?(?=\))/g, (x) => {
            let parts = x
                .split(/(?<!^)(?=[\+\-])/)
                .map((x) => x.replace(/^\+/, ''))
            parts.sort(sorter)
            return parts.join('')
        })
    }

    s = s.replace(/-(\w+) *\+ *(\w+)/g, '$2 - $1')
    s = spaceTheMathOperators(s)
    return s
}

function spaceTheMathOperators(s) {
    console.log(s, 's')

    return s.replace(/.[\+\-\*/]./g, (x) => {
        let [a, b, c] = x.split('')
        if (b == '*' && isLetter(a) && isLetter(c)) {
            return a + c
        }
        let temp = ''
        if (a == ' ') temp += a
        else temp += a + ' '
        temp += b
        if (c == ' ') temp += c
        else temp += ' ' + c
        return temp
    })
}

function createFunctionFromTemplate(s) {
    const variables = unique(s.match(/[a-zA-Z]+/g))
    // not robust because y ou could have things like 'let' and 'const' being removed.
    s = s.replace(/\$/g, '')
    const body = 'return ' + s
    const func = new Function(...variables, body)
    return func
}

function mathstringer(items, difficulty = 3, level = 0) {
    //const filterfn = (item) => item.fn && (!item.difficulty || item.difficulty < difficulty)
    const filterfn = (item) => item.fn

    const mapfn = (item) => {
        //let store = new GatedArray()
        let store = []
        let range = item.levels
            ? item.levels[level]
            : item.range
        let [a, b] = range
        let s = ''

        for (let i = a; i <= b; i++) {
            if (item.skip && i % 10 == 0) continue
            let value = item.fn(i)
            //store.add(value)
            store.push(value)
        }

        return store.value
    }

    //return items.map(mapfn)
    return items.filter(filterfn).map(mapfn)
}

function mathBackwards(answer, template) {
    calculator = new Calculation()
    answer = 5
    template = '$e - $b - $c'
    f = createFunctionFromTemplate(template)
    numbers = range(count('$', template)).map((x) => rng())
    //s = template.replace(mathDollarRE, () => rng())

    while (true) {
        let calculated = f(...numbers)
        console.log(numbers)
        console.log(calculated)
        let delta = calculated - answer
        let index = rng(0, numbers.length - 1)
        let direction = delta > 1 ? -1 : 1

        numbers[index] = numbers[index] + 1
        if (delta == 0) return s
    }
    console.log(s)
}

const mathstrings = [
    {
        description: '[1-99, 2-98 ... 50-50]',
        range: [1, 50],
        //fn: (i) => [i, 100 - i],
    },

    {
        range: [3, 5],
        //fn: (i) => range(i, 5).map(x => ([x, i]))
    },

    {
        range: [36, 36],
        description: 'difference of squares',
        difficulty: 3,
        //fn: (i) => range(1,5).map(x =>  [i + x, i - x, (i + x) * (i - x), x * x, i * i])
    },

    {
        levels: [
            [41, 59],
            [91, 109],
        ],
        description: '9801 trick',
        difficulty: 2,
        //return [i, i, i * i]
    },
]

function zoop(a, b) {
    return a + b
}

function displayemoji(s) {
    return '💃'
}

function prepareVariablesForFunction(fn) {
    return (s) => {
        let args = s.split(/, /)
        return fn(...args)
    }
}

function getRngLevel(level) {
    switch (level) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            return [5, 50]
        default:
            return [1, 10]
    }
}

function fixgrammar(s) {
    s = fixSentencePluralization(s)
    return s
}

function fractionToPercent(a, b) {
    return 100 * (a / b) + '%'
}

const questionText = `

    $a/$b is equivalent to what percentage?
    fractionToPercent(a,b)

    $name only eats $food. $name\'s mom buys a box of $a $food and $name eats $aa of them. What percentage of the box was NOT $food?
    fractionToPercent((a - b), a)
    
`

function toObject(arr, ...keys) {
    return zip(keys, arr)
}

function dedent(s, n = 4) {
    return replace('^' + ' *', '', s.trim())
    return replace('^' + toSpaces(n), '', s)
}

function dollarBracket(s) {
    const [startBracket, endBracket] = ['[', ']']
    if (test(/^[a-zA-Z]{3,}/, s)) return '$' + s
    return (
        '$' +
        startBracket +
        s.replace(/.$/, (x) => {
            if (x == '%') return endBracket + x
            return x + endBracket
        })
    )
}
function second(...args) {
    function wrapper(x, i) {
        return args[i] ? args[i](x) : x
    }
    return wrapper
}
function makemathmaker(questionText) {
    return dedent(questionText)
        .split(/\n\n+/)
        .map((x) =>
            toObject(
                x.split(/\n/).map(second(null, dollarBracket)),
                'question',
                'answer'
            )
        )
}

function countSyllables(word) {
    word = word.toLowerCase()
    if (word.length <= 3) {
        return 1
    }
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '')
    word = word.replace(/^y/, '')
    return word.match(/[aeiouy]{1,2}/g).length
}

function wordAnalysis(s, ignore) {
    const words = unique(getProseWords(s))
    const filteredWords = words.filter((word) => {
        if (word.length < 6) return false
        if (countSyllables(word) < 2) return false
        if (ignore && ignore.includes(word)) return false
        return true
    })
    return filteredWords

    const tally = new Tally()
    for (let word of filteredWords) tally.add(word)
    return tally.value
}

function getProseWords(s) {
    const r = /[a-zA-Z]+(?:\'[a-z]|(?:[\.-][a-zA-Z]+)+)?/g
    return s.match(r).map((x) => x.toLowerCase())
}

function includes(arr, key) {
    return arr.includes(key.toLowerCase())
    return arr.findIndex((x) => test(key, x, 'i')) > -1
}
function testmatch(s, dict) {
    for (let [a, b] of prepareIterable(dict, 'entries')) {
        if ((isFunction(a) && a(s)) || test(a, s, 'i')) {
            return b
        }
        //else if (test(a, s, 'i')) {
        //return b
        //}
    }
}
function imatch(s, dict) {
    for (let [a, b] of prepareIterable(dict, 'entries')) {
        let match = search(a, s, 'i')
        if (match) {
            //console.log(a, b)
            //if (__debug__) console.log('function', getFunctionName(b))
            const value = isArray(match)
                ? b(...match.map(toNumber))
                : b(s)
            return value
        }
    }
}

class Solver {
    constructor(s) {
        this.s = s
    }
    static solve(s) {
        return getValue(Solver, s)
    }
    getValue() {
        return this.run()
    }
    getType() {
        //console.log(getWords(this.s)); throw '';
        for (let word of getWords(this.s)) {
            let type = getTypeFromReferenceLib(word)
            if (type) return type
        }
    }
    run() {
        let type = this.getType()
        switch (type) {
            case 'time':
                return this.timeParser()
            default:
                return this.defaultParser()
        }
    }

    defaultParser() {
        let [s, unit] = mreplace(/[a-zA-Z]{3,}/, this.s)
        let value = matheval(s)
        return value + ' ' + unit
    }

    timeParser() {
        function parse(s) {
            const match = search(/(\d+) ?([a-z]+)/i, s)
            if (match) return atSecond(match, depluralize)
            return [s, null]
        }
        let [a, c, b] = this.s.split(/ *([\*\-\+\/]) */)
        //console.log([a,c,b]); throw "";
        let [valA, unitA] = parse(a)
        let [valB, unitB] = parse(b)
        let [ka, kb] = unitConversion2(unitA, unitB)
        let k = mhsd(ka, kb)
        let A = mhsm(valA, k)
        let B = valB
        let expr = A + c + B
        let value = nerdeval(expr)
        return value
    }

    parse(s) {
        const match = search(/(\d+) ?([a-z]+)/i, s)
        if (match) return atSecond(match, depluralize)
        return [s, null]
    }
}
function timeSolver(s) {
    const unitRE = /\d+ \w+/g
    const [target, timeA, timeB] = s.match(unitRE)
    const k = parser(mhsd(timeB, timeA))
    const value1 = mhsm(k, target)
    const value2 = parser2(value1)
    return value2

    function parser2(text) {
        let [s, unit] = mget(/[a-zA-Z]{3,}/, text)
        let value = mathEval(s)
        return value + ' ' + unit
    }

    function parse(s) {
        const match = search(/(\d+) ?([a-z]+)/i, s)
        //console.log(match)
        if (match) return atSecond(match, depluralize)
        return [s, null]
    }
    function parser(s) {
        let [a, c, b] = s.split(/ *([\*\-\+\/]) */)
        let [valA, unitA] = parse(a)
        let [valB, unitB] = parse(b)
        let [ka, kb] = unitConversion2(unitA, unitB)
        let k = mhsd(ka, kb)
        let A = mhsm(valA, k)
        let B = valB
        let expr = A + c + B
        let value = nerdeval(expr)
        return value
    }
}

function getRatioPairs(s) {
    return findall(/(\w+) to (\w+)/g, s)
}
function interweave(item, delimiter, count) {
    /* old verson of interweave */
    // doesnt really work.
    if (isArray(item)) {
        let s = ''
        for (let i = 0; i < item.length; i++) {
            if (delimiter[i]) {
                if (isString(delimiter[i])) {
                    s += item[i]
                    s += wrap(delimiter[i], ' ')
                } else if (isFunction(delimiter[i])) {
                    s += delimiter[i](item[i], item[i + 1])
                    i += 1
                }
            } else {
                s += item[i]
            }
        }
        return s
    }
    let s = item
    for (let i = 0; i < count; i++) {
        s += delimiter
        s += item
    }
    return s
}
function Dict(arr, mode) {
    const length = arr.length
    const halflength = length / 2
    const store = {}

    if (mode == 'l') {
        for (let i = 0; i < halflength; i++) {
            const a = arr[i]
            const b = arr[i + halflength]
            store[a] = toNumber(b)
        }
    } else {
        for (let i = 0; i < length - 1; i += 2) {
            const a = arr[i]
            const b = arr[i + 1]
            store[a] = toNumber(b)
        }
    }

    return store
}
function ratiosolver(s) {
    //console.log(s); throw '';
    const toCount = Math.floor(count('to', s) * 0.5)
    const regexPart = interweave('(\\w+)', ' to ', toCount)
    const endPart = '(\\d+) (\\w+)'
    const regex =
        regexPart + '.*?' + regexPart + '.*?' + endPart
    //console.log({toCount, regex, s, m: search(regex, s)}); throw '';
    const items = search(regex, s)
    //console.log(items); throw "";
    //console.log(s)
    //console.log(items)
    const [number, unit] = items.slice(-2)
    const ref = Dict(items.slice(0, -2), 'l')
    const r = ref[unit]
    const k = number / r
    const words = getWords(s)
    words.reverse()
    const targetregex = ncg(ref)
    const target = words.find((word) => test(targetregex, word))
    console.log({ target })
    return ref[target] * k
}
function r2atiosolver(s) {
    // there is a better one which ihas preceded this
    if (test(/\w+ to \w+ to/, s)) return ratiosolver2(s)
    const [a, b, c, d, e, f] = search(
        /(\w+) to (\w+).*?(\w+) to (\w+).*?(\d+) (\w+)/,
        s
    )
    const ref = {
        [a]: c,
        [b]: d,
    }
    const r = ref[f]
    const k = e / r
    return d * k
}
function mathWordSolver(s) {
    const operationRegexes = Object.keys(
        operationTranslationLib
    )
    const runners = [
        'remaining',
        remainingSolver,

        'percentage of (\\w+) .*?' +
            parens(numberRE) +
            '.*?ratio of (\\w+) to (\\w+)',
        percentageToRatioSolver,

        '^.*?ratio of (\\w+) to (\\w+).*?(\\d+) *: *(\\d+).*?percentage of (\\w+)',
        ratioToPercentageSolver,

        'ratio',
        ratiosolver,

        'every.*?\\. *how',
        timeSolver,

        'find [xyz]\\.',
        solver49,

        multiplencg('^(.+?) (?:$2) (?:$1) (\\w+)', [
            introducers,
            connectors,
        ]),
        (...args) => {
            return convertNumberViaUnit(...args)
        },

        multiplencg('^(?:$1) (\\w+) (?:$2) (.+)', [
            introducers,
            connectors,
        ]),
        (...args) => {
            tl(args)
            console.log('reverse @ convertnumberviaunit')
            return convertNumberViaUnit(...reverse(args))
        },
        /./,
        anySolver,
    ]
    const value = imatch(s, partition(runners))
    return value
    //let answer = spliteval(p, fractionize)
}

function hasWord(s) {
    return /[a-zA-Z]{3,}/.test(s)
}
function spliteval(s, fn) {
    if (hasWord(s)) {
        let [number, word] = s.split(' ')
        return fn(number) + ' ' + word
    } else {
        return fn(s)
    }
}
function getWords(s, min = 2, max = 100) {
    const regex = RegExp(`[a-zA-Z]{${min},${max}}`, 'g')
    return s.match(regex)
}
function shared(a, b) {
    return a.filter((x) => b.includes(x))
}
function getUnitWords(s) {
    const items = flat(Object.values(unitlib))
    //console.log(items)
    //console.log(getWords(s))
    return shared(getWords(s), items)
}

function normalizeUnits(s, getUnit) {
    const words = getUnitWords(s)
    function getSmallestUnit(words) {
        let match = search('\\b[xyzabc] (\\w+)', s)
        if (match) return match
        for (let [k, v] of Object.entries(unitlib)) {
            if (words.some((word) => v.includes(word))) {
                for (let el of v) {
                    if (words.includes(el)) return el
                }
            }
        }
    }

    const unit = getSmallestUnit(words)

    console.log(s, 'adsf')
    s = s.replace(unitNumberRegex, (x) => {
        //console.log(x, 'xm')
        //return x
        return convertNumberViaUnit(x, unit)
    })
    console.log(s, 'adadfasdfasdfsf')

    s = s.replace(numberREGEX, (x) =>
        parens(decimalToFraction(x))
    )
    return getUnit ? [s, unit] : s

    tl(
        'nope. bottom way is a little bit hmm. top way is a little more preconfigured'
    )
    const tally = new Tally(words)
    let target
    let acc = -1
    tally.forEach((k, v) => {
        if (v > acc) {
            acc = v
            target = k
        }
    })

    return target
}
function deleter(items, s) {
    const r = ncg(items)
    return replace(r, '', s, 'gi')
}
function solver49(s) {
    //console.log(s, 'the template for solver49')
    let [expr, unit] = normalizeUnits(s, true)
    let extra = '[\\. ]?'
    const deleteItems = [unit + extra, 'Find.*?\\.']
    expr = deleter(deleteItems, expr)
    expr = dreplace(expr, operationTranslationLib)
    //console.log(expr)
    return solve(expr)
    return expr
    //expr = expr.replace(unit, '').replace(ncg
    // There are so many different variations that are possible.
}

const ratiolib = {
    inches: 72,
    points: 1,
    decades: 3600 * 24 * 365 * 10,
    years: 3600 * 24 * 365,
    months: (3600 * 24 * 365) / 12,
    weeks: 3600 * 24 * 7,
    days: 3600 * 24,
    hours: 3600,
    minutes: 60,
    seconds: 1,
    milliseconds: 0.001,
    meters: 1,
    kilometers: 1000,
    centimeters: 0.01,
    millimeters: 0.001,

    year: 3600 * 24 * 365,
    month: (3600 * 24 * 365) / 12,
    week: 3600 * 24 * 7,
    day: 3600 * 24,
    hour: 3600,
    minute: 60,
    second: 1,
    millisecond: 0.001,
    meter: 1,
    kilometer: 1000,
    centimeter: 0.01,
    millimeter: 0.001,
}
function unitConversion2(from, to) {
    from = pluralize(from)
    to = pluralize(to)
    let a = ratiolib[from]
    if (!to) return a
    let b = ratiolib[to]
    return simplifyRatio(a, b)
}

function unitConversion(from, to) {
    from = pluralize(from)
    to = pluralize(to)
    let a = ratiolib[from]
    if (!to) return a
    let b = ratiolib[to]
    return b / a
}

function convertNumberViaUnit(expr, target) {
    const parts = findall(unitNumberCRE, expr)
    //console.log(expr)
    //console.log(parts)
    let solver = new MathSolver(expr)
    solver.asHelper = true
    return (
        nerdeval(mhsd(solver.getValue(), ratiolib[target])) +
        ' ' +
        target
    )

    console.log(solver.getValue())
    console.log(getValue(MathSolver, expr))
    const answer = sum(parts, ([number, unit]) => {
        let factor = unitConversion2(unit, target)
        console.log(factor)
        return (factor[0] / factor[1]) * number
    })
    return answer + ' ' + target
}

function populate(s) {
    const n = new NumberGen()
    const cache = new Cache()
    return s.replace(/[abcdefg]/g, (x) => {
        return cache.get(x, () => n.getRandomNumber())
    })
}
class CodeTokenizer extends BaseTokenizer {
    constructor(s) {
        super(s)
    }
    getValue() {
        return this.run()
    }

    run() {
        const store = []
        while (true) {
            let match = this.eat(/(\w+)\(/)
            if (match) {
                this.replace(/\)$/, '')
                store.push(match)
            } else {
                break
            }
        }
        const dict = {
            absolute: toPositiveNumber,
        }

        let value = MathSolver.solver(this.s)

        for (let i = store.length - 1; i >= 0; i--) {
            let parser = dict[store[i]]
            //console.log(value)
            value = parser(value)
        }
        return value
    }
}
function toPositiveNumber(x) {
    return isNumber(x)
        ? Math.abs(x)
        : x.toString().replace(/^-/, '')
}

class MathSolver extends BaseTokenizer {
    static solver(s) {
        return s.includes('=') ? nerdsolver(s) : nerdeval(s)
    }
    static evaluate(s, ref) {
        if (ref) {
            s = s.replace(/[abcdefg]/g, (x) => ref[char2n(x)])
            return MathSolver.solver(s)
        }
        if (s.includes('÷')) {
            s = s.replace(/ ?÷ ?/g, '/')
        }

        return getValue(CodeTokenizer, s)
    }
    constructor(s) {
        super(s)
    }
    getValue() {
        return this.run()
    }

    run2() {
        const dict = {
            how: 'setup',
            many: 'setup',
            are: 'setup',
            in: 'setup',
            is: 'equality',
        }
        const items = this.s
            .trim()
            .split(' ')
            .map((x) => x.toLowerCase())
        for (let i = 0; i < items.length; i++) {
            let item = this.items[i]
            let type = dict[item]
        }
    }
    run() {
        const mathpostprocesslib = {
            fraction: toFraction,
            percentage: toPercentage,
            ratio: toRatio,
        }

        const setupRE = '(is )?what (\\w+)(?: of)?'
        const setupRE2 = 'how many (\\w+)'
        const allMathNumberRE = '-?\\d+\\.?\\d*%?'
        const allMathNumberItemRE =
            '-?\\d+\\.?\\d*%? \\w+|[a-zA-Z]+-[a-zA-Z]+ \\w+'
        const allMathNumberItemCRE =
            '(-?\\d+\\.?\\d*%?|[a-zA-Z]+-[a-zA-Z]+) (\\w+(?: than)?)'
        const regex = `${allMathNumberItemCRE}|(and)(?= \\d)`

        this.mreplace(setupRE, setupRE2)
        this.findall(regex)

        editArray(this.matches, (el) => ['', el], isString)

        const items = splitarray(this.matches, (x) => {
            const foo = x[1] != 'and' && !operationmap[x[1]]
            if (foo) {
                return foo
            }
        })

        //console.log(this.s)
        //console.log(items)
        //console.log('match', this.match)
        let reverse
        let type
        let splitLast
        let lastValue

        if (isArray(this.match)) {
            reverse = this.match[0] != 'is '
            type = this.match[1]
        } else if (this.match in ratiolib) {
            const operations = items.map(runner)
            const expr = operations.join(' ')
            const arg = nerdeval(expr)
            const factor = ratiolib[this.match]
            const statement = mhsd(arg, factor)
            return nerdeval(statement)
        } else if (this.asHelper) {
            console.log('using processor')
            return processor(items)
        } else if (
            this.matches.find(
                (x) =>
                    depluralize(x[1]) == depluralize(this.match)
            )
        ) {
            let args = pairup(this.matches, this.match)
            console.log(args)
            return solveProportions(...args)
        } else {
            type = this.match
            reverse = true
        }

        const [operations, final] = splitarray(
            items.map(runner),
            -1
        )
        const expr = operations.join(' ')
        console.log(expr)
        const args = normalizeFractions(
            ...[expr, final].map(nerdeval)
        )
        if (reverse) args.reverse()

        const postprocess = mathpostprocesslib[type]
        if (postprocess) {
            return postprocess(...args)
        } else {
            tl('dunno about this')
            console.log(args)
        }

        function processor(items) {
            for (let i = 0; i < items.length; i++) {
                let item = items[i]
                lastValue = runner(item)
            }
            return lastValue
        }

        function runner(item) {
            const parsers = []
            let value
            let parser
            let use

            for (let [number, operation] of item) {
                if (operation == 'and') {
                    parser = (n) =>
                        operationmap[operation](lastValue, n)
                    use = true
                    parsers.push(parser)
                } else if (operation in operationmap) {
                    parser = (n) =>
                        operationmap[operation](n, number)
                    parsers.push(parser)
                } else {
                    if (!value) value = number
                    while (exists(parsers)) {
                        parser = parsers.pop()
                        if (use) {
                            if (operation in ratiolib) {
                                value = mhsm(
                                    value,
                                    ratiolib[operation]
                                )
                            }
                        }
                        value = parser(value)
                    }

                    if (operation in ratiolib) {
                        if (use) {
                            use = false
                        } else {
                            value = mhsm(
                                value,
                                ratiolib[operation]
                            )
                        }
                    }
                }
            }
            return value
        }
    }
    run2() {
        const pathmap = {
            '.*?($1).*?of': {
                fraction: {
                    reverse: true,
                },
                percentage: {},
            },
            [parens(allMathNumberRE) +
            ' ' +
            parens('(?:$1)|\\w+')]: {
                'less than': nerdLessThanHelper,
                'more than': nerdMoreThanHelper,
                of: nerdOfHelper,
            },
            $1: {
                is: 'equality',
            },
        }

        const generatedpathmap = generatepathmap(
            pathmap,
            (k, v) => {
                return k.includes('$1') ? ncg(k, v) : k
            }
        )

        let done = false
        let master = []
        let count = 0

        while (!done) {
            for (let [k, v] of Object.entries(
                generatedpathmap
            )) {
                if (this.eat(k)) {
                    let key = getFirstString(this.match)
                    let config = v[key]
                    if (config) {
                        master.push(this.match, config)
                    } else {
                        master.push(this.match)
                    }
                    break
                }
            }
            if (++count == 10 || this.s.trim().length < 2) {
                done = true
            }
        }
    }
    runn() {
        const introducers = ['find', 'how many']

        const splits = [
            'and',
            'are in',
            '\\d+ w+',
            'is (?:equivalent|equal) to',
            'equals',
            'is the same as',
            'the number of',
        ]
        const operationRegexes = [
            'subtracted from',
            'plus',
            'divided by',
            'minus',
            'multipled by',
        ]

        const regexes = [
            ...splits,
            ...operationRegexes,
            ...introducers,
        ]
        const regex = RegExp(ncg(regexes, 'c'), 'i')
        this.items = this.s.split(regex)
        this.items.shift()

        let next
        let x
        this.index = 0
        while (true) {
            const item = this.items[this.index++]
            if (!item) continue

            if (
                this.index == 0 &&
                introducers.includes(item.toLowerCase())
            ) {
                x = this.items[this.index + 1]

                for (
                    let i = this.index + 2;
                    i < this.items;
                    i++
                ) {
                    const item = this.items[i]
                }
            }
        }
    }
}

function type(x) {
    return search(
        /object (\w+)/,
        Object.prototype.toString.call(x)
    )
}
function type(x) {
    let value = search(
        /object (\w+)/,
        Object.prototype.toString.call(x)
    )
    if (value == 'Undefined') value = 'Null'
    return value
}

function getFunctionAndArguments(s) {
    const runner = (s) => search('(\\w+)\\((.*?)\\)$', s)
    const store = []
    let a
    let b
    while (true) {
        const match = runner(s)
        if (match) {
            ;[a, b] = match
            store.push(a)
            s = b
        } else {
            b = s.split(/, ?/).map(toArgument)
            break
        }
    }
    console.log(store)
    console.log(b)
    return [store[0], b]
}

function getFunctionName(s) {
    s = s.toString()
    let match = search('function (\\w+)', s)
    if (!match) match = search('^.*?(\\w+)\\(', s)
    return match
}

function getSentences(s) {
    const items = s.split(/(\S*[.?]) /)
    const store = []
    const putBack = ['mr', 'ms', 'dr', 'mr', 's', '...']
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        if (putBack.includes(item.toLowerCase().slice(0, -1))) {
            edit(
                store,
                -1,
                (x) => x + item + ' ' + items[i + 1]
            )
            i++
            continue
        }
        if (
            /[.?]$/.test(item) &&
            /[^.?]$/.test(getLast(store))
        ) {
            edit(store, -1, (x) => x + item)
        } else {
            store.push(item)
        }
    }
    return store
}

function swapNouns(s) {
    const ref = search('([a-zA-Z]+) to ([a-zA-Z]+)', s)
    if (!ref) return s
    const regex = ncg(ref)

    const sentences = getSentences(s)
    let x = sentences[1]

    let matches = findall(regex, x)
    let count = matches.length

    if (count == 2) {
        let dict = matches.reduce((acc, item, i, arr) => {
            acc[arr[i]] = arr[(i + 1) % arr.length]
            return acc
        }, {})
        x = dreplace(x, dict, 'g')
    } else {
        x = replace(
            regex,
            (el) => {
                return ref.find((x) => {
                    return x != el
                })
            },
            x
        )
    }
    return sentences[0] + x
}

function fractionize(s) {
    if (isNumber(s)) {
        return decimalToFraction(s)
    }

    if (isPercentage(s)) {
        return s
    }
    return s.replace(numberREGEX, decimalToFraction)
}

function mathUnitConverter(from, to) {
    const value = math.unit(x).toNumber(target)
}

//1 mile equals 5280 * 12 = 63360 inches.
function atFirst(fn) {
    return (item, i) => {
        if (i == 0) return fn(item)
        return item
    }
}

function oxfordJoin(items) {
    let s = ''
    let delimiter
    if (items.length == 2) return items.join(' and ')
    items.forEach((item, i) => {
        if (i == items.length - 2) delimiter = ', and '
        else if (i == items.length - 1) delimiter = ''
        else delimiter = ', '
        s += item + delimiter
    })
    return s
}

function varialize(name, value) {
    return 'const ' + name + ' = ' + stringify(value)
}
function variableLengther(s, level) {
    let n = 1
    const value = oxfordJoin(
        range(level || rng(1, 2)).map((i) => {
            return s.replace(/(?<=\$)\w\b/, (x) =>
                n2char(i - 1)
            )
        })
    )
    return mathtemplater2(value)
}

function improperFractionToMixedNumber(n, d) {
    i = parseInt(n / d)
    n -= i * d
    return [i, reduceFraction(n, d)]
}

function reduceFraction(numerator, denominator) {
    if (isNaN(numerator) || isNaN(denominator)) return NaN
    let lowest = gcd(numerator, denominator)
    return [numerator / lowest, denominator / lowest]
}
function mixedNumberToImproperFraction(wholeNumber, frac) {
    return [wholeNumber * frac[1] + frac[0], frac[1]]
    // i would have to go through some annoying bits to get it working for variables. you would need a comprehensive system in order to do that, and i dont have that.
}

function checkalanbackup(s) {
    const letters = s.match(/\w+/g)
    for (let i = 0; i < letters.length; i++) {
        let letter = letters[i].toLowerCase()
        let answer = s[i]
        if (letter != answer) {
            console.log(
                'correct answer',
                answer,
                'index',
                i + 1
            )
        }
    }
}

function copy(x) {
    return JSON.parse(JSON.stringify(x))
}

function analyzelotf() {
    data = read('MYTEMPFILE')
    tl(data)
    function runner(item) {
        lines = item.split(/(?<=\.) /)
        return [shuffle(copy(lines)), lines]
    }
    const payload = data.map(([a, b, text]) => {
        lines = text.split(/\n+\t*/, text.trim())
        lines = filtered(
            lines,
            (s) => s.length > 500 && s.length < 700
        )
        item = randomPick(lines)
        return runner(item)
    })

    write('alanscramble.json', payload)
}

function isReasonableMathAnswer(s) {
    return s.length < 10
}

function toLiteralArray(s) {
    return s.slice(1, -1).split(',')
}

function getVariables(s) {
    return unique(s.match(/\b[a-z]\b/g))
}

function getVariable(s, target) {
    if (target) return target
    const p = s.match(/[a-z]/g)
    if (p && p.length == 1) return p[0]
    return 'x'
}

function invivoDecimalToFraction(s) {
    // turns all decimals in a string into a fraction. Is ... this a good idea?
    //
    return s.replace(numberREGEX, decimalToFraction)
}

function solve(s) {
    s = invivoDecimalToFraction(s)
    const value = toLiteralArray(
        nerdamer.solve(s, getVariable(s)).toString()
    )
    console.log(value, 'prefilter')
    return smallify(value.filter(isReasonableMathAnswer))
}

function hasComma(s) {
    return s.includes(',')
}

function hasVariable(s) {
    return test(/\b[abcde]\b/, s)
}

//function count(regex, s) {
    //return findall(regex, s).length
//}

function hasVariables(s) {
    return test(/\b[abcde]\b/, s)
}

function createObject(...args) {
    return reduce(paired(args), (k, v) => [k, v])
}

function expand(s) {
    const p = nerdamer.expand(s).toString()
    return formatNerdamer(p)
}
function replaceAVariable(s) {
    console.log(s, 'o')
    const variableLetter = 'x'
    const regex = /\b[abcxyz]\b/g
    const items = s.match(regex)
    const index = rng(0, items.length - 1)
    let original
    let count = 0
    let value = s.replace(regex, (x) => {
        if (index == count++) {
            original = items[index]
            return variableLetter
        }
        return x
    })
    console.log(value)
    if (!original) throw ''
    return value
}

class NerdamerGenerator {
    constructor(s) {}
    replaceExpansionWithVariable(s) {
        const original = formatNerdamer(
            nerdamer.expand(s).toString()
        )
        const [replaced, answer] = replaceAVariable(original)
        return [replaced, answer]
    }

    replaceExpansionWithNumber(s) {
        const original = formatNerdamer(
            nerdamer.expand(s).toString()
        )
        const [replaced, answer] = replaceAVariable(original)
        return [replaced, answer]
    }
}
function replaceAVariable(s) {
    console.log(s, 'o')
    const variableLetter = 'x'
    const regex = /\b[abcxyz]\b/g
    const items = s.match(regex)
    const index = rng(0, items.length - 1)
    let original
    let count = 0
    let value = s.replace(regex, (x) => {
        if (index == count++) {
            original = items[index]
            return variableLetter
        }
        return x
    })
    if (!original) throw ''
    return [value, original]
}

const commonAlgebraExpressions = [
    '2(a+b)',
    'x + 2x + 3x + 4x + 5x',
    'x^2 + x',
    '(x+1)(x-1)',
]

class NerdamerExpression {
    constructor(s) {
        this.s = s || nerdamer('')
    }
    multiply(s) {
        this.s = this.s.multiply(s)
        return this
    }
    add(s) {
        this.s = this.s.add(s)
        return this
    }
    subtract(s) {
        this.s = this.s.subtract(s)
        return this
    }
    divide(s) {
        this.s = this.s.divide(s)
        return this
    }
    multiply(s) {
        this.s = this.s.multiply(s)
        return this.s
    }
    add(s) {
        this.s = this.s.add(s)
        return this.s
    }
    subtract(s) {
        this.s = this.s.subtract(s)
        return this.s
    }
    divide(s) {
        this.s = this.s.divide(s)
        return this.s
    }

    toString() {
        return formatNerdamer(this.s.toString())
    }
}

function invivoPolynomialRearrangement(s) {
    //s = s.replace(/\w+
    let items = s.toString().split('+')
    sorted(
        items,
        (x) => search(/\^(\d+)/, x),
        (x) => (test(/[xyz]$/, x) ? 1 : 0),
        true
    )
    return items.join(' + ')
}

function polynomialRearrangement(s) {
    let items = s.toString().split('+')
    sorted(
        items,
        (x) => search(/\^(\d+)/, x),
        (x) => (test(/[xyz]$/, x) ? 1 : 0),
        true
    )
    return items.join(' + ')
}

function nerdexpand(s) {
    s = nerdamer.factor(s).toString()
    //s = polynomialRearrangement(s)
    return s
}

function nerdfactor(s) {
    //s = nerdamer.expand(s)
    //s = nerdamer.simplify(s)
    s = nerdamer.factor(s)
    s = formatNerdamer(s)
    return s
}

const quadratic156a = '-5x^2 + 2x = x^3 + 8x'
const quadratic156 = 'x^2 + 5x + 6'
a2b2 = 'a^2 - b^2'
a3b3 = 'a^3 - b^3' // works but it is backwards
a4b4 = 'a^4 - b^4' // doesnt work

const wordProblemTemplatesTooHardCurrently = [
    'How many $unit(time) are in $variableLength($a $unit(time))',
    'x $unit(time) + $a $unit(time) equals $b $unit(time). Find x.',
    'How many $unit(time) are in $a $unit(time)?',
    '$unit(meter, n) added to $unit(meter, n) is equal to how many $unit(meter)?',
    //'$name makes $a $food every $unit(time, n). How many $food does $name make in $unit(time, n)?',
    // not working
    //'$name makes $a $food every $b minutes. How much $food does $name make in $c hours?',
]
const wordProblemTemplsdfates = [
    'How many minutes are in $a hours?',
    'How many seconds are in $a hours and $b minutes?',
    'How many hours are in $a minutes?',
    //'How many hours are in $a seconds and $b minutes?',
    'How many hours are in $a weeks?',
    'How many centimeters are in $a millimeters?',
    'How many years are in $a months?',
]

const wordProblemTemplates = [
    {
        question:
            'What is the sum of the unique prime factors of 100?',
        answer: (n) => sum(getuniqueprimefactors(n)),
    },

    //'$name makes $a $food every $b minutes. How many $food does $name make in $c hours?',
    //'How many minutes are in $a hours?',
    //'How many seconds are in $a hours and $b minutes?',
    //'How many hours are in $a minutes?',
    //'How many hours are in $a weeks?',
    //'How many years are in $a months?',

    {
        question:
            'What percentage of numbers from 40 to 80 are prime?',
        answer(a, b) {
            let amount = countPrimeNumbersBetween(a, b)
            let total = countinclusive(a, b)
            return toPercentage(amount, total)
        },
    },
    'The ratio of dogs to cats is $a to $b. If there are ${b * c} cats, how many dogs are there?',

    {
        question:
            'The ratio of eagles to seagulls is $a to $b and the ratio of eagles to hawks is $c to $d.',
        children: [
            {
                type: 'answerFromQuestion',
                question:
                    'If there are $e eagles, how many seagulls and hawks are there in total?',
                answer: 'e * b/a + e * d/c',
            },

            {
                type: 'answerFromQuestion',
                question:
                    'If there are $e hawks, how many seagulls are there?',
                answer: '(e * c/d) * (a/b)',
            },
        ],
    },
]

function getrandomfactor(n) {
    return randomPick(getallfactors(n).slice(1))
}

function fixSentencePluralization(s) {
    return s
    const items = ['of', 'how many', 'and', 'to']
    const infront = ['I', 'the', 'how']
    const regex = ncg('(?<=(?:$1) (?!$2))[a-zA-Z]+', [
        items,
        infront,
    ])
    function parser(x) {
        let suffix = x.endsWith('s') ? '' : 's'
        return x + suffix
    }
    s = replace(regex, parser, s)
    s = replace('(?<=1 )(\\w+)s(?!s) ', '$1 ', s)
    s = replace('are(?= 1)', 'is', s)
    return s
}

function globaleval(s) {
    try {
        return eval(s)
    } catch (e) {
        //console.log(getErrorInfo(e))
        return s
    }
}

function usefulforij(a = 10, b = 10) {
    const store = []
    for (let i = 1; i <= a; i++) {
        for (let j = i; j <= b; j++) {
            store.push([i, j])
        }
    }
    return store
}
function usefulnumbermaker() {
    const numbers = range(100)
        .filter((x) => {
            const factors = flat(getfactorpairs(x))
            return (
                factors.length > 4 &&
                factors[factors.length - 1] > 5
            )
        })
        .map(identity)
    return numbers
}

function ratioProblem(answer) {
    let [k, m] = shuffle(randomPick(getfactorpairs(answer)))
    let n = m + rng()
    let other = n * k
    let start = answer + other

    return [start, n, m, answer]
    return { start, m, n, answer }
}

function questionmakerhandler(x) {
    return runner(x)

    breaker = new BreakerFactory()
    function valid(answer) {
        return 1
        breaker()
        if (hasDecimal(answer)) {
            return false
        }

        if (isNumber(answer)) {
            if (answer <= 0) return false
        }
        return true
    }

    function runner(x) {
        let value = questionmaker(x)
        return 1

        return valid(value.answer) ? value : runner(x)
    }

    //let payload = runner(x) // returns an object
    //console.log(payload); throw '';

    return edit(payload, {
        answer: postProcessAnswer,
        question: postProcessQuestion,
    })
}

function rounded(s, n = 2) {
    s = String(s)
    if (s.includes('.')) {
        let [whole, decimal] = s.split('.')
        let [number, next] = [decimal.slice(0, n), decimal[n]]
        if (Number(next) >= 5) number = Number(number) + 1
        return Number(whole + '.' + number)
    }
    let [number, next] = [s.slice(0, n), s[n]]
    if (Number(next) >= 5) number = Number(number) + 1
    return number
}
function toTwoDecimals(x) {
    return x.toString().replace(/(?<=\.)\d+/, (x) => {
        if (x.length == 1) return x + '0'
        else {
            return rounded(x, 2)
        }
    })
}
function fixPercentageDecimals(s) {
    return s.replace(numberRE, (x) => {
        //console.log(x, 'x')
        if (hasDecimal(x)) x = toTwoDecimals(x)
        return x
    })
}

function keysAreFactory(state, exceptions) {
    const keys = isObject(state) ? Object.keys(state) : []
    const length = keys.length
    return function lambda(args) {
        console.log()
        throw ''
        if (isFunction(args)) {
            return args(state)
        }
        if (isObject(args)) {
            console.log(args)
            throw ''
            for (let [k, v] of Object.entries(args)) {
                if (!keys.includes(k)) return
                if (!v(state[k])) return
            }
            return true
        }

        if (exceptions) {
            map(exceptions, (x) => pop(args, x))
        }
        if (length != args.length) {
            return
        }
        return args.every((arg) => keys.includes(arg))
    }
}

function qaRunner(x) {
    const [args, question] = createArgsForQuestion(x.question)
    const answer = x.answer(...args)
    return { question, answer }
}
function isStringDollarTemplate(s) {
    return isString(s) && /\$(?!\d+\.)/.test(s)
}
function stringRunner(s) {
    /* work backwards into an answer */
    /*  */
    console.log(s)
    s = numberconvertify(s)
    console.log(s)
    throw ''
    answer = rng(10, 20)
    const numbers = fn(answer)
    const question = mathtemplater2(s, numbers)
    return { question, answer }
}

function dollarRunner(s) {
    const question = mathtemplater2(s)
    const answer = mathWordSolver(question)
    return { question, answer }
}

function answertemplater(answerTemplate, questionTemplate) {
    console.log('hiii')
    throw ''
    console.log(answerTemplate)
    throw ''
    const numbers = getnumbers(questionTemplate)
    const r = /\b[abcde]\b/g
    const value = answerTemplate.replace(r, (x) => {
        let c = n2char(x)
        return numbers[x]
    })
    return eval(value)
}
class MathTemplater3 {
    /** mt3 **/
    buildRegexAndParsers(key) {
        if (!key) key = 'default'
        let ref = MathTemplaterRegexes[key]
        let [regexes, parsers] = partitionVertical(ref)

        this.parsers = parsers.map((parser, i) => {
            if (isString(parser)) {
                if (parser in this) {
                    return this[parser].bind(this)
                } else {
                    return bringToLife(parser).bind(this)
                }
            }
            if (isFunction(parser)) {
                return parser.bind(this)
            }
        })

        let regex = reWrap(regexes)
        //console.log({regex}); throw ""
        this.regex = RegExp(regex, 'g')
    }

    buildDollarWordRef(key = 'default') {
        const preferences = this.studentConfig.preferences
        return preferences || {}
    }

    constructor(studentConfig, options = {}) {
        /* active */

        if (isString(studentConfig)) {
            options = { regexKey: studentConfig }
            studentConfig = null
        }

        this.dollarWordRef = {}
        this.baseDollarRef = options.baseDollarRef || {}
        this.loadRef(options.dollarRef)
        this.studentConfig = studentConfig
        this.numbergen = new Numbergen(studentConfig)
        this.cache = new NumberCache()

        if (studentConfig) {
            this.history = new History(this)
            this.wordnet = new WordNet()
            this.dollarWordRef = this.buildDollarWordRef()
        }

        this.buildRegexAndParsers(options.regexKey)
        this.clear()
    }

    loadRef(ref) {
        if (!exists(ref)) {
            return
        }
        this.dollarWordRef = merge(this.baseDollarRef, ref)
    }

    clear() {
        this.cache.clear()
        //this.numbergen.clear()
        //why do we not clear the numbergen???
        this.numbers = []
        this.tempRef = {}
        this.mtTempRef = {
            expressionValues: [],
            answer: null,
        }
    }

    onBeforeReplace() {}
    onAfterReplace() {}

    replaceObject(s, ref) {
        const runner = (_, ...args) => {
            const index = args.findIndex(exists)
            const arg = args[index]
            const parser = this.parsers[index]
            //console.log({parser}); throw ""
            const value = parser(arg, ref)
            return value
        }

        this.onBeforeReplace(s)
        //console.log(this.regex, this.regex.test(s)); throw '';
        const value = s.replace(this.regex, runner)
        this.onAfterReplace(value)
        return value
    }
    runOnce(s) {
        return this.replaceObject(s)
    }
    replace(s, r, f) {
        /* mt.replace */
        if (!r && !f) {
            if (hasDollarVariable(s)) {
                return this.runOnce(s)
            } else {
                return s
            }
        }

        if (isArrayOrObject(r)) {
            return this.replaceObject(s, r)
        }
        const g = thisf(this, f)
        return s.replace(r, (...args) => {
            const value = g(...args)
            console.log({ value })
            return this.push(value)
        })
    }

    push(value) {
        /* used at runner() */
        /* used at replace() */
        /* it is the last action */
        /* it saves numbers as needed */
        /* everything seems to work */
        /* it can also break at any moment */

        if (
            !this.skipNumbers &&
            (isNumber(value) ||
                (this.tempRef.allowNonNumbers &&
                    isVariable(value)))
        ) {
            this.numbers.push(value)
        }
        return value
    }

    split(s) {
        const runner = (item) => {
            return this.typeTransform(item)
        }

        const value = s
            .split(this.regex)
            .filter(isVeryDefined)
            .map(runner)

        if (len(value) == 1) {
            return value[0]
        } else if (value.every((t) => t.type == 'string')) {
            return 'xhiiiiiiiiii'
        } else {
            return divify('div', 'asdf', join(value))
        }

        /* for alanHtml
         * need to combine things sometimes
         * the feeling is kind of uncomfortable
         * to give it on leaving ... maybe ...
         * */

        return value
    }

    run(s, o = { eval: true, ref: null }) {
        const runner = (_, ...args) => {
            let index = args.findIndex(exists)
            let arg = args[index]

            if (o.ref) {
                let newArg = alphabet.includes(arg)
                    ? char2n(arg)
                    : Number(arg) - 1
                return o.ref[newArg]
                /*
                 * possibly extended to dictionaries as well
                 * only array is possible atm
                 * */
            }

            const parser = this.parsers[index]
            //console.log(parser, 'hi')
            const value = parser(arg)
            //const value = parser.call(this, arg)
            //console.log({parser, value, arg}) /* debugger */
            return this.push(value)
        }

        this._s = s
        let value = s.replace(this.regex, runner)
        //console.log({value, o})
        if (o.clear) this.clear()
        return o.eval ? this.eval(value) : value
    }
}
function qadRunner(x) {
    console.log('HI')
    throw 'HI'
}
function qadRunner2(mt, x) {
    const r = /\$[abcde]\b/g
    //const question = x.question.replace(r, (x) => {
    //rng(5,20)
    //})
    const [question, answer] = mathtemplater3(x.question)
    console.log(question, x)
    throw ''
    const numbers = getNumbers(question)
    console.log(x)
    throw ''
    const vars = getVariables(x.answer)
    //const answer = nerdsub(x.answer, zip(vars, numbers))
    console.log(answer)
    throw ''
    return { question, answer }
}

function qacRunner(x) {
    return x.children.map((child) => {
        child = edit(
            child,
            'question',
            (y) => {
                return x.question + ' ' + y
            },
            Object
        )
        return this.questionRunner.run(child)
    })
}
function isDollarAnswer(s) {
    if (!isString(s)) return
    let a = /\$[abcde12345]/.test(s)

    if (a) {
        return 1
    }
    let b = /\b[abc]\b/g
    return count(b, s) > 2
}

function questionmaker(x) {
    const keysAre = keysAreFactory(x, ['type'])
    const tests = [
        ['question', 'children'],
        qacRunner,
        { answer: isDollarAnswer },
        qadRunner,
        ['question', 'answer'],
        qaRunner,
        isStringDollarTemplate,
        dollarRunner,
        isString,
        stringRunner,
    ]

    for (let [a, b] of partition(tests)) {
        if (keysAre(a)) {
            const value = b(x)
            console.log(value)
            return value
        }
    }
    return logError(x)
    if (x.question) x.template = x.question

    function runner(answer, fn, template) {
        try {
            if (isFunction(template)) {
                return template(answer)
            } else if (isFunction(answer) && !fn) {
                const [numbers, question] =
                    createArgsForQuestion(template)
                answer = answer(...numbers)
                return { question, answer }
            } else if (
                isString(answer) &&
                answer.includes('$')
            ) {
                template = createArgsForQuestion(
                    template,
                    numberLargeRE
                )[1]
                const question = mathtemplater2(template)
                const numbers = getnumbers(question)
                //console.log({answer})
                answer = mathtemplater2(answer, numbers)
                //console.log({answer})
                return { question, answer }
            } else if (isString(template)) {
                template = numberconvertify(template)
                if (!answer) answer = rng(10, 20)
                else if (isFunction(answer)) answer = answer()
                const numbers = fn(answer)
                const question = mathtemplater2(
                    template,
                    numbers
                )
                return { question, answer }
            }
        } catch (e) {
            e = e.toString()
            tl({ e, answer, fn, template, x })
        }
    }

    if (isString(x)) {
        const question = mathtemplater2(x)
        const answer = mathWordSolver(question)
        return { question, answer }
    } else if (isObject(x)) {
        if (!x.template) return
        return runner(x.answer, x.numbers, x.template)
    } else {
        console.log(x, 'x')
        tl('not don')
    }
}

function isTerminating(a, b) {
    if (isPrime(b)) return false
    return true
}

function getuniqueprimefactors(n) {
    return unique(getprimefactors(n))
}

function sumUpTheDigits(n) {
    return sum(splitNumber(n))
}

const xExplanationServiceParsers = {
    default(s) {},
    translation(s) {
        console.log('todo')
        return
        console.log(this.ref)
        throw ''
    },
}
const algebrawordquestions = [
    {
        question:
            'The sum of two numbers is 15. One of the numbers is 3 more than the other number. What is the smaller number?',
        answer: '($a - $b)/2',
    },

    {
        question:
            'I am a $rng(2, 3)-digit $or(odd, even) number. Reverse my digits and I will become an $other number. Add my digits up, and their sum is $rng(5, $lastNumber * 9 - 3). What number could I be?',
        answer(numbers, tempRef) {
            let config = {
                digitSum: numbers[2],
                len: numbers[0],
                digits(digits) {
                    return tempRef.or == 'even'
                        ? isEven(digits[0])
                        : isOdd(digits[0])
                },
            }

            return getNDigitNumber(numbers[0]).filter(c)
        },
    },
    {
        question:
            'I am a $rng(3, 3)-digit $odd number. My $rnp(1s, 10s, 100s) digit is $a less than my $rnp digit. My digits sum up to $rng(5, 25). What number could I be?',
        answer(numbers, tempRef) {
            let config = {
                len: numbers[0],
                digits(digits) {
                    let a = log10(parseInt(tempRef.a)) - 1
                    let b = log10(parseInt(tempRef.b)) - 1
                    return digits[a] - digits[b] == numbers[1]
                },
                digitSum: numbers[2],
            }

            let c = numberf(config)
            return getNDigitNumber(numbers[0]).filter(c)
        },
    },

    {
        numbers: 'default1',
        type: 'questionFromAnswer',
        question:
            'What is the $smallestLargest number X such that $1/$2 is $greaterLess than $3/$4?',
        answer(numbers) {
            let index = randomIndex(numbers)
            let greaterLess
            let smallestLargest

            if (index == 1 || index == 3) {
                smallestLargest = 'smallest'
                greaterLess = 'greater'
            } else {
                smallestLargest = 'largest'
                greaterLess = 'less'
            }

            edit(numbers, index, 'X')
            let argRef = {
                numbers,
                smallestLargest,
                greaterLess,
            }
            let solutions = [
                (a, b, c, d) => (b * c) / d,
                (a, b, c, d) => (a * d) / c,
                (a, b, c, d) => (a * d) / b,
                (a, b, c, d) => (b * c) / a,
            ]
            let answer = solutions[index](...numbers)
            if (isInteger(answer)) {
                if (smallestLargest == 'smallest') {
                    answer++
                } else {
                    answer--
                }
            } else {
                if (smallestLargest == 'smallest') {
                    answer = Math.floor(answer)
                } else {
                    answer = Math.ceil(answer)
                }
            }
            return [answer, argRef]
        },
    },

    {
        question:
            'What is the smallest number that is a multiple of both $a and ${a * c}',
        answer: 'lcm(a, b)',
    },

    {
        type: 'questionFromAnswer',
        question:
            'What is the lowest common multiple of $join($args)',
        answer(numbers) {
            numbers = [4, 6, 9]
            let seed = number
            /* the numbers arg comes from numbers... */

            let answer = lcm(numbers)
            return [answer, args]
        },
        numbers: {
            1: 5,
        },
    },

    {
        question:
            'How many prime numbers are there whose squares are less than 125?',
        answer(n) {
            return PRIMES.filter((x) => x * x < n).length
        },
        explanation(n) {
            const numbers = PRIMES.filter((x) => x * x < n)
            const length = numbers.length
            //return `
            //table(numbers)
            //`
        },
    },

    {
        question: 'How many different factors does 60 have?',
        answer: 'factor($1, Array)',
    },

    {
        question:
            'How many integers between $rng(5,10) and $rng(50,60) are multiples of $rng(2,4) and $rng(5,7)?',
        answer: '${range($1, $2).filter(x => x % lcm($3, $4) == 0).length}',
    },
    {
        question() {
            function creator() {
                let s = []
                let length = rng(2, 3)
                for (let i = 0; i < length; i++) {
                    let number = rng(isPrime)
                    let exponent = rng(1, 2)
                    s.push(interweave(number, ' * ', exponent))
                }
                return s.join(' * ')
            }

            let a = creator()
            let b = creator()
            let aa = getnumbers(a)
            let bb = getnumbers(b)
            let intersection = getAllShared(aa, bb)
            let question = `What is the greatest common factor of ${a} and ${b}?`
            answer = multiply(...intersection)
            return { question, answer }
        },
    },
    {
        question:
            'On Christmas, $name eats $1 cakes. The amount he eats is $2 times more than $3 more than $name2. How much does $name2 eat?',
        numbers: (answer, level) => {
            function runner(answer) {
                let offset = rng(1, 0.5 * answer)
                let multiplier = rng()
                let eats = (answer + offset) * multiplier
                return [eats, multiplier, offset]
            }
            return repeatUntil(
                runner,
                (x) => {
                    return every(x, isPositive, isInteger)
                },
                answer
            )
        },
    },
]

function percenthelper(a, b, mode = '+') {
    if (mode == '+' || mode == 'more than')
        return ((100 + a) * b) / 100
    if (mode == '-' || mode == 'less than')
        return ((100 - a) * b) / 100
    if (mode == 'of') return ((0 + a) * b) / 100
}
function moreOrLessThanParser(b, operator, c) {
    return percenthelper(b, c, operator)
}
const mathquestions = [
    {
        question: (a, b, c) => {
            const moreOrLess = () =>
                randomPick(['more than', 'of', 'less than'])
            const first = moreOrLess()
            const second = moreOrLess()

            const question = `${a}% ${first} ${b}% ${second} ${c} = ?`
            const answer = moreOrLessThanParser(
                a,
                first,
                moreOrLessThanParser(b, second, c)
            )
            return { question, answer }
        },
        answerRequirement: [isInteger, isPositive],
        numbers: { n: 3, min: 20, max: 100, nice: true },
    },
    {
        numbers: [
            [
                [40, 100],
                [100, 200],
            ],
        ],
        question: (a, b) => {
            let _a = getbiggestprimefactor(a)
            let _b = getbiggestprimefactor(b)

            if (_a < _b) {
                ;[a, b] = swap(a, b)
                ;[_a, _b] = swap(_a, _b)
            }

            const question = `The biggest prime factor of ${a} is x more than the biggest prime factor of ${b}. What could the value of x be?`
            const answer = _a - _b

            return { question, answer }
        },
    },
    {
        description: 'lowest common multiple backwards',
        numbers: { n: 3, max: 10, unique: true },
        question: (...numbers) => {
            const length = numbers.length
            const templateAnswer = grouplcm(...numbers)
            const answer = numbers.pop()
            const variableX = randomPick(['x', 'y', 'z'])

            const question = `${templateAnswer} is the lowest common multiple of ${length} different numbers: ${stringmathlist(
                [...numbers, variableX]
            )}. What might a possible value for ${variableX} be?`
            return { answer, question }
        },
    },
    {
        numbers: { n: 2, min: 3, max: 10, unique: true },
        question: (...numbers) => {
            let question = `What is the ${
                Math.random() > 0.5 ? 'least' : 'smallest'
            } common multiple of ${stringmathlist(numbers)}?`

            return {
                answer: lcm(...numbers),
                question: question,
            }
        },
        answerRequirement: (x) => x > 1,
    },

    {
        type: 'factors',
        numbers: {
            n: 5,
            min: 3,
            max: 50,
            requirements: [notPrime],
        },
        question: (...numbers) => {
            let question = `How many factors do ${listify(
                sorted(numbers, identity)
            )} have in common?`
            let answer = findCommonFactors(numbers).length
            return { question, answer }
        },
        answerRequirement: (x) => x > 1,
    },

    {
        numbers: {
            n: 1,
            min: 30,
            max: 80,
            requirements: [notPrime],
        },

        question: (n) => {
            const question = `My digits add up to ${sum(
                getdigits(n)
            )}. My prime factors add up to ${sum(
                getprimefactors(n)
            )}. What number am I?`
            const answer = n
            return { question, answer }
        },

        choices(n) {
            let $sum = sum(getdigits(n))
            let a = rng(1, $sum - 1)
            let b = $sum - a
            return makeNumber(a, b)
        },
    },
    {
        numbers: { n: 2, min: 3, max: 50, unique: true },
        question: (...numbers) => {
            const question = `What is the greatest common factor of ${stringmathlist(
                numbers
            )}?`
            const answer = gcd(...numbers)
            return { question, answer }
        },
        answerRequirement: (x) => x > 1,
    },

    {
        numbers: {
            n: 1,
            min: 400,
            max: 500,
            requirements: [notPrime],
        },
        question(n) {
            const answer = getprimefactorization(n)
            const question = `What is the prime factorization of ${n}?`
            return { question, answer }
        },
        choices: (n, answer) => {
            return answer.replace(/\d+/g, (x) => {
                let val
                do {
                    val = Number(x) + rng(-10, 10)
                } while (val < 1 || !isPrime(val))
                return val
            })
        },
    },

    {
        numbers: (answer, level) => {
            const a = rng(level, level + 20)
            return primes.slice(a, a + rng(2, 5))
        },
        question: (...n) => {
            const item = randomPick(
                mathOrdinals.slice(0, n.length)
            )
            const template = `${
                n.length
            } prime numbers in a row add up to ${sum(
                n
            )}. What could the ${item} prime number be?`
            return {
                question: template,
                answer: n[parseInt(item) - 1],
            }
        },
        choices: (numbers) => {
            const first = primes.findIndex(
                (x) => x == numbers[0]
            )
            let index = rngAround(first)
            return primes[index]
        },
        extensions: [
            'average value',
            'median value',
            'mode',
            'mean',
        ],
    },
]

function every(x, ...args) {
    return x.every((el) => {
        for (let arg of args) {
            if (!arg(el)) return false
        }
        return true
    })
}

function isPositive(n) {
    return n >= 0
}

function getDigit(number, n) {
    if (n > 1 && n % 10 === 0) n = Math.log10(n) + 1
    return Math.floor((number / Math.pow(10, n - 1)) % 10)
}

function iterateunique(length, fn, condition, ...args) {
    const store = []
    let count = 0
    while (store.length < length) {
        if (count++ > 40) throwError()
        let value = fn(...args)
        if (store.includes(value) || !condition(value)) continue
        store.push(value)
    }
    return store
}

function gcd(a, b) {
    return !b ? a : gcd(b, a % b)
}

function lcm(...args) {
    args = gatherArgs(args)
    if (args.length > 2) {
        return args.reduce((acc, item) => lcm(acc, item), 1)
    }
    let [a, b] = args
    return (a * b) / gcd(a, b)
}

function grouplcm(...args) {
    return args.reduce((acc, item) => lcm(acc, item), 1)
}
function indexedDialogueRunner(s, i) {
    return [String(i + 1), s]
}
function toMathDialogue(s, split, speaker = Number) {
    const lines = linegetter(s, split)
    let runner
    if (speaker == Number) runner = indexedDialogueRunner
    else if (speaker == Number)
        runner = (s, i) => [String(i + 1), s]

    return lines.map(runner)
}

function getDialogue({
    override = null,
    query = 'dialogue',
    fn = identity,
    reverse = true,
    file = 'd.txt',
} = {}) {
    let datestampRE = '\\d+-\\d+-\\d+'
    let regex = createAccumulateRegex(
        parens(datestampRE),
        '(.+)'
    )
    let items = findall(regex, read(file), 'g')
    if (reverse) items.reverse()
    let actiondict = {
        '#': simplelineeditmath,
        '#': (s) => toMathDialogue(simplelineeditmath(s)),
    }
    if (override) {
        const item = items.find((x) => {
            return test(override, x[1], 'i')
        })
        return item[2]
    }

    for (let [date, $tag, text] of items) {
        if (!test(query, $tag)) continue
        let [action, tag] = search('(#)?(\\w+)', $tag)

        if (actiondict[action]) fn = actiondict[action]
        else if (actiondict[tag]) fn = actiondict[tag]

        const p = fn(text)
        return p
    }
}
function filegetter(x) {
    return isfile(x) ? read(file) : x
}

function isfile(s) {
    return s.length < 20 && test(/^\w+\.\w+$/, s)
}

function tempwrite(x) {
    tl(write('temp.json', x))
}
function testing234() {
    const ss = `
     runner 4300  2.875 answer 2.875 dec
     runner 4300  0.8333333333333333 answer 0.8333333333333333 dec
     runner 4300  0.16666666666666663 answer 0.16666666666666663 dec
     runner 4300  0.125 answer 0.125 dec
     runner 4300  1.5 answer 1.5 dec
     runner 4300  1.7142857142857144 answer 1.7142857142857144 dec
    234 0.142857143
    `
    n = getTextItemsAt(2, ss, Number)
    testmap(n, decimalToFraction)
}
function testmap(items, fn) {
    tl(
        items.forEach((x) =>
            console.log('original', x, 'value', fn(x))
        )
    )
}

function math0925createproblems() {
    s = wordProblemTemplates
        .map(questionmakerhandler)
        .filter(isDefined)
    //.map(x => x.question).map(indexedDialogueRunner)
    //tempwrite(s)
}

function math0925() {
    const $questions = algebrawordquestions.map(
        questionmakerhandler
    )
    console.log($questions)
    throw ''
    const worksheet = new MathWorksheet()
    const lettermaker = new LetterInfusion('peanut')
    const payload = $questions.map(({ question, answer }) =>
        worksheet.maker(question, answer, lettermaker.next())
    )
    console.log(payload)
    return payload
}

function addDecimals(n, amount) {
    return n / Math.pow(10, amount || rng(1, 8))
}

function addZeroes(n, amount) {
    return n * Math.pow(10, amount)
}

function addZeroesOrDecimals(a = [3, 10], b = [-2, 2]) {
    if (a.length == 4) {
        ;[a, b] = [a.slice(0, 2), a.slice(2)]
    }
    return fixFloatingPoint(addZeroes(rng(...a), rng(...b)))
}

function zeroify(n, range) {
    return fixFloatingPoint(addZeroes(n, rng(...range)))
}

function randomdecimal() {
    return addDecimals(rng(1, 20), rng(1, 5)) + rng()
}

function randomfractiondecimal() {
    let a = addDecimals(rng(1, 20), rng(1, 3))
    let b = addDecimals(rng(1, 20), rng(1, 3))
    return toFractionString(a, b)
}

function getQuotientAndRemainder(a, b) {
    let remainder = a % b
    let quotient = Math.trunc(a / b)
    return [quotient, remainder]
}
function divisionMaker(...args) {
    let [dividend, divisor] = fractiongetter(args)

    let store = []
    let remainder
    let n = 5
    let count = 0
    let decimal = false

    function runner(dividend, divisor) {
        counter(3)
        if (divisor > dividend) {
            if (!decimal) {
                decimal = true
                store.push('.')
            }
            dividend *= 10
        }

        let [quotient, remainder] = getQuotientAndRemainder(
            dividend,
            divisor
        )
        console.log(quotient, remainder)
        if (quotient != 0) count++
        store.push({
            quotient,
            bottom: quotient * divisor,
            remainder,
        })
        if (quotient == 0 && store[store.length - 3] == 0)
            return null
        return remainder
    }

    while (count < n) {
        dividend = runner(dividend, divisor)
        if (dividend == null) break
    }

    console.log(store)
    //if (decimal) store.unshift('0', '.')
    //console.log(toString(store))
}

function divisionMaker(...args) {
    let [a, b] = fractiongetter(args)

    let store = []
    let remainder = 0
    let n = 5
    let count = 0
    let decimal = false
    let index = 0
    let quotient

    console.log('start', a, b)

    const numbers = a.toString().split('').map(Number)
    while (true) {
        counter(5)
        let number = remainder * 10 + numbers[index++]
        //tl( number )
        ;[quotient, remainder] = getQuotientAndRemainder(
            number,
            b
        )
        store.push({ quotient, remainder })
        if (remainder == 0) {
            console.log('done')
            break
        }
    }
    console.log(store)
}

function countDecimalPlaces(n) {
    return (n.toString().split('.')[1] || '').length
}

function divmod(n, d) {
    return [Math.floor(n / d), Math.floor(n % d)]
}

function makeTeams(n, d, p = 0) {
    // p = precision
    // people distribution n
    const e = Math.pow(10, p)
    const [q, r] = divmod(n * e, d)
    return [
        ...Array(r).fill((q + 1) / e),
        ...Array(d - r).fill(q / e),
    ]
}

function modifydict(dict, ...args) {
    const fn = args.pop()
    for (let [k, v] of Object.entries(dict)) {
        if (args.length == 0) dict[k] = fn(v) || v
        else {
            for (let [k2, v2] of Object.entries(v)) {
                if (k2 == args[0]) {
                    if (args[1]) {
                        const zsdf = dict[k][k2][args[1]]
                        console.log(zsdf)
                        dict[k][k2][args[1]] = fn(
                            dict[k][k2][args[1]]
                        )
                        break
                    }
                }
            }
        }
        //if (args.length == 2) dict[k][args[0]][args[1]] = fn(v)
    }
}
function modify(items, fn) {
    for (let i = 0; i < items.length; i++) {
        items[i] = fn(items[i])
    }
}
function createQuestionObject(s) {
    const lines = linegetter(s)
    const dict = {
        '?': runnerA,
        '': runnerB,
    }

    for (let [k, v] of Object.entries(dict)) {
        if (test(rescape(k), lines[0])) return v(lines)
    }
    throw 'no match'

    function runnerA(lines) {
        return lines.map((line) => {
            const items = line.split(/(?<=\?) /)
            const obj = zip(['question', 'answer'], items)
            obj.type = 'default'
        })
    }

    function runnerB(lines) {
        const [template, ...children] = lines
        modify(children, (line) => {
            const items = line.split(/(?<=\?) /)
            return zip(['question', 'answer'], items)
        })
        return {
            template,
            children,
            type: 'withChildren',
        }
    }
}

function getMode(a) {
    const tally = new Tally(a)
    const store = sorted(tally.value, ([a, b]) => b, null, true)
    const value = []
    for (let i = 0; i < store.length; i++) {
        if (store[i][1] == store[0][1]) value.push(store[i][0])
        else break
    }
    return smallify(value.map(toNumber))
}

function getRegexForMathTemplater() {
    const A = '((?:[a-zA-Z]+)\\d?)(?:\\((.*?)\\)(?!\\)))?'
    const B = '(-?\\d+(?!(?:\\w|\\.\\d)))' // $1 $2
    const C = '[\\[{](.*?)[\\]}]' //${recursive}
    const regex = ncg('\\$(?:$1)', [A, B, C])
    return regex
}
function mtState(names) {
    const restaurants = ['Xiang Hot Pot Lunch Buffet']

    const foodNames = ['apples', 'bananas']
    const locations = [
        'Hawaii',
        'California',
        'Sunset Park',
        'New York',
        'Tokyo',
    ]
    const animals = ['dogs', 'cats']
    const holidays = ['Mid-Autumn Mooncake Festival']
    const animalNouns = [
        'dogs',
        'cats',
        'pigs',
        'chickens',
    ].map(depluralize)
    const foodNouns = ['cakes', 'donuts', 'donuts', 'donuts']
    const nouns = [...animalNouns, ...foodNouns]
    const verblib = {
        food: ['create', 'eats'],
    }
    const biglib = {
        studentlib: studentlib,
        animal: animals,
        holiday: holidays,
        name: names,
        sport: [
            'basketball',
            'soccer',
            'baseball',
            'golf',
            'football',
            'soap-making',
        ],
        //sport: ['golf', 'squash'],
        food: foodNames,
        location: locations,
        dynamic: {
            animals: {
                noun: animalNouns,
                location: [
                    'ranch',
                    'farm',
                    'farm house',
                    'homestead',
                ],
                verb: ['at', 'in', 'on'],
            },

            food: {
                noun: foodNouns,
                location: [
                    'eatery',
                    'restaurant',
                    'desert house',
                    'kitchen',
                ],
                verb: ['at', 'in', 'on'],
            },
        },
        noun: nouns,
        holiday: holidays,
        restaurant: restaurants,
    }
    return biglib
}

function syncState(obj, config) {
    if (!exists(config)) return
    //console.log(obj.config)
    for (let [k, v] of Object.entries(obj.config)) {
        if (k == 'level') {
            if (obj.numbergen) {
                obj.numbergen.config.level = config.level
            }
            if (obj.generator) {
                syncState(obj.generator, config)
                obj.generator.numbergen.config.level =
                    config.level
            }
            obj.config.level = config.level
        } else if (config.hasOwnProperty(k)) {
            obj.config[k] = config[k]
        }
    }
}

//mtg
function solidify(dict) {
    return editDict(dict, (x) =>
        isArray(x) ? randomPick(x) : x
    )
}

function once(obj, fn) {
    if (obj.once) return
    obj.once = true
    fn()

    if (!obj.onces) obj.onces = ['onces']
    obj.onces.push(...resetOnceItems(fn))
}
function getPastTense(verb) {
    var exceptions = {
        are: 'were',
        eat: 'ate',
        go: 'went',
        have: 'had',
        inherit: 'inherited',
        is: 'was',
        run: 'ran',
        sit: 'sat',
        visit: 'visited',
        edit: 'edited',
    }

    if (exceptions[verb]) {
        return exceptions[verb]
    }

    if (/y$/i.test(verb)) {
        return verb.slice(0, -1) + 'ied'
    }

    if (/e$/i.test(verb)) {
        return verb + 'd'
    }
    if (/[aeiou]c/i.test(verb)) {
        return verb + 'ked'
    }
    // for american english only
    if (/el$/i.test(verb)) {
        return verb + 'ed'
    }
    if (/[aeio][aeiou][dlmnprst]$/.test(verb)) {
        return verb + 'ed'
    }
    if (/[aeiou][bdglmprst]$/i.test(verb)) {
        return verb.replace(
            /(.+[aeiou])([bdglmprst])/,
            '$1$2$2ed'
        )
    }
    return verb + 'ed'
}
const verblists = [
    ['announce', 'cry', 'shout', 'declare', 'roar', 'cheer'],
]
function randomVerb(key) {
    for (let verblist of verblists) {
        let i = verblist.findIndex((verb) =>
            test(key.slice(0, Math.ceil(key.length / 2)), verb)
        )
        if (i > -1) return getPastTense(randomPick(verblist))
    }
}

function quoted(quote, speaker) {
    if (!quote) {
        return ''
    }
    const adverbs = [
        'excitedly',
        'thrilled',
        'exhilaratedly',
        'delightfully',
        'enrapturedly',
        'enthusiastically',
    ]
    const postDescriptions = [
        ...adverbs,
        'at the top of her lungs',
        'with great enthusiasm',
        'as loudly as she could',
        'as she was super fired up',
        'full of beans',
        'bright-eyed and bushy-tailed',
    ]
    const verb = randomVerb('announced')
    const postDescriptor = ' ' + randomPick(postDescriptions)
    return (
        '"' +
        quote +
        '"' +
        ', ' +
        verb +
        ' ' +
        speaker +
        postDescriptor +
        '.'
    )
}

//return [v.words.sport, v.blurbs.sport]
const blurblib = {
    mathematics:
        'Prepare yourself everyone! It is time to math!',
    'cat-watching': "Everyone! Let's watch some cats!",
    icecream: 'Everybody! No walking! Run to the stars!',
    'soap-making':
        "Everybody! It's time to make delicious soap!",
    basketball: "Everybody! It's time to play basketball!",
    scooter: 'Vroom vroom everyone! Vroom vroom!',
    running:
        'No walking allowed everybody! Run to the stars and beyond!',
}

function resetOnceItems(fn) {
    return findall(/this\.(\w+) =/g, fn.toString())
}

function getStudent() {
    return randomPick(sat9am).name
}

function getStudentDict(name) {
    const store = { name }
    const ref = STUDENTLIB[name]
    for (let [k, v] of Object.entries(ref)) {
        store[k] = randomPick(v)
    }
    return store
}

const STUDENTLIB = {
    Kaylee: {
        sport: ['soap-making'],
    },
}
const extendedwordnet = {
    'candle-making': { league: 'club', player: 'member' },
    cat: { league: 'club', player: 'member' },
    scooter: { league: 'club', player: 'member' },
    '': { league: 'club', player: 'member' },
    '': { league: 'club', player: 'member' },
    '': { league: 'club', player: 'member' },
}
function getFirstString(x) {
    if (isString(x)) {
        return x
    }
    if (isArray(x)) {
        return x.filter((el) => !isAnyMathNumber(el))[0]
    }
}
function getString(x) {
    if (isArray(x)) {
        return randomPick(x)
    }
    return x.toString()
}

function mergeObjects(...args) {
    const store = {}
    for (let arg of args) {
        if (arg) Object.assign(store, arg)
    }
    return store
}

function getExtendedDict(dict) {
    const keys = Object.values(dict)
    const dicts = keys.map((key) => extendedwordnet[key])
    const p = mergeObjects(...dicts)
    return p
}

const adjectives = [
    'cake-baking',
    'apple-growing',
    'mathematics',
    'chemistry',
    'english',
]
function to12Hours(hours) {
    let ampm = 'AM'
    if (hours > 12) {
        hours -= 12
        ampm = 'PM'
    }
    return hours + ampm
}
function createSequence() {
    let a = rng()
    let b = a + rng(2, 6)
    let sequence = range(a, b)
    return interweave(sequence.join(', '), ', ', rng(2, 3))
}

function getSequenceDigit(sequence, at) {
    getSequencePeriod(sequence)
    console.log(sequence, at)
}

const KeyValFunctionMixins = {
    //keyvalmix
    name() {
        const runner = () => {
            let student = randomPick(this.config.studentNames)
            this.studentinfo = studentfacts.find(
                (x) => x.student == student
            )
            return student
        }
        return this.cache.get('name', runner)
    },

    unit(s) {
        if (this.memory.unit) {
            switch (s) {
                case 'near':
                case 'nearby':
                    return getNearbyUnit(this.memory.unit)
                case 'less':
                    return getNearbyUnit(
                        this.memory.unit,
                        'smaller'
                    )
                case 'more':
                    return getNearbyUnit(
                        this.memory.unit,
                        'bigger'
                    )
            }
        }
        this.memory.unit = randomPick(unitreferencelib[s])
        return pluralize(this.memory.unit)
    },
    ordinal(s) {
        const args = s.split(/, ?/).map(toNumber)
        const number = rng(...args)
        const value = ordinal(number)
        return { number, value }
    },
    RNG(s) {
        return this.rng()
    },

    frac(s) {
        return randomPick(commonstringfractions)
        let a = rng(1, 9)
        let b = rng(2, 9)
        if (b == a) {
            if (b == 1) {
                b += 1
                //
            } else {
                a -= 1
            }
        } else if (a > b) {
            ;[a, b] = swap(a, b)
        }
        console.log({ a, b })

        return toFractionWord(a, b)
    },

    rng(s) {
        const args = s ? s.split(/, ?/).map(toNumber) : [2, 9]
        return roundToNearest(rng(...args))
    },
    get(s) {
        const [key, ...args] = s.split(/, ?/).map(toNumber)
        const dict = {
            time: (weekday) => {
                let hours = rng(1, 24)
                let time = to12Hours(hours)

                if (weekday) {
                    return randomPick([
                        randomPick(weekdays) + ' ' + time,
                        time + ' on ' + randomPick(weekdays),
                    ])
                }
                return time
            },
            sequence: createSequence,
        }

        if (!dict[key]) {
            if (!this.lastKey) {
                this.lastKey = key
            } else if (key == this.lastKey) {
            }
        }

        try {
            return dict[key](...args)
        } catch {
            tl(key, args, s)
        }
    },

    descriptive(s) {
        const dict = {
            test: (s) => {
                let ref = {
                    test: ['test', 'exam'],
                }
                let extraItems = {
                    mathematics: [
                        'described by some as the most delicious test in the world',
                    ],
                }
                let adjective = randomPick(adjectives)
                let synonym = randomPick(ref[s])
                let extra = addStartingSpace(
                    randomPick(extraItems[adjective])
                )
                return adjective + ' ' + synonym + extra
            },
        }
        return dict[s](s)
    },
}
function addStartingSpace(s) {
    return s ? ' ' + s : ''
}
const InfusionMixins = {
    wordnet(s) {
        tl('wordnet from infusion')
        //let student = randomPick(studentfacts)
        //let student = studentfacts[5]
        let student = this.student
        console.log(this.student)
        let studentdict = {
            name: student.student,
            sport: student.interest,
        }
        let extendeddict = getExtendedDict(studentdict)
        s = s.replace(/\$(\w+)/g, (_, x) =>
            getString(studentdict[x])
        )
        s = dreplace(s, extendeddict, 'gs')
        return s
    },
}

function numberboundarysplit(s) {
    const numberBoundaryRE = /(?<=\D)(?=\d)|(?<=\d)(?=\D)/
    return s.split(numberBoundaryRE)
}
function getForwardTime(time, n, unit = 'hours') {
    let [day, hours, ampm] = getTime(time)

    let [$days, $hours] = divmod(n, 24)
    let extraDay = 0
    hours += $hours

    if (hours < 0) hours = 12 - hours
    if (hours >= 12) {
        if (hours > 12) {
            hours = hours % 12
        }
        if (ampm == 'AM') ampm = 'PM'
        else {
            ampm = 'AM'
            extraDay = 1
        }
    }

    if (!day) return hours + ampm
    let index = weekdays.indexOf(day)
    let newIndex = index + $days + extraDay
    let newDay = weekdays[newIndex % weekdays.length]

    return newDay + ' ' + hours + ampm
}

function optional(s) {
    return '(?:' + s + ')?'
}
function getTime(time) {
    let [$time, day] = mreplace(
        ncg('(?:on )?($1)', weekdays),
        time
    )
    if (day) day = day[0]
    let [hours, ampm] = numberboundarysplit($time)
    return [day, hours, ampm.toUpperCase()]
}
function getNameAndArgs(s) {
    const [a, b] = search(/(\w+)\((.*?)\)$/, s)
    return [a, b.split(/, ?/).map(toNumber)]
}

function questionmaster(...args) {
    const mt = new MathTemplater()
    const store = flat(
        args
            .filter(exists)
            .map((arg) => questionmaker2(arg, mt))
    )
    return store
}

function isfile(s) {
    return s.length < 20 && test(/^\w+\.\w+$/, s)
}
function createbound(classObj, key) {
    return classObj[key].bind(classObj)
}
function questionmaker2(input, mt, qg) {
    /* -------------------------------------------------------- */
    const questiontemplater = mt.create('question')
    const answertemplater = mt.create('answer')
    const validationcheck = createbound(qg, 'validationcheck')
    const items = getItems(input)
    const studentLevel = qg.config.level
    const store = []
    const seen = []
    const isFresh = createbound(qg, 'isFresh')
    /* -------------------------------------------------------- */

    for (let item of items) {
        gn(item)
    }
    return store

    /* -------------------------------------------------------- */
    function stop(item) {
        if (!item) {
            tl('forcestop bc null')
        }
        if (
            mt.config.enforceLength &&
            mt.index >= mt.config.enforceLength
        ) {
            return true
        }
        return (
            isObject(item) &&
            !(item.quantity || item.question || item.template)
        )
    }

    function gn(item, returnObject) {
        if (stop(item)) return

        let fn = getfn(item)
        let validator = item.answerRequirement
            ? smartpipe(item.answerRequirement)
            : validationcheck

        /* -------------------------------------- */
        if (item.quantity) {
            for (let i = 0; i < item.quantity; i++) {
                internal()
            }
        } else if (returnObject) {
            return internal()
        } else {
            internal()
        }
        /* -------------------------------------- */

        function internal() {
            let value = repeatUntil(
                (item) => {
                    mt.reset()
                    return fn(item)
                },
                validator,
                item,
                isFresh
            )

            //console.log(value)

            if (exists(value)) {
                if (value.children) {
                    store.push(value)
                    return
                }

                mt.index++

                if (returnObject) {
                    return value
                } else {
                    store.push($postprocess(value))
                }
            } else {
                tl(item)
            }
        }
    }

    function $postprocess(value) {
        value = reshapeQuestionAndAnswer(value)
        value.question = fixNumberPluralization(value.question)
        value.answer = conditional(
            value.answer,
            pluralize,
            (x) => test(/[a-z]{2,}/i, x)
        )
        return value
    }

    function getfn(item) {
        if (isFunction(item)) {
            return function () {
                const result = item(studentLevel)
                if (isObject(result)) {
                    return result
                } else {
                    return {
                        question: result,
                        answer: mathjsSolver(result),
                    }
                }
            }
        }

        if (isString(item)) {
            const dict = [
                ['infusion', infusionRunner],
                [isInfusionTemplate, infusionTemplateRunner], // source of error
                ['.', wordSolverRunner],
            ]
            return testmatch(item, dict)
        }

        switch (item.type) {
            case 'default':
                return defaultRunner
            case 'withChildren':
                return withChildrenRunner
            case 'wordsolver':
                return wordSolverRunner
            case 'answerFnUsesQuestionNumbers':
                return answerViaQuestionRunner
            case 'questionFromAnswer':
                return startFromAnswerRunner
            case 'answerFromQuestion':
                return answerRunner
            case 'infusion':
                return infusionRunner
            default:
                return objectRunner
        }
    }

    /* -------------------------------------------------------- */

    function quantityRunner(item) {
        if (item.item) {
            return iterate(item.quantity, () => gn(item.item))
        } else {
            let quantity = pop(item, 'quantity')
            return iterate(quantity, () => gn(item))
        }
    }
    function infusionRunner(item) {
        if (isString(item)) {
            return qg.next(item)
        }

        if (isObject(item)) {
            if (item.infusion) {
                //if (item.use) {
                //qg.generator.numbergen.use(item.use)
                //}
                return qg.next(item.infusion)
            }

            if (item.template) {
                return qg.next(item.template)
            }
        }
        let key = isString(item)
            ? search('^infusion-([-\\w]+)', item, 'i')
            : item.question
        let ref = dictgetter(infusionlib, key, studentLevel)
        let template
        let mode
        if (isObject(ref)) {
            template = ref.template
            mode = ref.mode
        } else {
            template = ref
        }

        if (key == 'populate') {
            return infusionPopulate(template)
        } else if (mode) {
            tl('mode not allowed atm')
            return
            qg.generator.numbergen.setNumbers(mode)
            qg.generator.config.mode = mode
        }
        return qg.next(template)
    }

    function infusionTemplateRunner(s) {
        qg.allow()
        return qg.next(s)
    }

    function answerRunner(item) {
        //console.log(item.question)
        if (!test(/\$\w(?!\w*\.)/, item.question)) {
            item.question = Infusion.repopulateNumbers(
                item.question
            )
        }
        const question = questiontemplater(item.question)
        //console.log(question)

        const numbers = mt.state.savedCache
            ? [...mt.state.savedCache, ...getnumbers(question)]
            : getnumbers(question)

        const answer = isString(item.answer)
            ? MathSolver.evaluate(item.answer, numbers)
            : item.answer(...numbers)

        return { question, answer }
    }

    function startFromAnswerRunner(item) {
        //tl( item.numbers )
        //const answer = mt.getCurrentAnswer() || 3
        const answer = 1
        console.log(answer)
        const numbers = item.numbers(answer)
        console.log(numbers)
        item.question = item.question = item.question.replace(
            /\$?\d+/g,
            (x) => {
                return fixFloatingPoint(numbers.shift())
            }
        )
        const question = questiontemplater(item.question, null)
        return { question, answer }
    }
    function answerViaQuestionRunner(item) {
        const [question, numbers] = modifyNumbersInTemplate(
            item.question
        )
        const answer = spreadout(item.answer, numbers)
        return { question, answer }
    }
    function questionFnRunner(item) {
        return item.question()
    }

    function defaultRunner(item) {
        const question = questiontemplater(item.question)

        const answer = answertemplater(item.answer)
        if (!exists(answer)) {
            console.log('no answer')
        }
        return { question, answer }
    }

    function withChildrenRunner(item) {
        let template
        let children

        mt.wrap(() => {
            template = questiontemplater(item.question)
            children = item.children.map((child) => {
                return gn(child, true)
            })
        })
        return { template, children }
    }

    function answerFnRunner(item) {
        const [numbers, question] = createArgsForQuestion(
            item.question
        )
        const answer = item.answer(...numbers)
        return { question, answer }
    }

    function dunno(item) {
        template = createArgsForQuestion(
            template,
            numberLargeRE
        )[1]
        const question = questiontemplater(template)
        answer = answertemplater(answer)
        return { question, answer }
        template = numberconvertify(template)
        if (!answer) answer = rng(10, 20)
        else if (isFunction(answer)) answer = answer()
        const numbers = fn(answer)
        //const question = mathtemplater2(template, numbers)
        return { question, answer }
    }

    function wordSolverRunner(s) {
        if (!test(/\$\w(?!\w*\.)/, s))
            s = Infusion.repopulateNumbers(s)
        const question = questiontemplater(s)
        let answer = mathWordSolver(question)
        if (mt.noun) answer = parseFloat(answer) + ' ' + mt.noun
        return { question, answer }
    }

    function sourceRunner(item) {
        let source = item.source
            ? isFunction(item.source)
                ? item.source(studentLevel)
                : item.source
            : 'boop'

        if (isArray(source)) source = randomPick(source)
        return item.question({ level: studentLevel, source })
    }

    function objectRunner(item) {
        //if (item.answerRequirement) {
        //qg.setRequirement(item.answerRequirement)
        //}

        //if (item.quantity) {
        //return quantityRunner(item)
        //}

        if (item.infusion) {
            return infusionRunner(item)
        }

        if (item.children) {
            return withChildrenRunner(item)
        }

        let numbers
        let answer
        let question
        let choices

        if (item.source) {
            return sourceRunner(item)
        }

        if (isFunction(item.answer)) {
            answer = item.answer()
        }

        if (isFunction(item.numbers)) {
            if (!answer) answer = rng(10, 20) //later
            numbers = item.numbers(answer, studentLevel)
        } else if (isNestedArray(item.numbers)) {
            numbers = item.numbers[0].map((x) => rng(...x))
        } else if (isArray(item.numbers)) {
            numbers = rngAround(
                item.numbers[mt.studentLevel] || item.numbers[0]
            )
        } else if (isObject(item.numbers)) {
            numbers = NumberGen.numbergen(item.numbers)
        }

        if (isFunction(item.question)) {
            const $result = isNumber(numbers)
                ? item.question(numbers)
                : isArray(numbers)
                ? item.question(...numbers)
                : item.question()

            if (item.answerRequirement) {
                if (
                    !smartpipe(item.answerRequirement)(
                        $result.answer
                    )
                ) {
                    return objectRunner(item)
                }
            }
            question = $result.question
            answer = $result.answer
        } else if (isString(item.question)) {
            question = questiontemplater(item.question, numbers)
        }

        if (!answer) {
            if (isString(item.answer)) {
                if (!numbers) {
                    answer = answertemplater(item.answer, null)
                } else {
                    answer = answertemplater(
                        item.answer,
                        numbers
                    )
                }
            } else {
                answer = mathWordSolver(question)
            }
        }

        if (isFunction(item.choices)) {
            let choicesLength = 4
            choices = uniqueiteration(
                () => item.choices(numbers, answer),
                choicesLength - 1,
                (x) => x != answer
            )
            choices.push(answer)
        }

        return { question, answer, choices }
    }
}

class TextInfusion {
    static getDescriptor() {
        const descriptions = [
            ["in $name's $sport league", 'in the league'],
        ]
        return randomPick(descriptions)
    }
    descriptorA(regex, s) {
        let flags = ''
        const [pre, post] = TextInfusion.getDescriptor()
        s = replace(regex, parens(pre, ' '), s, flags)
        s = s.replace(/(?=[\.\?]$)/, ' ' + post)
        const p = InfusionMixins.wordnet(s)
        return p
    }
    constructor(s) {
        //s = 'The percentage of boys is 40%. What is the ratio of girls to boys?'
        this.s = s
    }
    changeNumbers() {
        this.s = createArgsForQuestion(this.s)[1]
    }
    infuse() {
        this.addDescriptor()
        this.changeNumbers()
        //if (coinflip(0.5)) this.s = toNewNouns(this.s)
        if (coinflip(0.5)) this.s = swapNouns(this.s)
        return this.value
    }
    static Infusion(s) {
        let infusion = new TextInfusion(s)
        return infusion.infuse()
    }
    addDescriptor() {
        const dict = {
            '(?<=of (?:\\w+ to \\w+|\\w+)) (?=is)':
                this.descriptorA,
        }
        this.s = dictiteration(dict, this.s, (s, k, v) =>
            v(k, s)
        )
    }
    get value() {
        return this.s
    }
}

function toNewNouns(s) {
    const items = [
        ['boys', 'girls'],
        ['apples', 'oranges'],
    ]

    for (let i = 0; i < items.length; i++) {
        if (test(ncg(items[i]), s)) {
            let dict = zip(
                items[i],
                items[(i + 1) % items.length]
            )
            return dreplace(s, dict, 'g')
        }
    }
    return s
}

function dictiteration(
    dict,
    s,
    fn,
    check = (k, s) => test(k, s, 'i')
) {
    if (isFunction(Object.values(dict)[0])) {
        for (let [k, v] of Object.entries(dict)) {
            if (check(k, s)) return v(s)
        }
        console.log('no find')
    } else {
        for (let [k, v] of Object.entries(dict)) {
            if (check(k, s)) {
                return fn(s, k, v)
            }
        }
    }
    return s
}

function createConfig(s) {
    const items = s.split(/, ?| |\n+/)

    return items
        .map((x) => x.split(/[=;:]/))
        .reduce((acc, [k, v]) => {
            if (!v) v = true
            acc[k] = toArgument(v)
            return acc
        }, {})
}

function ratioToPercentageSolver(c, d, a, b, target) {
    let denominator = a + b
    return target == c
        ? toPercentage(a, denominator)
        : toPercentage(b, denominator)
}
function percentageToRatioSolver(target, percentage, a, b) {
    let f = simplifyFraction(percentage, 100)
    if (target == a) return toRatio(f[0], f[1] - f[0])
    else {
        return toRatio(f[1] - f[0], f[0])
    }
}

const hardratioquestions = [
    'The number of boys in the class is 20% less than the number of girls in the class. After 5 more girls join the class, the ratio of boys to girls is now 3:5. How many girls were originally in the class?',
]
const tests = [
    'The percentage of boys is 40%. What is the ratio of girls to boys?',
    'The ratio of boys to girls is 2:3. What is the percentage of girls?',
]

function runtests(fn) {
    const p = tests
        .map(identity)
        .map(TextInfusion.Infusion)
        .map((original) => {
            const value = fn(original)
            console.log({ original, value })
            return value
        })
    return p
}

function isCommonWord(s) {
    const commonWords = [
        'after',
        'what',
        'how',
        'every',
        'the',
        'it',
        'one',
        'two',
    ]
    return (
        s.length < 3 ||
        commonWords.includes(s.toLowerCase()) ||
        holidays.includes(s)
    )
}
function findNames(s) {
    let matches = findall(/[A-Z][a-z]+/g, s).filter(
        (x) => !isCommonWord(x)
    )
    return matches
}

function findName(s) {
    const names = findNames(s)
    return names[names.length - 1]
}
function fixSentenceGender(s) {
    let name = findName(s)
    if (name) console.log({ name })
    if (!name) {
        return s
    }
    let gender = getGender(name)
    const dict = {
        he: 'she',
        him: 'her',
        his: 'her',
    }
    const genderdict = gender == 'female' ? dict : reverse(dict)
    const p = dreplace(s, genderdict, 'gb')
    return p
}

function usefulfmaker(s) {
    lines = linegetter(s)
    items = lines.map(runner).join('\n\n')
    function runner(line) {
        let arg = getFunctionAndArguments(line)[1]
        let evaluated = globaleval(line)
        if (!evaluated) throw ''
        let payload = varialize(arg, evaluated)
        return payload
    }
    return items
}

function adjectiveToAdverb(s) {
    const exceptions = {
        delighted: 'delightfully',
    }
    if (s.includes(' ')) return s
    if (s in exceptions) return exceptions[s]
    if (test('c$', s)) return s + 'ally'
    if (test('ed$', s)) return s + 'ly'
}

function getText() {
    s = read('f.txt')
    if (test(/\n\n\n\n/, s))
        return s.trim().split(/\n\n\n\n+/)[0]
    return s
}

function toRatio(a, b) {
    return simplifyRatio(a, b).join(':')
}

function hasLookAround(s) {
    return test(/\(\?\</, s.toString())
}

function math0929generator({
    mode = null,
    studentLevel = 5,
    templates,
    repeat = 1,
    title = 'Practice',
} = {}) {
    const g = new OldQuestionGenerator('infusion', {
        studentLevel,
        templates,
    })
    const ref = InfusionMasterConfig[studentLevel]
    const store = []
    g.medleyLimit = 10
    g.generator.config.withZeroesOrDecimals = true // the numbers have zeros and deciamls added
    g.generator.config.answerAsDecimal = true // fractionize is not activated
    g.generator.numbergen.overrideRange = true //  uses 1,5 or 1,9
    for (let [k, v] of Object.entries(ref)) {
        g.generator.config.withVariables = k == 'solveForX'
        g.templates = templates ? templates : shuffle(v)
        const items = g.medley(5, repeat)
        sorted(items, sortByMathDifficulty, null, true)
        store.unshift(...items)
    }

    const body =
        mode == 'practice'
            ? store.map((x) => x.question)
            : store
    return { title, body }
}

function sortByMathDifficulty(s) {
    if (isObject(s)) s = s.question
    let length = s.length

    let frac = 0
    let hasX = 0

    if (isString(s)) {
        if (s.includes('/')) frac = 10
    }
    const p = 100 - length + frac + hasX
    return p
}

const decimalTemplates = ['a * b', 'a * b * c', 'a * b * d']

function RNG(a, b) {
    return roundToNearest(rng(a, b))
}

function parsezq() {
    // not wroking
    let text = read('zq')
    let [s, config] = mreplace(/^(const.+?= )(.+)/m, text)
    tl(config)
    let payload = unique(s.trim().split(/\n+/)).map((x) =>
        x.toLowerCase()
    )
}

function readnotes(key = null) {
    s = read('notes.txt')
    dateRE = '(\\d\\d-\\d\\d-\\d\\d\\d\\d)'
    delimiter = ': '
    if (key)
        return findall(
            '^' + dateRE + delimiter + key + '(.+)',
            s,
            'gmi'
        )
    else return s
}

function oldpprint(x) {
    for (let i = 0; i < x.length; i++) {
        console.log(i + 1, x[i])
    }
}

function dateselectionfactory() {
    let month = getMDY()[0] - 1
    if (len(month) == 1) month = '0' + month
    return (s) => {
        return test('^' + month, s)
    }
}

function parseAlanTimes(matches) {
    const dater = dateselectionfactory()
    matches = filtered(
        matches,
        (x) =>
            dater(x[0]) &&
            len(x[1]) < 40 &&
            !x[1].includes('. ')
    )
    //console.log(matches)
    store = []
    score = 0
    dict = {
        '([\\d:]+)(?:am|pm)?(?: (?:to )?|-)([\\d:]+)(?:am|pm)?':
            (a, b) => {
                function timegetter(s) {
                    s = String(parseInt(s))
                    if (s.includes('.')) return s * 60
                    if (s.length == 1) return s * 60
                    if (
                        (s.length == 2 && s == 10) ||
                        s == 11 ||
                        s == 12
                    )
                        return s * 60
                    if (s.length == 2) return s
                    if (s.length == 3)
                        return (
                            Number(s[0]) * 60 +
                            Number(s.slice(1, 3))
                        )
                    if (s.length == 4)
                        return (
                            Number(s[0] + s[1]) * 60 +
                            Number(s.slice(2, 4))
                        )
                }

                return timegetter(b) - timegetter(a)
            },
        '\\+(\\d+)': (a) => a,
    }

    sorted(matches, (x) => new Date(x[0]))
    const store = new SimpleStorage()
    let prev
    for (let [date, s] of matches) {
        let result = Number(imatch(s, dict))
        console.log(result)
        score += result
        const destination = store.add(destination, result)
        prev = date
    }
    return sum(Object.values(store.value))
}

function addMathComma(x) {
    var parts = x.toString().split(".");
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return parts.join(".");
}
function addMathTags(questions) {
    for (let question of questions) {
        let tag = tagQuestion(question)
        if (tag) question.tag = tag
        else {
            store.push(question)
        }
    }
}

function createBasicFractions() {
    return unique(
        usefulforij()
            .filter(
                ([a, b]) => a % b != 0 && isTerminating(a, b)
            )
            .map((x) => simplifyFraction(...x))
    )
}

const extraquestions = [
    //{type: 'infusion', template: 'ax^2 = 10'},
    {
        type: 'infusion',
        template: 'ax + by = c, dx^2 + ey = f',
    },
    //'infusion-random',
    'infusion-fraction-addition',
    'infusion-division',
    'infusion-addition',
    {
        source: createBasicFractions(),
        question({ level, source } = {}) {
            let k = rng(2, 9)
            let [a, b] = source
            return {
                question:
                    'Simplify: ' +
                    toFractionString(a * k, b * k),
                answer: toFractionString(a, b),
            }
        },
    },

    toExamQuestionFactory(
        createTerminatingDivision,
        mathjsSolver,
        true,
        'preserveDecimal'
    ),
]

function toExamQuestionFactory(questionFn, answerFn, ...args) {
    return (...kwargs) => {
        let question = questionFn(...kwargs)
        let answer = answerFn(question, ...args)
        return { question, answer }
    }
}

function isTerminatingFraction(a, b) {
    ;[a, b] = simplifyFraction(a, b)

    while (b % 2 == 0) {
        b /= 2
    }
    while (b % 5 == 0) {
        b /= 5
    }
    return b == 1
}
function zoop(fn, ...args) {
    if (exists(args)) {
        return (x) => {
            return fn(x, ...args)
        }
    }
    return (x) => {
        return isArray(x) ? fn(...x) : fn(x)
    }
}
function createTerminatingDivision(level) {
    let x = rng(-3, 3)
    let y = rng(-3, 3)
    let a = rng(...rangegetter(standardNumberRanges, level))
    let b = Math.pow(2, x) * Math.pow(5, y)
    let k = rng(1, 2)
    //console.log({x, y, a, b, k})
    return toDivision(...[a, b].map(zoop(multiply, k)))
}

function toDivision(a, b) {
    return a + div + b
}

function terminatingDivision() {
    return unique(
        usefulforij(20, 20)
            .filter(zoop(isTerminatingFraction))
            .map(zoop(simplifyFraction))
            .map(zoop(toFractionString))
    )
}
function isCoprime(...args) {
    const items = flat(args.map(getfactors))
    const length = items.length
    const uniqueLength = unique(items).length
    return length == uniqueLength
}

const hints = [
    'A mixed number is when you have a whole number and a fraction.',
    'Coprime means the greatest common factor is 1. 3 and 7 are coprime because their greatest common factor is 1.',
]

function isInfusionTemplate(s) {
    console.log(s)
    const p =
        /^\(?(?:\d|[abcdenmx]).*?[\=\*\/\+] *(?:\d+|[abcdenmx]{1,3})\b/.test(
            s
        )
    console.log(p)
    return p
}

function mathLetterReplacement(s) {
    s = s.toString()
    const regex = randomPick(range(s.length))
    const cache = new Cache()
    function parser(x) {
        return cache.get(x, () => randomPick(['A', 'B', 'C']))
    }
    return replace(regex, parser, s)
}

const modalquestions = [
    {
        question:
            'How many $mode numbers are there from $1 to $2?',
        mode: {
            '': '$2 - $1 + 1',
            prime: 'getNumbersBetween($1, $2, "prime")',
            odd: 'getNumbersBetween($1, $2, "odd")',
            even: 'getNumbersBetween($1, $2, "even")',
        },
    },

    {
        question:
            'How many numbers are there from $1 to $2 exclusive?',
        answer: '$2 - $1 - 1',
    },

    {
        question:
            'How many prime numbers are there from $1 to $2?',
        answer: '$2 - $1 - 1',
    },

    {
        question:
            'What is the $mode of the set of numbers from $1 to $2?',
        answer: '$getMedianFrom($1, $2)',
    },
]

function missingTestScore() {
    // how do the numbers get added in ... that is something that is important.
}

function pluralizer(s, yes) {
    console.log(s)
    if (!yes) return s
    if (isFunction(yes) && !yes()) return s
    return s + 's'
}
function toFractionWord(...args) {
    let [a, b] = fractiongetter(args)
    console.log({ a, b })
    const p =
        numberWords[Number(a)] +
        '-' +
        pluralizer(ordinalWords[b], a != 1)
    return p
}
function reverseOrdinal(s) {
    return ordinalWords.indexOf(depluralize(s))
}

const ordinalWords = [
    null,
    null,
    'half',
    'third',
    'fourth',
    'fifth',
    'sixth',
    'seventh',
    'eighth',
    'ninth',
    'tenth',
    'eleventh',
    'twelveth',
    'thirteenth',
]
const numberWords = [
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'ten',
    'eleven',
    'twelve',
    'thirteen',
    'fourteen',
    'fifteen',
    'sixteen',
    'seventeen',
    'eighteen',
    'nineteen',
    'twenty',
]

function fractionWordToExpression(s) {
    return s.replace(fractionWordRE, (x) => {
        let [a, b] = x.split('-')
        a = numberWords.indexOf(a)
        b = reverseOrdinal(b)
        return toFraction(a, b)
    })
}

function fractionDecomposition(level) {
    //'one-half of one-sixth is equal to';
    //let [a,b] = [4, 62]
    //let [c, d] = fractiongetter(a,b).map(getfactors)
    //let common = shared(c, d)
    //d = filtered(d, common)
    //console.log(c, d)
}

function mathComposition(level) {
    return getValue(BuildMath, NumberGen.generate(3))
}

const xoperationmap = [
    //['times more than', (a,b) => b * a],
    //['times less than', (a,b) => b / a],
    ['less than', (a, b) => b - a],
    ['more than', (a, b) => b + a],
    ['of', (a, b) => a * b],
    ['and', (a, b) => a + b],
    //['less',            (a,b) => a - b],
]

const operationmap = {
    'less than': nerdLessThanHelper,
    'more than': nerdMoreThanHelper,
    of: nerdOfHelper,
    //and: mhsa,
}

const mathOperations = {
    '+': function (a, b) {
        return a + b
    },
    '-': function (a, b) {
        return a - b
    },
    '/': function (a, b) {
        return a / b
    },
    '*': function (a, b) {
        return a * b
    },
}

function nerdOfHelper(a, b) {
    return mhsm(a, b)
}

function nerdLessThanHelper(a, b) {
    if (isPercentage(a)) {
        return mhsm(mhoperation(a, 100, '-'), b)
    }
    return mhss(b, a)
}

function nerdSumHelper(a, b) {
    return mhsa(a, b)
}

function nerdDifferenceHelper(a, b) {
    return mhss(a, b)
}

function nerdTimesHelper(a, b) {
    return mhsm(a, b)
}

function nerdMoreThanHelper(a, b) {
    if (isPercentage(a)) {
        return mhsm(mhoperation(a, 100, '+'), b)
    }
    return mhsa(b, a)
}

function conditional(fn, condition) {
    if (arguments.length == 3) {
        //console.log(arguments)
        return (
            isString(arguments[2])
                ? test(arguments[2], arguments[0])
                : arguments[2](arguments[0])
        )
            ? arguments[1](arguments[0])
            : arguments[0]
    }

    function handler(s) {
        const p = fn(s)
        return p
    }
    function catcher(s) {
        return 'unsuccess', s
        return s
    }

    return (s) => {
        return (
            isFunction(condition)
                ? condition(s)
                : test(condition, s)
        )
            ? handler(s)
            : catcher(s)
    }
}
function mhfactory(operator) {
    const parse = conditional(
        fractionWordToExpression,
        /[a-z]-[a-z]/
    )

    return function lambda(a, b, wrap = false) {
        const value = joinString(parse(a), operator, parse(b))
        return wrap ? latex.parens(value) : value
    }
}

function mhoperation(a, b, operation) {
    operation = mathOperations[operation]
    if (isNumber(a)) {
        return operation(a, b)
    }
    if (isPercentage(a)) {
        return a.replace(/-?[.\d]+/, (x) => {
            const p = operation(Number(x), b)
            return Math.abs(p)
        })
    }
    throw ''
}

function isPercentage(s) {
    return s.toString().endsWith('%')
}
function getValue(classObject, ...args) {
    return new classObject(...args).getValue()
}
function unzip(iterable) {
    return prepareIterable(iterable, 'entries').reduce(
        (acc, item) => {
            acc[0].push(item[0])
            acc[1].push(item[1])
            return acc
        },
        [[], []]
    )
}

class BuildMath {
    run(items) {
        const keys = []

        for (let i = 0; i < items.length - 1; i++) {
            let [a, b] = items.slice(i, i + 2)
            let source =
                isNumber(a) && isNumber(b)
                    ? 'betweenNumbers'
                    : 'betweenAnything'
            keys.push(randomPick(operationlib[source]))
        }

        const [delimiters, fs] = keys.reduce(
            (acc, key) => {
                const ab = operationlibconnector[key]
                acc[0].push(ab[0])
                acc[1].push(ab[1])
                return acc
            },
            [[], []]
        )

        let value = items[items.length - 1]
        let s = interweave(items, delimiters)

        for (let i = fs.length - 1; i >= 0; i--) {
            const fn = fs[i]
            value = fn(items[i], value)
            value = nerdEval(value)
        }

        const questioners = [
            (s) => 'What is ' + s + '?',
            (s) => s + ' = ?',
        ]

        return {
            question: randomPick(questioners)(s),
            answer: value,
        }
    }
}

function toInteger(x) {
    return Math.round(x)
}

function toFraction(a, b, mode = String) {
    if (isArray(a)) {
        b = a[1]
        a = a[0]
    }
    ;[a, b] = simplifyFraction(a, b)
    if (b == 1) return a
    if (mode == Array) return [a, b]
    if (mode == String) return a + '/' + b
    return '\\frac' + '{' + a + '}' + '{' + b + '}'
}
const mathtable = {
    polynomial: 'ax^2 + bx + c',
    linear: 'mx + b',
    cubic: 'ax^3 + bx^2 + cx + d',
}

class CreateMathExpression {
    constructor() {}
}
class AlgebraicExpression {
    constructor() {}
}

testobj = { a: 1, b: 2 }

function mpNumberRange(a, b, mode, exclusive) {
    let total = b - a + 1
    if (exclusive) total -= 2

    if (mode == 'even') {
        if (isEven(a)) return Math.ceil(total / 2)
        return Math.floor(total / 2)
    }

    if (mode == 'odd') {
        if (isOdd(a)) return Math.ceil(total / 2)
        return Math.floor(total / 2)
    }

    if (mode == 'percentage-odd') {
        let odd = mpNumberRange(a, b, 'odd', exclusive)
        return toPercentage(odd, total)
    }

    if (mode == 'percentage-even') {
        let even = mpNumberRange(a, b, 'even', exclusive)
        return toPercentage(even, total)
    }

    return total
}

function isMultipleFactory(s) {
    let multiple = search('multiple of (\\w+)', s)
    if (!multiple) return null
    if (!isNumber(multiple)) {
        multiple = wordToNumber(multiple)
    }
    return (n) => n % Number(multiple) == 0
}

function toBinaryRatio(target, total) {
    return toRatio(target, total - target)
}

function getClosestRefMatch(dict, key) {
    let value = dict[key]
    if (value) return value

    for (let [k, v] of Object.entries(dict)) {
        if (test(getFirst(key), k, 'i')) return v
    }
    throw 'cudnt find'
}

function numberRangeSolver(s) {
    const dict = {
        exclusive: (state) => {
            state.numbers.pop()
            state.numbers.shift()
            state.initialLength = state.numbers.length
        },
        even: { filter: isEven },
        odd: { filter: isOdd },
        'multiple of \\w+': { filter: isMultipleFactory },
        ratio: { postprocess: toBinaryRatio },
        percentage: { postprocess: toPercentage },
        fraction: { postprocess: toFraction },
    }

    let matches = findall(ncg(dict), s)
    let state = {}
    state.numbers = range(...getnumbers(s).slice(0, 2))
    state.initialLength = state.numbers.length

    if (matches.includes('odd') && matches.includes('even')) {
    }
    const seen = []
    for (let [k, ref] of Object.entries(dict)) {
        let $matches = matches.filter((x) => {
            return test(getFirst(k), x, 'i')
        })

        for (let match of $matches) {
            if (isFunction(ref)) {
                ref(state)
            } else if (ref.filter) {
                const runner = isFactoryFunction(ref.filter)
                    ? ref.filter(match)
                    : ref.filter
                state.numbers = state.numbers.filter(runner)
            } else if (ref.postprocess) {
                let payload = ref.postprocess(
                    state.numbers.length,
                    state.initialLength
                )
                return payload
            }
        }
    }
}

function getFirst(x, mode) {
    if (isObject(x)) {
        return Object[mode](x)[0]
    }
    if (mode == String) {
        return search(/^\S+/, x)
    }
    if (isString(x)) {
        return search('\\w+', x)
    }

    if (isArray(x)) {
        return x[0]
    }
}

function randomReplace(s, regex, replacement, count = 1) {
    while (count > 0) {
        let matches = findall(regex, s)
        let match = randomPick(matches)
        s = replace(match, replacement, s, '')
        count--
    }
    return s
}
function createExpressionToEqual(n, amount = 2) {
    let [value, variable] = numberboundarysplit(n)
    let store = NumberGen.numbergen({
        n: amount,
        unique: true,
        requirements: (x) => x != value,
        min: -9,
        max: 9,
    })

    let b = sum(store)

    let offset = b > value ? b - value : value - b
    if (offset) store.push(offset)

    let s = ''
    for (let i = 0; i < store.length; i++) {
        let item = store[i]
        if (i > 0) s += item < 0 ? ' - ' : ' + '
        s += Math.abs(item)
        if (variable) s += variable
    }
    return s
}
function decomposeMathTerm(s) {
    let terms = 1
    return randomReplace(
        s,
        '(?<!-)\\w+',
        (x) => {
            let expr = createExpressionToEqual(x) // has some levels
            return expr
        },
        terms
    )
}
function changeSigns(s) {
    return s.replace(/[\-\+]/, (x) => {
        return coinflip() ? x : '-'
    })
}

function infusionPopulate(template) {
    let question = repeatUntil(
        () => {
            return populate(changeSigns(template))
        },
        (question) => {
            let answer = nerdsolver(question)
            return isNiceAnswer(answer)
        }
    )
    return {
        question: decomposeMathTerm(question),
        answer: nerdsolver(question),
    }
}

function getTemplate(lib) {
    const runner = (x) => {
        if (isString(x)) return x
        return runner(x[0])
    }
    return runner(lib)
}

class Quadratic {
    constructor(a, b, c) {
        if (c) {
            this.a = a
            this.b = b
            this.c = c[(this.x1, this.x2)] = Quadratic.getRoots(
                a,
                b,
                c
            )
        } else {
            this.x1 = a
            this.x2 = b
            this.a = 1
            this.b = a + b
            this.c = a * b
        }
    }
    getRoots(a, b, c) {
        const equations = ['x1 + x2 = ' + b, 'x1 * x2 = ' + c]
        return nerdamer
            .solveEquations(equations)
            .map((x) => x[1])
    }

    toString() {
        function getSign(n, degree) {
            if (n == 0) return ''
            let absolute = Math.abs(n)
            let prefix = absolute == 1 ? '' : absolute
            let operator =
                degree == 2
                    ? n > 0
                        ? ''
                        : '-'
                    : n > 0
                    ? ' + '
                    : ' - '

            let suffix =
                degree == 0
                    ? ''
                    : degree == 1
                    ? 'x'
                    : 'x^' + degree

            return operator + prefix + suffix
        }

        let s = ''
        s += getSign(this.a, 2)
        s += getSign(this.b, 1)
        s += getSign(this.c, 0)
        return s
    }
    static create(x1, x2) {
        if (!x1) x1 = rng(-9, 9)
        if (!x2) x2 = rng(-9, 9)
        return new Quadratic(x1, x2)
    }
    createSiblings(count = 1) {
        const store = new UniqueStorage3(String)
        for (let i = 0; i < count; i++) {
            const args = coinflip()
                ? [this.x1, null]
                : [null, this.x2]
            store.add(Quadratic.create, ...args)
        }
        return smallify(store.store)
    }
    static cancelToOne() {
        let top = new Numbergen().create(4, '-99')
        let bottom = repeatUntil(
            () => shuffle(copy(top)),
            (n) => n[0] != top[0]
        )
        let [a, b, c, d] = top
        let [e, f, g, h] = bottom
        let A = Quadratic.create(a, b)
        let B = Quadratic.create(c, d)
        let C = Quadratic.create(e, f)
        let D = Quadratic.create(g, h)
        return Fraction.create(A, B, null, C, D)
    }
}

class Fraction {
    static stringify(a, b) {
        let delimiter = '/'
        return a + delimiter + b
    }
    getPeriod() {
        let n = this._numerator
        let d = this._denominator

        var primefactors = getprimefactors(d)
        for (var i = 0; i < primefactors.length; i++) {
            if (
                primefactors[i] !== 2 &&
                primefactors[i] !== 5
            ) {
                let output = []
                let ns = []

                for (var i = 0; i < 20; i++) {
                    var temp2 = parseInt(n / d)

                    if (ns[n] === undefined) {
                        ns[n] = i
                    } else {
                        this.decimalplaces = output.slice(ns[n])
                        return this.decimalplaces.length
                    }

                    output.push(temp2)
                    n %= d
                    n += '0'
                }
                console.log('reached the end')
                return output
            }
        }
        return 0
    }

    toDecimal() {
        const [a, b] = this.toString(Array)
        return a / b
    }

    static generate(...reqs) {
        let rng = rngfactory(1, 99)
        let a = rng()
        let b = rng()
        let frac = a / b
        let pass

        while (true) {
            pass = true
            for (let req of reqs) {
                if (!req(frac)) {
                    a = rng()
                    b = rng()
                    frac = a / b
                    pass = false
                    break
                }
            }
            if (pass) {
                return new Fraction(a, b)
            }
        }
    }
    constructor(...args) {}
    combine(items) {
        if (!isArray(items)) return items
        return items
            .map(conditional(wrap.parens, /^\(/))
            .join('')
        let s = ''
        for (let i = 0; i < items.length; i++) {
            if (test('^(', item)) {
                return
            }
        }
    }
    toString(mode) {
        const denominator = this.combine(this.denominator)
        const numerator = this.combine(this.numerator)
        const p = toFraction(numerator, denominator, mode)
        return p
    }
    static create(...args) {
        if (args.includes(null)) {
            let [top, bottom] = splitarray(args).map(
                (items) => {
                    return items
                        .map(String)
                        .map((item) => parens(item))
                        .join(' * ')
                }
            )
            return toFractionString(top, bottom)
        }
        return new Fraction(...args)
    }
    addDenominatorItem(s) {
        this.denominator.push(s)
    }

    addNumeratorItem(s) {
        this.numerator.push(s)
    }
}

function getCombinations(arr, targetLength = 2) {
    let combinations = []
    let temp = []
    let length = Math.pow(2, arr.length)

    for (let i = 0; i < length; i++) {
        temp = []
        for (let j = 0; j < arr.length; j++) {
            if (i & Math.pow(2, j)) {
                temp.push(arr[j])
            }
        }
        if (targetLength) {
            if (temp.length == targetLength) {
                combinations.push(temp)
            }
        } else if (temp.length > 0) {
            combinations.push(temp)
        }
    }

    combinations.sort((a, b) => a.length - b.length)
    return combinations
}

function smartsolver(s) {
    console.log(s)
    tl()
}
function populateWithNewNumbers(s) {
    const items = ['multiple of']
    const regex = '\\d+'
    const numbers = findall(regex, s)
    const ordering = getNumberOrder(numbers)
    for (let i = 0; i < ordering.length; i++) {}
    // has to preserve the ordering.
    function parser(x) {
        console.log(x)
        return rngAround(x)
    }
    return replace(`(?<!${items})${regex}`, parser, s)
}

function getNumberOrder(items) {
    let store = []
    let prev = 0
    for (let i = 0; i < items.length; i++) {
        let number = items[i]
        if (i == 0) {
            prev = number
            continue
        }
        let sign = prev > number ? 1 : -1
        store.push(sign)
        prev = number
    }
    return store
}

function remainingSolver(s) {
    const superNumberRE = '-?\\d+(?:\\.|:)?\\d*%?'
    const [a, b] = findall(superNumberRE, s)
    const args = isPercentage(a)
        ? [a, 'x', mhss('100%', a), b]
        : [b, 'x', mhss('100%', b), a]
    return solveProportions(...args)
}

function solveProportions(a, b, c, d) {
    const expr = mhse(mhsd(a, b), mhsd(c, d))
    return nerdSolver(expr)
}
function isCapitalized(s) {
    return /^[A-Z]/.test(s)
}
function pairNumbersToNames(s) {
    const regex = '-?\\d+(?:\\.|:)?\\d*%?'
    let numbers = findall(regex, s)
    let names = findNames(s)
    let target = names.pop()
    return [zip(names, numbers), target]
}

function indepthRatio() {
    // not in use atm
    const dict = {
        ratioExpression: ['boys to girls', 'girls to boys'],
        gender: ['boys', 'girls'],
        pastOrPresent: ['are currently ', 'were originally '],
        joinOrLeaveG: ['join', 'leave'],
        joinOrLeaveB: ['join', 'leave'],
    }

    const {
        joinOrLeaveG,
        joinrOrLeaveB,
        ratioExpression,
        gender,
        pastOrPresent,
    } = editDict(dict, randomPick)
    let a = rng(2, 5)
    let b = a + rng()
    let girls = rng(notPrime)
    if (joinOrLeaveG == 'leave') girls *= -1

    let [h, i] = simplifyRatio(a, b + girls)
    let template = `The ratio of ${ratioExpression} in Ms. Elina's Cat class is ${a}:${b}.`
    let e1 = `After ${Math.abs(
        girls
    )} girls ${joinOrLeaveG} the class, the ratio is now ${h}:${i}.`
    //let e2 = `After ${boys} boys ${joinOrLeaveB} the class, the ratio is now ${j}:${k}.`
    let conclusion = `How many ${gender} ${pastOrPresent}in the class?`

    let question = [template, e1, conclusion].join(' ')
    let answer = 'hi'
    return { question, answer }
}

const newproblemtemplates = [
    'After eating 20% of a pie, Sarah gives the remaining 5 slices to Tom. How many slices did Sarah eat?',
    'Tom eats 10 slices of a pie, then gives the remaining 10% to Sarah. How many slices does Sarah get?',
    '$name makes $a $food every $b $unit(time). How many $food does $name make in $c $unit(nearby)?',
    'What fraction of $rng()% more than $frac() of 1 $unit(time) is $rng()% of $rng()% of 1 $unit(nearby)?',
    '20% more than one-fifth of 1 hour is what fraction of 10% of 20% of 1 minute?',
    'What fraction of 1 $unit(time) is $rng()% of 1 $unit(time)?',
    '$rng()% of $rng() $unit(time) is what percentage of $rng() $unit(nearby)?',

    {
        //question: 'At Walmart, you can purchase a 15 pound bag of Nishiki Premium Brown Rice for $d.34, or a 5 pound bag for $5.54. $name wants to purchase ${$a * 15} pounds of rice for his restaurant. How much money will he save if he purchases the rice in 5 pound bags?',
        question:
            'At Walmart, you can purchase a $ab pound bag of Nishiki Premium Brown Rice for $c dollars, or a $a pound bag for $d. $name wants to purchase $abc pounds of rice for his restaurant. How much money will he save if he purchases the rice in $a pound bags?',
        answer: 'absolute((($5 / $1) * $2) - (($5 / $3) * $4))',
        //answerRequirement: isInteger,
    },
    //null,
    {
        quantity: 2,
        question:
            "If rice costs $a cents per serving at $name's taco restaurant, and $b jumbo meals costs $c dollars, how many servings of rice are equal to 1 jumbo meal?",
        answer: '$1 * x = $3 * 100 / $2',
        //nerdamer cna solve this
        //answerRequirement: isInteger,
    },

    { quantity: 1, infusion: '(ax + b)/c = d' },
    '(ax + b)/c = (dx + e)/f',
    {
        quantity: 1,
        question:
            'How many minutes are in $rng(10, 90)% of $frac() of $a hours and ${$b * 60} seconds and $c minutes?',
    },
]

function quantify(quantity, item) {
    if (!quantity) return null
    if (quantity == 1) return item
    return { quantity, item }
}

const commonstringfractions = [
    '1/4',
    '1/6',
    '1/8',
    '1/9',
    '1/10',
    '1/2',
    '1/3',
    '2/9',
    '1/5',
    '3/4',
    '3/8',
    '3/10',
    '2/3',
    '4/9',
    '2/5',
    '5/6',
    '5/8',
    '5/9',
    '3/5',
    '7/8',
    '7/9',
    '7/10',
    '8/9',
    '4/5',
    '9/10',
]

function checkfactory(arg) {
    return isFunction(arg) ? arg : (s) => test(arg, s)
}
function partitioned(items, ...args) {
    if (isArray(items)) {
        return partitionArray(items, ...args)
    }
}
function partitionArray(items, ...args) {
    const store = range(args.length + 1, [])
    for (let item of items) {
        args.forEach((arg, i) => {
            const check = checkfactory(arg)
            if (check(item)) {
                found = true
                store[i].push(item)
            } else if (i == args.length - 1)
                store[i + 1].push(item)
        })
    }
    return store
}

const npt2 = [
    'ax/b = c',
    { quantity: 1, infusion: 'ax/b = c/d' },
    {
        quantity: 1,
        infusion: 'n(n - x)/n + n(x - n) = n(x+n)/n',
    },
    'ax/b + cx/d = e/f',
    'abx * ab = a * a * b * c',
    'If 1 oak is 5 bees, how many bees is 8 oaks?',
    // works
]

function finder(items, key) {
    if (!key) return items
    const found = items.find((x) =>
        test(key, JSON.stringify(x), 'i')
    )
    return found ? found : throwError()
}

//onlyIntegerAnswers: true,
//onlyPositiveAnswers: true,
//useVariablesInAnswer: true,
//level: 1,

function createDivisionProblem(a, b) {
    // Basically ... it is done via decimalToFraction ... a similar sort of parsing.
}

function zeroPad(x) {
    return String(x).length == 1 ? '0' + x : x
}
function changeDate(s, increment) {
    return s.replace(/(?<=-)\d+/, (x) =>
        zeroPad(Number(x) + increment)
    )
}
function isYesterday(date) {
    return changeDate(datestamp(), -1) == date
}

function isToday(date) {
    return datestamp() == date
}
function getDialogue3({
    key = 'dialogue',
    today = true,
    reverse = true,
    file = 'd.txt',
} = {}) {
    if (isString(arguments[0])) key = arguments[0]
    let datestampRE = '\\d+-\\d+-\\d+'
    let regex = createAccumulateRegex(
        parens(datestampRE),
        '(.+)',
        datestampRE
    )
    //let regex = '(?<=\\n|^)' + parens(datestampRE) + '(.*)\\n([^]+?)' + lookahead(datestampRE)
    let items = findall(regex, read(file), 'g', 'nf') // means nofilter
    if (reverse) items.reverse()

    for (let [date, tag, text] of items) {
        if (today) {
            if (!isToday(date)) {
                if (!isYesterday(date)) {
                    continue
                }
            }
        }

        if (test(key, tag, 'i')) {
            return text.trim()
        }
    }
    const names = items.map((x) => x[1])
    console.log(names)
    console.log(names.find((x) => test(key, x, 'i')))
    return null
}

class LineEdit2 {
    constructor(parser) {
        this.store = []
        this.parser = parser.bind(this)
        this.index = 0
        this.temp = []
        this.state = {
            emptyLineCount: 0,
        }
    }

    run(s) {
        this.lines = s.trim().split('\n')

        while (this.index < this.lines.length) {
            this.parser(this.lines[this.index])
            this.index += 1
        }
    }

    getValue() {
        //const p = this.lines.join('\n')
        //console.log(p)
        //return p
        console.log(this.store)
    }

    hasNext() {
        return this.lines[this.index + 1] != ''
    }
}

function parser(s) {
    if (!s) {
        this.state.emptyLineCount += 1
        return
    }

    if (
        this.index == this.lines.length - 1 &&
        this.temp.length > 0
    ) {
        this.store.push(this.temp)
        return
    }
    if (!this.state.insideChunk) {
        if (s.length > 100 && !this.hasNext()) {
            this.store.push(s)
            return
        }

        if (s.length < 80 && this.hasNext()) {
            this.temp.push(s)
            this.state.insideChunk = true
            return
        }
    }

    if (this.state.insideChunk) {
        this.temp.push(s)
        if (!this.hasNext()) {
            if (this.nextNextIsShort()) {
                this.index += 1
            }
            this.state.insideChunk = false
            this.store.push(this.temp)
            this.temp = []
        }
        return
    }
}

class LineEdit3 extends BaseTokenizer {
    constructor(s) {
        super(s)
    }
    run() {
        const introRE = /[^]+?\n\n(?=\w.+\n\w)/
        //const contiguousRE = /\w.+(?:\n\w.+)+/
        //const contiguousRE = /\w.+(?:\n\w.+)+(?:\n+\w.+\n\n)?/
        const contiguousRE =
            /\w.+(?:\n\w.+)+(?:\n+\w.+\n\n(?:\w.+\n\n)?)?/
        const spacerRE = /\n\n+/
        const colonRE = /\w+:\n+\S[\w\W]+?\n\n+/
        //const extensionRE = /\n\s*\w.+
        const regexes = [spacerRE, contiguousRE, colonRE]

        let regex
        while (this.nullCount < 3) {
            if (this.store.length == 0) {
                regex = introRE
                this.eat(regex)
            }

            for (let r of regexes) {
                if (this.eat(r)) {
                    if (r == contiguousRE) {
                        //this.eat(extensionRE, 'join')
                    }
                    break
                }
            }
        }
        console.log(stringify(this.store))
    }
}

function appendLast(arr, item) {
    arr[arr.length - 1] = arr[arr.length - 1] + item
}

function umbuilder23(s) {
    function splitter(line, regex) {
        const [a, b] = line.split(regex).filter(exists)
        return [{ text: a, bold: true }, b]
    }
    const colonRE = /(^.*?: *)/
    const startingPeriodRE = /(^\d+\. *)/

    return chunkgetter(s).map((x, j) =>
        linegetter(x).map((line, i, lines) => {
            if (test(startingPeriodRE, line)) {
                return splitter(line, startingPeriodRE)
            }

            if (i == 0 && j != 0) {
                if (line.endsWith(':')) {
                    return {
                        text: line,
                        bold: true,
                        marginBottom: true,
                    }
                }
                if (line.length < 60) {
                    return { text: line, bold: true }
                }
            }
            if (i > 0 && line.length > 250) return '\n' + line

            if (test(colonRE, line)) {
                return splitter(line, colonRE)
            }
            return line
        })
    )
}

//const xfoo = (() => {const g = require('./edit.js');eval(g.toString());return eval('getdependencies2');})()
//const xfoo = (() => {const g = require('./edit.js');eval(g.toString());return eval('countdependencies');})()

//xfoo('difficultyRanking')
//const g = require('./edit.js')

//let names = getFunctionNames(read('classroom.js'))
//tempwrite(reduce(names, x => [x, g(x, globaleval)]))

class Qg {
    constructor(student) {
        this.tracker = {}
        this.config = {
            latex: false,
        }

        this.student = student
        this.indexed = new Indexed(this.student.templates)
        this.watcher = new Watcher(
            (item) => item.question || item.passage
        )
        this.numbergen = new NumberGen()

        const generatorlib = {
            //'arithmetic': InfusionGenerator,
            //'cogart': InfusionGenerator,
            arithmetic: SimpleGenerator,
            //'word-problems': MTG,
        }

        this.generators = this.indexed.keys.reduce(
            (acc, key) => {
                if (generatorlib.hasOwnProperty(key)) {
                    const Generator = generatorlib[key]
                    acc[key] = new Generator(
                        this.numbergen,
                        this.watcher
                    )
                }
                return acc
            },
            {}
        )

        this.reset()
    }

    get generator() {
        return this.generators[this.topic]
    }

    setConfig(config) {
        Object.assign(this.numbergen.config, config)
        Object.assign(this.config, config)
        Object.assign(this.generator.config, config)
    }

    set level(level) {
        this.numbergen.config.level = level
        this.generator.config.level = level
        this.config.level = level
    }

    get level() {
        return this.config.level
    }

    getValue(template) {
        return this.generator.generate(template)
    }

    generate() {
        this.numbergen.reset()
        if (this.indexed.finished) return true
        let value = this.getValue(this.indexed.value)
        if (isBrowser())
            value.question = toLatex(value.question)
        return value
    }

    get index() {
        return this.indexed.index
    }

    set index(val) {
        this.indexed.index = val
        this.topic = this.indexed.key
    }

    reset() {
        this.topic = getFirst(this.student.templates, 'keys')
        this.level = this.student.level
        this.index = this.student.lastIndex
    }

    incrementIndex(value = 1) {
        if (!value) return
        this.index += value
        this.numbergen.config.level = this.student.level
    }

    incrementLevel(value = 1) {
        if (!value) return
        this.level += value
        this.numbergen.config.level = this.level
    }
}

class Qm extends BaseGenerator {
    constructor(...args) {
        super(...args)
        this.memory = {}
        this.biglib = mtState()
        this.regex = getRegexForMathTemplater()
        this.cache = new Cache()
    }

    create(item) {
        switch (typeof item) {
            case 'function':
                return this.functionRunner(item)
            case 'string':
                return this.wordSolverRunner(item)
            case 'object':
                return this.objectRunner(item)
        }
    }
}

const wpt = ['How many minutes are in $a hours?']
const kloe = {
    lastIndex: 0,
    level: 0,
    templates: {
        arithmetic: ['a + b', 'a + b', 'a * b', 'a - b - c'],
        'word-problems': wpt,
        //cogart: ['aaaaaa * aaa', 'ab * ccccccc'],
    },
}

//z.config.latex = true
//z.infusion.config.withVariables = true
//z.level += 3
//console.log(z.generate())
//z.topic = 'word-problems'
//console.log(z.next())

//console.log(z.numbers)
//console.log(z.getQuestion('$1 + $2', [3, 6]))
//console.log(z.numbers)

function nerdguess(s) {
    //let variables = getVariables(s)
}
//console.log(nerdsolver('9a + b = 22'))

class SimpleGenerator extends BaseGenerator {
    constructor() {
        super()
        this.left = []
        this.right = []
        this.items = []
        this.numbers = []
        this.generator = new MonomialGenerator(this)
    }
    end(val) {
        this.items[this.items.length - 1] = '='
        this.items.push(sum(this.items.filter(isNumber)))
    }
    addNumber() {
        let value = this.generator.generate()
        this.push(value)
    }
    generate() {
        this.addNumber()
        this.addNumber()
        this.end()
        return this.toString()
    }

    addOperator() {
        let value = '+'
        this.push(value)
    }

    toString() {
        const p = this.items.join(' ')
        console.log(p)
        return p
    }

    push(n) {
        this.items.push(n)
        if (isNumber(n)) {
            this.numbers.push(n)
            this.addOperator()
        }
    }
}

class MonomialGenerator {
    constructor(state) {
        this.state = state
    }

    generate() {
        return rng(10, 99)
    }
}

class MTM extends BaseGenerator {
    constructor() {
        super()
    }

    generate() {
        let nodes = rng(2, 5)
        let expr = this.build(nodes, null, null).toString()
        if (nodes > 3) {
            expr = addRandomParentheses(expr)
        }
        return {
            question: expr + ' = ?',
            answer: eval(expr),
        }
    }

    build(nodes, leftCount, rightCount) {
        if (leftCount != null) leftCount += 1
        if (rightCount != null) rightCount += 1
        if (nodes == 1) return rng()
        const numLeft = Math.floor(nodes / 2)
        const numRight = Math.ceil(nodes / 2)
        const leftSubTree = this.build(numLeft, leftCount, null)
        const rightSubTree = this.build(
            numRight,
            null,
            rightCount
        )
        const operator = randomOperator()
        return new MathTree(
            leftSubTree,
            rightSubTree,
            operator,
            nodes
        )
    }
}

class MathTree {
    constructor(left, right, operator, nodes) {
        this.left = left
        this.right = right
        this.operator = operator
        this.nodes = nodes
    }
    toString() {
        let left = ''
        let right = ''

        if (this.nodes == 2) {
        } else if (this.nodes == 3) {
            //left = '('
            //right = ')'
        }

        return (
            left +
            this.left +
            ' ' +
            this.operator +
            ' ' +
            this.right +
            right
        )
    }
}

function harder(obj) {
    obj.incrementIndex()
    const p = obj.generate()
    console.log(p)
    return p
}

s = `

After 1/4 of a ribbon is thrown away, the remaining part is cut into two pieces whose lengths are in the ratio of 4 : 5. If 9 inches of the original ribbon was thrown away, how long is the shorter of the two remaining pieces of ribbon?
`
// the evaluation is clientside.
//console.write(math0929generator({studentLevel: 5, templates: decimalTemplates, repeat: 3,  mode: 'practice', title: 'Multiplication with Decimals and Zeroes'}))

function run() {
    z = new Qg(kloe)
    harder(z)
    harder(z)
    harder(z)

    //

    z = new MTM()
    console.see(z.generate())
    console.see(z.generate())
    console.see(z.generate())
    console.see(z.generate())
}
//const nerdamer = require("nerdamer/all.min")
//console.log(nerdsolver('2 + 2 = 2^x'))

//console.log(getprimefactorization(18))

function toExponentialForm(n) {
    if (n.length < 3) return n
    const store = new Storage(Number)
    const factors = getfactors(Number(n))
    factors.forEach((item, i) => store.add(item))

    let s = ''
    store.forEach(([k, v], i) => {
        s += k + '^' + v + ' * '
    })
    return s.slice(0, -3)
}

//math0925()

function mathsolver(s) {
    const answer = nerdamer(s).evaluate().toString()
    return answer
}

//s = '3/4 / (3/4)'
//const nerdamer = require("nerdamer/all.min")
//console.log(solve(s))
//console.log(Calculation.calculate(s))
//console.log(mathsolver(s))
//console.log(Object.keys(nerdamer))

function evaluated(s) {
    const nerdamer = require('nerdamer/all.min')
    //console.log(nerdamer(s).simplify().toString())
    console.log(nerdamer.convertToLaTeX(''))
    return
    //console.log(nerdamer(s).multiply().toString())
    console.log(
        fixNerdamer(
            nerdamer.convertToLaTeX(
                identity(nerdamer(s).expand().toString())
            )
        )
    )
    //console.log(s)
    //console.log(nerdamer.convertToLaTeX(s))
    //return
    //console.log(nerdamer(s).sub('x', 3).toString())
    //console.log(nerdamer(s).simplify().toString())
    //return nerdamer(s).evaluate().text()
}
//zxcv =  '(-2x + 3) * (4x + 5)'
//console.log(evaluated(zxcv))

//console.log(decimalToFraction('0.3333'))

function generateMultipleChoice(
    answer,
    length = 4,
    letter = null,
    onlyPositive = 0
) {
    let ref = letter ? char2n(letter) : rng(1, 20)
    if (ref == 24) ref -= 1
    if (ref == 25) ref -= 2
    let index = ref % length
    let increment
    let count = 0
    let condition = (x) => {
        if (onlyPositive && parseInt(x) < 0) return false
        return true
    }
    let storage = new UniqueStorage(condition)

    for (let i = 0; i < length; i++) {
        const runner = () => {
            return i == index
                ? answer
                : modifyNumber(answer, changeAnswer, i, index)
        }
        storage.add(runner)
    }

    const choices = question
        ? storage.store.map(f)
        : storage.store
    return [store, index]
}

//generateMultipleChoice('3/5')

/*  */

sat9am = [
    { name: 'kloe', grade: 6 },
    { name: 'sam', grade: 6 },
]
//math0925()

function math0730() {
    classMixin(
        MathTemplater,
        MathTemplaterMixins,
        KeyValFunctionMixins
    )
    Classroom2.create(sat9am)
}

function postProcessAnswer(answer) {
    if (isString(answer) && answer.endsWith('%'))
        return fixPercentageDecimals(answer)
    return answer
}

function postProcessQuestion(s) {
    s = fixSentenceGender(s)
    return s
}

//const introducers = [
//'find',
//'how many',
//]
//const connectors = [
//'are in',
//'is (?:equivalent|equal) to',
//'equals',
//'is the same as',
//'the number of',
//]
//

function trial(f, ...args) {
    try {
        return f(...args)
    } catch (e) {
        return logError(e)
    }
}

function ncga(s, a, flags) {
    const value = s.replace(
        /\$1/,
        prepareIterable(a, 'keys').join('|')
    )
    return flags ? RegExp(value, flags) : value
}

function logError(INPUT) {
    const value = { ERROR_LOCATION: getCaller(-1), INPUT }
    console.log(value)
    return value
}
function assert(condition, message = 'assertion-error') {
    if (isFunction(arguments[1])) {
        let result = arguments[1](arguments[0])
        if (result) return
        const error = {
            ASSERTION_ERROR: '!' + arguments[1].name,
            INPUT: arguments[0],
            CALLER: getCaller(-1, 0),
        }
        console.log(error)
        throw ''
    }
    if (!exists(condition)) {
        console.log({
            ASSERTION_ERROR: 'sup',
            INPUT: arguments[0],
            CALLER: getCaller(-1, 0),
        })
        throw message
    }
}
function assert(x) {
    if (exists(x)) return
    const [caller, lineNumber] = getCaller(-1, 0)
    const message =
        AssertionMessages[caller] || 'No AssertionMessage'
    console.log({
        ASSERTION_ERROR: message,
        LINE_NUMBER: lineNumber,
        CALLER: caller,
    })
    throw ''
}

function anySolver(s) {
    console.log(s)
    function parse(s) {
        const match = search(/(\d+) ?([a-z]+)/i, s)
        if (match) return match.map(atSecond(depluralize))
        return [s, null]
    }

    let [a, c, b] = s.split(/ *([\*\-\+\/]) */)
    let [valA, unitA] = parse(a)
    let [valB, unitB] = parse(b)
    let [ka, kb] = unitConversion2(unitA, unitB)
    let k = mhsd(ka, kb)
    let A = mhsm(valA, k)
    let B = valB
    let expr = A + c + B
    let value = nerdeval(expr)
    return value
}
function join(...a) {
    if (a.length == 2 && isArray(a[0])) {
        return a[0].join(a[1])
    }
    const args = prepareIterable(
        filter(gatherArgs(a)),
        'values'
    )
    if (empty(args)) {
        return ''
    }

    if (args.length == 1) return args[0]
    if (args.length > 1 && /[ -.]$/.test(getLast(args))) {
        let d = args.pop()
        return args.join(d)
    }

    let s = ''
    for (let i = 0; i < args.length; i++) {
        let item = args[i]
        s += item
        if (i < args.length) {
            let next = args[i + 1] || ''
            s +=
                item.includes('\n') || next.includes('\n')
                    ? '\n\n'
                    : '\n'
        }
    }
    return s
}
function getNumbers(s, mode) {
    if (mode == Number) {
        regex = /\d+(?:\.\d+)?/g
    } else {
        regex = /-?\d+(?:\.\d+)?/g
    }
    const match = s.match(regex)
    //console.log(s, match, 'h')
    if (!match) return []
    if (mode == String) return match
    return match.map(Number)
}

function classMixin(Base, ...mixins) {
    for (let mixin of mixins) {
        for (let [k, v] of Object.entries(mixin)) {
            if (isFunction(v)) {
                if (isFunction(Base)) {
                    Base.prototype[k] = v
                } else {
                    Base[k] = v.bind(Base)
                }
            } else {
                Object.defineProperty(Base.prototype, k, v)
            }
        }
    }
}

/* these are the main parsers for the run() function and this.parsers */
function getEnd(s, key) {
    let r = RegExp(key + '$')
    return mget(r, s)
}

var MathTemplaterMixins = {
    infusionNumberGetter(s) {
        let [text, x] = getEnd(s, 'x')
        if (!text) return x
        return this.abcNumberGetter(text) + x
    },
    abcNumberGetter(s) {
        const g = (s) => this.numbergen.generate(s)
        const f = (s) => this.cache.get(s, g)

        let x
        ;[s, x] = s.length == 2 ? getEnd(s, 'x') : [s, '']

        switch (s) {
            case 'x':
            case 'n':
            case 's':
            case 'r':
                return rng()
                throw ('not in use', s)
                return this.levelNumberGetter()
            case 'f':
                return toFraction(this.numbergen.generate(2))
            case 'm':
                return
                return this.moneyNumberGetter()
        }

        let a = this.dollarWord1(s)
        return isDefined(a) ? a : f(s)
    },

    callable(s) {
        let [caller, args] = parseCallable(s)
        args = args.map((item, i) => {
            return this.bracket(item)
        })

        return this.callable1(caller, ...args)
    },

    bracket(s) {
        s = s.replace(/\b[a-z]\b/g, '$$$&')
        //console.log({s}); throw ""
        return this.wrap('skipNumbers', () => {
            return this.run(s)
        })
    },

    number(s) {
        if (isNegative(s)) {
            return this.numbers[this.numbers.length + Number(s)]
        }
    },

    dollarWord(s) {
        let a = this.dollarWord1(s)
        return isDefined(a) ? a : this.callable1(s)
    },
}
const mathTemplaterHelperFunctions = {
    getX() {
        /* it is too complicated */
        this.once(() => {
            this.tempRef.xCount = count(/\$x/g, this._s)
            this.tempRef.allowNonNumbers = true
        })

        const c = this.tempRef.xCount--
        if (c > 0) {
            if (coinflip(1 / c)) {
                this.tempRef.xCount = -100
                return 'X'
            }
            return this.numbergen.generate()
        } else if (c == 0) {
            return 'X'
        } else {
            return this.numbergen.generate()
        }
    },

    getValue(s) {
        const value = this.run(s, 1)
        const numbers = this.numbers
        const cache = toJSON(this.cache)
        this.clear()
        /* resetState: numbers, tempRef, cache */
        /* tempRef not used yet */

        return {
            value,
            numbers,
            cache,
        }
    },
    eval(s) {
        if (hasProse(s)) return s
        return nerdSolver(s)

        //if (isArithmetic(s)) {
        //console.log(s); throw '';
        //return this.calculation.calculate(s)
        //}
        //return s
    },
    /* ----------------------- */
    callable1(caller, ...args) {
        if (DefaultMathMixins[caller]) {
            let f = DefaultMathMixins[caller]
            return f.call(this, ...args)
        }

        if (MathTemplaterCallableMixins[caller]) {
            console.log(caller, 'cccc')
            let f = MathTemplaterCallableMixins[caller]
            return f.call(this, ...args)
        }

        return eval(stringcall(caller, ...args))
    },

    dollarWord1(s) {
        if (s in this.dollarWordRef) {
            return fget2(this.dollarWordRef[s])
        }
        if (this.wordnet && this.wordnet.has(s)) {
            return this.wordnet.getSibling(s)
        }
        return this.callable1(s)
    },

    topicalNumberGetter(topic) {
        const level = this.studentConfig.level
        const ref = MathTemplaterNumberRanges[topic][level]
        return fget2(ref)
    },
}
function fget2(ref) {
    let value

    if (isPrimitive(ref)) {
        return ref
    }

    if (isArray(ref)) {
        value = randomPick(ref)
    } else if (isFunction(ref)) {
        value = ref()
    }

    if (isArray(value)) {
        return rng(...value)
    } else {
        return value
    }
}
function parseCallable(s) {
    let [a, b] = search(/(\w+)\((.*?)\)$/, s)
    const args = split(b, /, +/)
    return [a, args]
}
class Cache {
    getValue() {
        return this.store
    }
    constructor(store = {}) {
        this.store = isFunction(store) ? new store() : store
        const name = this.store.constructor.name
        this.get = this['get' + name]
        this.set = this['set' + name]
        this.clear = this['clear' + name]
        this.update = this['update' + name]
    }
    updateWeakMap(key, value) {
        const prev = this.get(key)
        this.store.set(key, merge(prev, value))
    }

    setWeakMap(key, value) {
        this.store.set(key, value)
    }

    setObject(key, value) {
        this.store[key] = value
    }

    updateObject(key, value) {
        const prev = this.get(key)
        this.set(key, merge(prev, value))
    }

    clearObject() {
        this.store = {}
    }
    clearWeakMap() {
        this.store = new WeakMap()
    }
    getWeakMap(key, value) {
        if (this.store.has(key)) {
            const storedValue = this.store.get(key)
            return storedValue
        }
        if (isFunction(value)) value = value(key)
        this.store.set(key, value)
        return value
    }

    getObject(key, value) {
        if (this.store.hasOwnProperty(key)) {
            return this.store[key]
        }
        if (value) {
            if (isFunction(value)) value = value(key)
            this.store[key] = value
            return value
        }
    }
}
function thisf(state, s) {
    if (isFunction(s)) {
        return s
    }
    if (isObject(s)) {
        if (s.after || s.before) {
            return function lambda2(key) {
                const f = lambda(key)
                function lambda3(...args) {
                    const value = f(...args)
                    const after =
                        s.after &&
                        s.after(state, value, args[0])
                    return after
                }

                return lambda3
            }
        }
    }
    if (!s) {
        return lambda
    }
    const items = split(s, '.')
    switch (items.length) {
        case 1:
            return state[items[0]].bind(state)
        case 2:
            const refState = state[items[0]]
            return refState[items[1]].bind(refState)
    }

    function lambda(key) {
        if (isFunction(key)) {
            return key
        }

        if (isArray(key)) {
            return compose(key)
        }
        if (key in state) {
            return state[key].bind(state)
        }
        //if (key == 'timeSolver') {
        //console.log(key, 'ggg')
        //console.log(bringToLife(key))
        //}
        return bringToLife(key)
    }
}
const MathTemplaterCallableMixins = {
    frac(s) {
        /* frac */
        return fractionWord(randomFraction())
    },
    foo(...args) {
        console.log(args)
        return 1
    },
    arctic() {
        console.log('arc')
    },
    sum(...args) {
        console.log(args, 'hi')
        return sum(args)
    },
    pow(degree = 2) {
        return this.topicalNumberGetter('pow' + degree)
    },
    pow2() {
        return this.topicalNumberGetter('pow2')
    },
    pow3() {
        return this.topicalNumberGetter('pow3')
    },

    last() {
        return getLast(this.numbers)
    },

    other() {
        return this.tempRef.other
    },
    or(...args) {
        if (this.tempRef.hasOwnProperty('or')) {
            return this.tempRef.or
        }
        let [a, b] = shuffle(args)
        this.tempRef.other = b
        this.tempRef.or = a
        return a
    },
    even() {
        return MathTemplaterCallableMixins.or.call(
            this,
            'odd',
            'even'
        )
        //return this.or('odd', 'even')
    },

    odd() {
        return MathTemplaterCallableMixins.or.call(
            this,
            'odd',
            'even'
        )
    },

    rnp(...args) {
        if (exists(args)) {
            let arg = randomPick(args)
            this.tempRef.args = args
            this.tempRef.a = arg
            return arg
        } else {
            let ignore = []
            for (let letter of alphabet) {
                if (this.tempRef.hasOwnProperty(letter)) {
                    ignore.push(this.tempRef[letter])
                    continue
                }
                let value = randomPick(
                    filter(this.tempRef.args, notIn(ignore))
                )

                this.tempRef[letter] = value
                return value
                break
            }
        }
    },

    odd(s) {
        let [odd, even] = coinflip()
            ? ['odd', 'even']
            : ['even', 'odd']
        if (!this.otherValue) this.otherValue = even
        this.tempRef.odd = true
        return odd
    },
    other(s) {
        let value = this.otherValue
        this.otherValue = null
        return value
    },

    lastNumber() {
        return getLast(this.numbers)
    },
    expr(s) {
        console.log('vvvvvvvvvvvvvvv expr')
        const [expr, answer] = nerdExpr(s)
        this.mtTempRef.expressionValues.push(answer)
        return expr
    },

    simp(s) {
        //console.log(s); throw '';
        const [expr, answer] = nerdExpr(s)
        this.mtTempRef.answer = answer
        return expr
    },
    percentChange(...args) {
        function runner(s, arg) {
            if (s) {
                return `${s} * ((100 + ${arg})/100)`
            }
            return `((100 + ${arg})/100)`
        }

        let s = ''
        for (let i = 0; i < args.length; i++) {
            s = runner(s, args[i])
        }
        if (args.length > 1) {
            //console.log(s); throw '';
            //console.log(args); throw '';
        }
        return s
    },
}

function isExpression(s) {
    return /\bx\b/.test(s)
}
function isArithmetic(s) {
    if (/^\d+ *[^+-\/*]/.test(s)) return true
    if (/[a-z]{3,} [a-z]/.test(s)) return 0
    return /^\d+ *[^+-\/*] *\d+/.test(s)
}
class Config {
    constructor(state, config) {
        if (getConstructorName(config).endsWith('Config')) {
            Object.assign(this, config)
        } else {
            this.getConfig(state, config)
        }
    }

    getConfig(state, config) {
        const name = getConstructorName(state)
        const ref = {
            Worksheet3: sampleStudentConfig,
            QuestionGenerator3: {
                level: 1,
                name: 'sally',
                parent: 'maria',
            },

            MathTemplater3: {
                level: 1,
                name: 'sally',
                parent: 'maria',
            },
        }
        Object.assign(this, ref[name], config)
    }
}

class StudentConfig extends Config {
    constructor(state, config) {
        super(state, config)
        this.level = 1
    }

    getConditions() {
        const level = this.level
        const conditions = {
            1: [noDecimals, isPositive, noFractions],

            1: [noDecimals, isPositive, noFractions],
        }
        return conditions[level]
    }
}
var MathTemplaterRegexes = {
    /* mtr */
    html: [
        /\$(\w+\(.*?\))/,
        'callable',
        /\$(\w{1,})\b/,
        'htmlWord',
    ],

    qaMath: [
        /\$(\w+\(.*?\)(?!\)))/,
        'qaCallable',
        /\$\[(.*?)\]/g,
        'qaBraces',
        /\${(.*?)}/,
        'qaBracket',
        /\$([abcdef])(?=[xyz ]|$)/,
        'qaVariable',
        /\$([a-zA-Z]{1,})\b/,
        'qaDollarWord',
        /((?:[+-] |\$)?\$\d+)/g,
        'qaNumber',
    ],

    infusionMath: [
        /([abcderxyz]{1,2})/,
        'infusionNumberGetter',
        /\$(\w+\(.*?\))/,
        'callable',
        /\${(.*?)}/,
        'bracket',
        /\$(-?[12345])\b/,
        'number',
        /\$(\w{1,})\b/,
        'dollarWord',
    ],

    default: [
        /*
         * f = fraction
         * m = money
         * r = randomNumber(noCache)
         * n = ???
         * s = ???
         * */

        /\$([abcdefsmnr]{1,2}[xy]?)\b/,
        'abcNumberGetter',
        /\$(\w+\(.*?\))/,
        'callable',
        /\${(.*?)}/,
        'bracket',
        /\$(-?[12345])\b/,
        'number',
        /\$(\w{1,})\b/,
        'dollarWord',
    ],

    prose: [
        /\$([abcdessmln]+)\b/,
        /\$(\w+\(.*?\))/,
        /\${(.*?)}/,
        /-not in use-\b([abcde])\b/,
        /\$([12345])\b/,
        /\$(\w{1,})\b/,
    ],
}

const MathTemplaterNumberRanges = {
    pow2: {
        1: [2, 4, 8, 16],
        2: [2, 4, 8, 16, 32, 64],
        3: [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048],
        4: [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048],
    },
    pow3: {
        1: [3, 9, 27],
        2: [3, 9, 27, 81, 729],
        3: [3, 9, 27, 81, 729],
    },
}
var UtilityMixins = {
    before(key, f, ...args) {
        this[key]()
        const value = f(...args)
        return value
    },

    after(key, f, ...args) {
        const value = f(...args)
        this[key]()
        return value
    },

    wrap(key, f, ...args) {
        //console.log(f, args)
        this.toggle(key)
        const value = f(...args)
        this.toggle(key)
        return value
    },

    toggle(key) {
        const newValue = opposite(this[key])
        this[key] = newValue
        return newValue
    },
    once(f) {
        if (this.tempRef.once) {
            return
        }
        this.tempRef.once = true
        f()
    },
}
function toStorage(store, f, mode) {
    if (isObject(store)) {
        store = Object.entries(store)
    }

    assert(store, isNestedArray)

    if (!f) {
        f = (k, v) => [k, v]
    }
    const storage = new Storage()
    store.forEach(([a, b]) => {
        storage.add(...f(a, b))
    })
    return mode == Object ? toJSON(storage) : storage
}
class WordNet {
    constructor(store) {
        if (!store) store = DefaultWordNet
        this.load(store)
    }
    load(store) {
        if (store) {
            assert(store, isObject)
            this.store = store
            let f = (k, v) => [v, k]
            this.storage = toStorage(this.store, f)
        }
    }
    has(key) {
        if (key.endsWith('s')) {
            key = backspace(key)
            this.plural = 1
        }
        let type = this.store[key]
        if (type) this.type = type
        return type
    }
    getSibling(key) {
        if (!this.type) {
            let go = this.has(key)
            if (!go) return []
        }
        const items = this.storage.get(this.type)
        const choices = items.filter((x) => x != key)
        const choice = randomPick(choices)
        const value = this.plural ? pluralize(choice) : choice
        this.type = null
        this.plural = null
        return value
    }
}

/* pizza represents food which can be circularly sliced */
const DefaultWordNet = {
    cake: 'pizza',
    donut: 'food',
    strawberry: 'food',
    apple: 'food',
    grape: 'food',
    tomato: 'food',
    pizza: 'pizza',
    '$fruit pie': 'pizza',
    'apple pie': 'pizza',
    'apple pie': 'pizza',
    'apple pie': 'pizza',
}
function wrapFunction(...args) {
    if (args.length == 3) {
        return _wrapStateFunction(...args)
    }
    if (args.length == 2) {
        return _wrapFunction(...args)
    }
    function _wrapFunction(f, g) {
        return (...args) => {
            const value = f(...args)
            const output = g(value)
            return isDefined(output) ? output : value
        }
    }

    function _wrapStateFunction(state, key, f) {
        let prev = state[key] && state[key].bind(state)
        if (!prev) return
        state[key] = (...args) => {
            const value = prev(...args)
            const output = f(value)
            return isDefined(output) ? output : value
        }
    }
}
class History {
    constructor(state) {
        this.store = []
        wrapFunction(state, 'getValue', (x) => {
            this.store.push(x)
        })
    }
    getValue() {
        return this.store
    }
}

function errorLogger(s) {
    return console.log(s)
    const value = s.replace(/\$\w+/, (x) => {
        x = x.slice(1)
        console.log({ x })
        return eval(x)
    })
    console.log({ errorLogger: value })
}
class QuestionGenerator3 {
    setOption(key, value) {
        this.config[key] = value
    }
    setAnswerRequirements(topic, level) {
        if (topic == null) {
            this.storage.transformCheckpoint =
                this.storage._transformCheckpoint

            this.storage.transformSeen =
                this.storage._transformSeen

            this.storage.checkpoint = this.storage_checkpoint

            return
        }
        //console.log(QGAnswerRequirements); throw '';

        const ref = QGAnswerRequirements[topic] || {}
        const options = ref.options || {}
        const requirements = ref[level]

        if (options.transformCheckpoint) {
            this.storage.transformCheckpoint =
                options.transformCheckpoint
        }

        if (options.transformSeen) {
            this.storage.transformSeen = options.transformSeen
        }

        this.storage.checkpoint = checkpointf(requirements)
    }
    reset(s) {
        this.mt.clear()
        this.cache.clear()
        this.storage.clear()
    }
    constructor(studentConfig) {
        this.studentConfig = studentConfig
        this.config = {
            multipleChoice: false,
        }

        //this.cache = new NumberCache()
        this.mt = new MathTemplater3(studentConfig, {
            regexKey: 'infusionMath',
        })

        this.storage = new UniqueStorage([isDefined], {
            transformSeen: (x) => x.question,
            transformCheckpoint: (x) => x.answer,
        })
        this.f = this.f.bind(this)
    }

    f(s) {
        let question = this.mt.run(s, { eval: 0, clear: 1 })
        let answer = nerdSolver(question)
        return this.config.multipleChoice
            ? {
                  question,
                  answer,
                  choices: generateMultipleChoice(
                      answer,
                      question
                  ),
              }
            : { question, answer }
    }

    generate(s) {
        if (isObject(s)) {
            s = this.getTemplate(s)
        }
        const value = this.storage.add(this.f, s)
        return value
    }

    set onSuccess(f) {
        this._onSuccess = f.bind(this)
    }
    get onSuccess() {
        return this._onSuccess
    }
}

class MathSingletonSolver {
    constructor({
        runner,
        requirements,
        checkpointOptions,
        postParse,
        preParse,
    } = {}) {
        this.checkpoint = checkpointf(
            requirements,
            checkpointOptions
        )
        this.postParse = postParse
        this.preParse = preParse
        this.runner = runner
    }
    run(s) {
        if (this.preParse) {
            s = this.preParse(s)
        }

        let value
        do {
            value = this.runner(s)
        } while (!this.checkpoint(value))

        return this.postParse
            ? this.postParse(value, s) || value
            : value
    }
}
class MathSolver3 {
    constructor(
        tests,
        {
            requirements,
            checkpointOptions,
            postParse,
            preParse,
            debug,
        } = {}
    ) {
        this.tests = isArray(tests[0])
            ? tests
            : partition(tests)
        this.checkpoint = checkpointf(
            requirements,
            checkpointOptions
        )
        this.postParse = postParse
        this.preParse = preParse
        this.debug = debug
    }

    run(item) {
        //console.log(item); throw '';
        for (let [test, f] of this.tests) {
            //console.log(test.name, 'test name')
            if (this.preParse) {
                item = this.preParse(item)
            }
            if (test(item)) {
                const breaker = BreakerFactory(20)

                if (this.debug || 0) {
                    display({
                        CALLER: getCaller(),
                        NAME: MathSolver3.getName(f),
                        RAW: deepString(item),
                    })
                }

                let value = f(item)

                while (!this.checkpoint(value)) {
                    value = f(item)
                    if (breaker(true)) return value
                }
                if (this.postParse) {
                    return this.postParse(value, item) || value
                }
                return value
            }
        }
        logError(item)
    }
    static getName(f) {
        let s = f.name
        return s == ''
            ? 'lambdaFunction'
            : s.replace(/bound */g, '')
    }
}

function recursiveToDictionary(a) {
    /* do it later */
    return toDictionary(a)
    let store = {}
    let ref = store
    function runner(x) {
        if (isArray(x)) {
            ref = ref[a]
            for (let [a, b] of x) {
                ref[a] = runner(b)
            }
        } else {
            ref[a] = b
        }
    }
}

function buildObjectFromString(s) {
    const arr = runner(s)
    return recursiveToDictionary(arr)

    function runner(s, depth = 0) {
        s = smartDedent(s)
        let r = /\n(?=\w)/
        let m = s.split(r)

        return m.map((item, i) => {
            let m = search(/^(\w+)\n+([^]+)/, item)
            if (!m) return item
            let [name, b] = m
            return [name, smallify(runner(b, depth + 1))]
        })
    }
}

/* as */
ANNOUNCEMENT_STRING = `

Worksheet4

    date
        Created on 08-11-2022
    descrip
        The next iteration of Worksheet3
    features
        Every number is being hand carved
        yup yup
        hand carving each number

active0812
    Uses Worksheet4
`
function announcement(s) {
    if (typeof ANNOUNCEMENT_OBJECT == 'undefined') {
        ANNOUNCEMENT_OBJECT = buildObjectFromString(
            ANNOUNCEMENT_STRING
        )
    }
    //console.string({ANNOUNCEMENT_OBJECT}); throw '';
    let caller = getCaller(-1)
    let MESSAGE = ANNOUNCEMENT_OBJECT[caller]
    console.log({ [caller + '_MESSAGE']: MESSAGE })
}
class Worksheet4 {
    /** ws4 **/
    get level() {
        return this.config.level
    }
    constructor() {
        announcement()
        this.watcher = new Watcher()

        this.mt = new MathTemplater3('qaMath')
        this.latexTree = new LatexTree({
            f: incrementf((i) => '$' + n2char(i)),
            operations: ['*', '+', '-'],
        })

        const numbergen = new Numbergen()
        this.numbergen = numbergen
        this.mt.numbergen = numbergen
        this.latexTree.numbergen = numbergen

        this.config = {
            level: 1,
            multipleChoice: false,
        }
    }

    filter(items) {
        const only = (x) => x.only
        const difficulty = (x) => {
            return (
                !x.hasOwnProperty('difficulty') ||
                x.difficulty <= this.config.level
            )
        }
        const skip = (x) => x.skip

        items = items.filter((x) => !x.skip)
        //console.log({items}); throw ""
        if (items.some(only)) {
            return items.filter(only)
        }

        if (items.some(difficulty)) {
            return items.filter(difficulty)
        }

        return items
    }
    runConfig(items, config) {
        const store = []
        for (let [k, v] of Object.entries(config)) {
            const item = items[Number(k) - 1]
            if (item.skip) continue
            for (let answer of toArray(v)) {
                store.push(this.runner(item, answer))
            }
        }
        return store
    }

    buildMainRunner(config) {
        let name = config.runner ? config.runner : 'runner'
        let runner = this[name].bind(this)
        runner = this.watcher.wrap(runner, 'question')
        return repeatUntilFactory({ runner, debug: true })
    }

    oldVersionForCog1Cog2() {
        /* this has merit.
         * it needs to be used later
         * some questions cannot be come from an answer
         *
         * */
        this.solveForNumbers = this.solveForNumbers.bind(this)
        this.selfSolver = this.selfSolver.bind(this)

        let self = this
        this.repeatUntil = repeatUntilFactory({
            endingArgs: self,
            onError(e) {
                const index = self.index
                const question = self.item.question
                console.log({ question, index })
            },
            limit: 50,
            debug: true,
        })
    }
    run(items, config = {}) {
        this.mainRunner = this.buildMainRunner(config)
        this.oldVersionForCog1Cog2()

        if (Object.keys(config).some((key) => isNumber(key))) {
            return this.runConfig(items, config)
        }
        const length = items.length
        const amounts = isArray(config.amounts)
            ? config.amounts
            : isNumber(config.amounts)
            ? map(length, () => config.amounts)
            : map(length, () => 1)

        const amount = sum(amounts)

        const answers = numberPattern({
            amount: amount,
            pattern: 'pyramid',
            ...config,
        })

        const next = nextf(answers)
        const store = []
        const storeRef = []

        for (let i = 0; i < length; i++) {
            let item = items[i]

            this.index = i
            this.item = item

            let value
            for (let j = 0; j < amounts[i]; j++) {
                value = this.mainRunner(item, next())
                store.push(value)
            }
            storeRef.push({ ...value, id: item.question })
        }
        this.storeRef = storeRef
        return store
    }

    solveForNumbers(question, answer) {
        let dollars
        ;[question, dollars] = mreplace(
            /\$(\w+)/g,
            (x) => x,
            question
        )
        if (/x/.test(question)) {
            question = question.replace(/x/g, answer)
        } else {
            question = answer + ' = ' + question
        }

        const store = {}
        const last = randomPick(dollars)

        const f = (x) => {
            if (x == last) return x
            const n = rng(this.numbergen.getRange())
            store[x] = n
            return n
        }

        let value
        if (exists(dollars)) {
            const r = reWrap(dollars, 'brg')
            value = preParseMath(question.replace(r, f))
        } else {
            value = question
        }

        const lastNumber = solveFor(value, last)
        //if (!isInteger(lastNumber)) return
        store[last] = lastNumber
        return store
    }

    selfSolver(question, a, answer, context) {
        if (a.includes('answer')) {
            a = a.replace('answer', answer)
        } else {
            a = answer + ' = ' + a
        }

        const dollarList = getDollars(question)
        const tally = getVariables(a, Tally)
        const [lowest, dollars] = tally.pop()
        const r = reWrap(dollars, 'rbg')

        a = a.replace(r, (s) => {
            return context.numbergen.generate(s, 'students')
        })
        let conditionMap = {
            students: isInteger,
        }
        let solution = solveFor(a, lowest, identity)
        let suffix = search(lowest + ' ' + '(\\w+)', question)
        if (
            suffix in conditionMap &&
            !conditionMap[suffix](solution)
        ) {
            //context.numbergen.clear()
            //return
        }

        let args = dollarList.reduce((acc, dollar) => {
            if (dollar == lowest) acc[dollar] = solution
            else if (dollar.length == 1) {
                acc[dollar] =
                    context.numbergen.cache.get(dollar)
            } else if (dollar in increaseDecreaseRef) {
                let i = dollarList.indexOf(dollar)
                let nextTwo = dollarList.slice(i + 1, i + 3)
                let nextTwoValues = nextTwo.map((x) => {
                    return context.numbergen.cache.get(x)
                })
                let dir = nerdCompare(...nextTwoValues)
                let value = increaseOrDecrease(dir, dollar)
                acc[dollar] = value
            }
            return acc
        }, {})
        context.numbergen.clear()
        return args
    }

    accumulateHashes(s) {
        this.hash = {}
        const ref = {
            moreOrLess: {
                display: ['more', 'less'],
                value: ['+', '-'],
            },

            inclusive: {
                display: ['inclusive', 'exclusive'],
                value: ['inclusive', 'exclusive'],
            },
            numberCondition: {
                display: ['odd', 'even', 'prime'],
                value: [isOdd, isEven, isPrime],
            },
        }
        s = s.replace(/#(\w+)/g, (_, key) => {
            const childRef = ref[key]
            const index = randomIndex(childRef.display)
            this.hash[key] = childRef.value[index]
            const display = childRef.display[index]
            return display
        })
        return s
    }
    cog3runner_1(item, answer) {
        let number = uniqueNumber(item.answer)
        let r = RegExp(boundary(number))
        let _answer = item.answer.replace(r, 'x')
        _answer = fixBackslashNumbers(_answer)
        //console.log({_answer}); throw ""

        let numbers
        ;[_answer, numbers] = transmuteNumbers(_answer)
        _answer += ' = ' + answer
        _answer = nerdSolver(_answer)

        let _question = item.question
        let question = _question.replace(/\b\d+\b/g, (x) => {
            if (x == number) {
                return isFraction(_answer)
                    ? parens(_answer)
                    : _answer
            }
            return numbers[x] || 23444444444444444
        })

        question = fixMultipleFractions(question)
        question = fixMath(question)
        return { question, answer }
    }
    cog3runner_2(item, answer) {
        let [question, numbers] = transmuteNumbers(
            item.question
        )

        let number = uniqueNumber(question)
        let r = RegExp(boundary(number))

        let _question = question
        question = item.question.replace(r, 'x')
        question += ' = ' + answer
        let _answer = latex.wrapFraction(
            nerdSolver(question),
            question
        )
        if (isNull(_answer)) {
            console.log('null answer')
            return
        }
        _question = _question.replace('x', _answer)
        _question = fixMultipleFractions(_question)
        _question = fixMath(_question)
        return { question: _question, answer }
        console.log({ question, numbers })
        throw ''
    }
    cog3runner_355(item, answer) {
        /* a major answer solver */
        let [question, numbers] = transmuteNumbers(
            item.question
        )

        let answer0 = fixMultiplication(item.answer)
        let answer1 = replaceNumbers(answer0, numbers)
        let answer11 = this.mt.runOnce(answer1)
        let number = uniqueNumber(onlyXSide(answer11))
        if (isNegative(number)) {
            //console.log('negger nancy')
            number = getNumbers(answer11)[0]
        }
        let r = RegExp(boundary(number))
        let answer2 = answer11.replace(r, 'yyy')
        let answer3 = answer2.replace('x', answer)
        //console.log({answer, answer2, answer3, question})
        let answer4 = nerdSolver(answer3)
        question = question.replace(r, latex.fractify(answer4))
        if (item.requireInteger && !isInteger(answer4)) return

        return { question, answer }
        //console.log('potential error with shingles because you may end up with something like 2 to 332 for 2 to 332 ... it is the exact same numbers. the error has been fixed by restricting to the same side of x')
    }

    cog3runner_354(item, answer) {
        let [question, numbers] = transmuteNumbers(
            item.question
        )
        let _answer = replaceNumbers(item.answer, numbers)
        _answer = nerdSolver(_answer)

        return {
            question,
            answer: _answer,
        }
    }

    cog3runner_3(item, answer) {
        let [question, numbers] = transmuteNumbers(
            item.question
        )
        let number = uniqueNumber(question)
        let orig = question
        let r = RegExp(boundary(number))
        question = question.replace(r, 'y')
        question = question.replace('x', answer)
        let _answer = nerdSolver(question)
        question = orig.replace('y', _answer)
        question = fixMath(question)
        return { question, answer }
    }
    cog3runner_4(item, answer) {
        let [question, numbers] = transmuteNumbers(
            item.question
        )
        let answerTemplate = replaceNumbers(
            item.answer,
            numbers
        )
        let _answer = eval(answerTemplate)
        //console.log({_answer}); throw ""
        //if (_answer != answer) {
        //return this.cog3runner_4(item, answer)
        //}
        // we have an error here
        return {
            question,
            answer,
        }
    }

    cogrunner_5(item, answer) {
        let type = getQuestionType(item)
        //let [question, numbers] =
    }
    cog3runner(item, answer) {
        return this._cog3runner(item, answer)
    }
    _cog3runner(item, answer) {
        if (item.answer) {
            if (item.answer.endsWith('Solver')) {
                return this.cogrunner_5(item, answer)
            } else if (hasCallable(item.answer)) {
                return this.cog3runner_4(item, answer)
            } else if (isXEquation(item.answer)) {
                if (hasMultipleVariables(item.answer)) {
                    return this.cog3runner_354(item, answer)
                } else {
                    return this.cog3runner_355(item, answer)
                }
            } else {
                //console.log('end')
                return this.cog3runner_1(item, answer)
            }
        } else if (isXEquation(item.question)) {
            return this.cog3runner_3(item, answer)
        } else {
            return this.cog3runner_2(item, answer)
        }
    }
    runner1(item, answer) {
        /* this is the old original solver */

        let _question = isString(item)
            ? item
            : item.precursor
            ? item.precursor.call(this)
            : item.question.length <= 3
            ? randomPick(item.question)
            : isArray(item.question)
            ? item.question[this.config.level - 1]
            : item.question

        _question = convertToLatex(_question)
        _question = nameChange(_question)
        _question = this.accumulateHashes(_question)

        let args = isString(item.answer)
            ? this.repeatUntil(
                  this.selfSolver,
                  _question,
                  item.answer,
                  answer
              )
            : item.answer
            ? this.repeatUntil(item.answer, answer)
            : this.repeatUntil(
                  this.solveForNumbers,
                  _question,
                  answer
              )

        //console.log(args)
        if (isPrimitive(args)) {
            args = [args]
        }

        this.args = args
        let question = isString(_question)
            ? this.mt.replace(_question, args)
            : _question.call(this, ...args)

        if (isMathematical2(question)) {
            question = fixMath(question)
            if (coinflip()) {
                question = reverse(question)
            }
        }

        if (question.includes('null')) {
            /* perhaps put this in mt.replace */
            return this.runner(item, answer)
        }

        return { question, answer }
    }
}
class Worksheet3 {
    inject(key) {}
    constructor(studentConfig, config = {}) {
        this.studentConfig = new StudentConfig(
            this,
            studentConfig
        )

        this.mt = new MathTemplater3(this.studentConfig, config)
        this.qg = new QuestionGenerator3(this.studentConfig)
        if (config.runner) {
            console.log(
                'Using MathSingletonSolver as worksheet.questionRunner. It was activated via config.runner in the new Worksheet constructor. As a result of this, we are not using the previous "buildQuestionSolver" or "buildQuesionRunner" methods. everything will need to go thru config.runner which is consumed by mathsinglletonsolver. This stuff is at WS4.'
            )
            throw 'see ws4'
        } else {
            this.setup()
            this.questionSolver = this.buildQuestionSolver()
            this.questionRunner = this.buildQuestionRunner()
            //this.explanationService = new ExplanationService()
        }
    }

    buildQuestionRunner() {
        const conditions = this.studentConfig.getConditions()
        const checkpointOptions = {
            fallback: yes,
            key: 'answer',
            transform: parseFloat,
            moreRequirements: [(x) => isDefined(x.answer)],
        }

        function createRef(value) {
            const ref = {
                lines: getSentences(value.question),
            }
            return ref
        }

        const postParse = (value, obj) => {
            if (!obj.explanation) return

            this.explanationService.ref = createRef(value)
            const explanation = this.explanationService.run(
                obj.explanation
            )
            if (!explanation) return
            return { ...value, explanation }
        }

        return new MathSolver3(this.questionRunnerTests, {
            conditions,
            checkpointOptions,
            postParse,
        })
    }
    buildQuestionSolver() {
        return new MathSolver3(this.questionSolverTests)
    }

    setup() {
        const options = {
            after(state, value, initialArg) {
                state.mt.clear()
                return value
            },
        }

        const testOptions = {
            ignore: ['explanation', 'type'],
        }

        const f = atBoth(
            curryEnd(keysAreFactory3, testOptions),
            thisf(this, options)
        )

        const g = atBoth(regextestf, thisf(this))

        const ftests = partition(questionRunnerTests)
        this.questionRunnerTests = ftests.map(f)

        const gtests = partition(questionSolverTests)
        this.questionSolverTests = gtests.map(g)
    }
    run(...args) {
        const f = thisf(this, 'questionRunner.run')
        const items = gatherAllArgs(args)
        return map(items, f)
    }
}
function atFirst(fn, ...args) {
    if (isArray(fn)) return [args[0](fn[0]), fn[1]]

    return (x) => {
        const b = fn(x[0], ...args)
        const value = isDefined(b) ? b : x[0]
        return [value, x[1]]
    }
}

function atSecond(fn, ...args) {
    if (isArray(fn)) return [fn[0], args[0](fn[1])]

    return (x) => {
        const b = fn(x[1], ...args)
        const value = isDefined(b) ? b : x[1]
        return [x[0], value]
    }
}
function curryStart(...kwargs) {
    const fn = kwargs.pop()
    return function curryStart(...args) {
        return fn(...kwargs, ...args)
    }
}

function getFactors(n) {
    return range(n).filter((x) => !(n % x))
}

function itemgetterf(items) {
    let zeroBasedIndexes = false
    let offset = zeroBasedIndexes ? 0 : 1
    items = toArray(items)

    return function lambda(...args) {
        if (args[0] === true) {
            return items
        }
        if (args[0] > items.length - 1) {
            console.log(items)
        }
        const value = args.map((arg) => {
            if (!isNumber(arg)) return arg
            if (arg < 0) {
                return items[items.length + arg]
            }
            return items[arg - offset]
        })
        //console.log(value)
        return value
    }
}
function map(x, f, ...args) {

    if (isNumber(x) && isPrimitive(f)) {
        return range(x).map((x) => f)
    }
    if (isString(f)) {
        let arg = f
        f = (x) => (isObject(x) ? x[arg] : simpleTemplater(arg, x))
    }

    if (isNumber(x)) {
        return range(x).map(partial(f, ...args))
    }
    if (isString(x)) {
        return [f(x)]
    }
    if (isIterable(x)) {
        return Array.from(x, f).filter(isDefined)
    }

    if (isObject(x)) {
        let lambda = f
        if (isFunction(f)) {
            if (!/^.*?\(.*?\,.*?\)/.test(f.toString())) {
                lambda = (k, v) => [k, f(v)]
            }
        } else if (isArray(f)) {
            lambda = (k, v) => (f.includes(k) ? [k, v] : null)
        }

        return reduceObject(x, lambda)
    }
}

function keysAreFactory3(args, { ignore = [] } = {}) {
    if (isFunction(args)) {
        return args
    }
    if (isObject(args)) {
        return function lambdaObject(x) {
            if (!isObject(x)) {
                return
            }
            let keys = Object.keys(x)

            for (let [k, v] of Object.entries(args)) {
                //console.log({k, v})
                if (!keys.includes(k)) return
                if (v == 1 || v == true) {
                    continue
                }

                if (ignore && ignore.includes(k)) continue
                if (isString(v)) {
                    if (x[k] != v) return
                } else if (!v(x[k])) return
                logObject('matched!', v.name || v.toString())
            }
            return true
        }
    }

    if (isArray(args)) {
        return function lambdaArray(x) {
            if (!isObject(x)) {
                return
            }
            const keys = Object.keys(x)
            return overlap(keys, args)
        }
    }
}

function overlap(a, b) {
    return a.every((arg) => b.includes(arg))
}
function logMessage(message, ...args) {
    let items = gatherArgs(args)
    let caller = getCaller(-1)
    let value = { message, caller, items }
    console.log(value)
}

function regextestf(s, mode) {
    const introducers = ['find', 'how many']
    const connectors = [
        'are in',
        'is (?:equivalent|equal) to',
        'equals',
        'is the same as',
        'the number of',
    ]
    const ref = {
        introducers,
        connectors,
    }

    const f = (_, a, b) => {
        switch (b) {
            case 'w':
            case 'd':
                return `(\\${b}+)`
        }
        return a.replace(/\w+/, (key) => {
            return reWrap(ref[key], String)
        })
    }

    const flags = 'i'
    const regex = s
        .replace(/\$(?:(\(.*?\))|([wd]))/g, f)
        .replace(/[.*\[]{2,}/g, '\\$&')

    if (mode == String) {
        return regex
    }
    const r = RegExp(regex, flags)
    //console.log(r) // 08-01-2022 debug

    return function lambdaTest(s) {
        return r.test(s)
    }
}

var questionSolverTests = [
    'remaining',
    'remainingSolver',
    'percentage of $w .*? $number.*?ratio of $w to $w',
    'percentageToRatioSolver',
    '^.*?ratio of $w to $w.*?$d *: *$d.*?percentage of $w',
    'ratioToPercentageSolver',
    'ratio',
    'ratiosolver',
    'every.*?\\. *how',
    'timeSolver',
    'find [xyz]\\.',
    'solver49',
    '^(.+?) $(?:connectors) $(?:introducers) $w',
    'convertNumberViaUnit',
    '^$(?:introducers) $w $(?:connectors) (.+)',
    'convertNumberViaUnitReversed',
    '.',
    'anySolver',
]
function convertNumberViaUnitReversed(a, b) {
    return convertNumberViaUnit(b, a)
}
/* prettier-ignore */
/*
 * the typed versions should take precedence over the others
 * */
const questionRunnerTests = [
    {type: 'questionFromAnswer'}, 'questionFromAnswerRunner',
    {answer: isCallable}, 'callableAnswerRunner',


    {answer: isFunction}, 'qafRunner',
    {generator: 1}, 'generatorRunner',
    ['question', 'children'], 'qacRunner',
    { question: notf(/\$/), answer: true, }, 'qaRunner',
    {answer: isDollarAnswer}, 'qadRunner',
    isStringDollarTemplate, 'dollarRunner',
    isString, 'stringRunner',
]

function notf(x) {
    if (isRegExp(x)) {
        return testf(x, -1)
    }
}

const MathSolverMixins = {
    /* it is called MathSolver but the
     * state context is from Worksheet3 */

    questionNumbersFromAnswerFunctionRunner(x) {
        console.log(x)
        throw ''
        let level = this.studentConfig.level

        let result = x.answer({
            answer: this.answer,
            level,
        })

        let numbers
        let answer

        if (isNumber(result)) {
            answer = result
            if (isFunction(x.numbers)) {
                numbers = x.numbers({
                    level,
                    answer,
                })
            }
        } else if (isArray(result)) {
            ;[answer, numbers] = result
        }

        const question = templater2(x.question, numbers)
        return { question, answer }
    },

    qafRunner(x) {
        const question = hasTemplateDollar(x.question)
            ? this.mt.run(x.question)
            : this.mt.replace(x.question, /(\d+)/g, rngAround)

        const numbers = this.mt.numbers
        //console.log(numbers); throw "";
        const answer = x.answer(numbers, this.mt.tempRef)
        return { question, answer }
    },
    callableAnswerRunner(x) {
        return mtShortcut(this.mt, x, 'callable')
    },
    qadRunner(x) {
        const f = (_, x) => this.mt.abcNumberGetter(x)
        const question = this.mt.run(x.question)
        console.log(question)
        throw ''
        let answer = this.mt.replace(
            x.answer,
            /(?:\b|\$)([abcde]\b)/g,
            f
        )
        answer = matheval(answer)
        return { question, answer }
    },

    generatorRunner(config) {
        const items = range(config.amount || 1).map(() => {
            return this.qg.generate(config)
        })
        return {
            type: 'generator',
            questions: items,
        }
    },

    numbergetter(x) {
        /* move it later */
        let numbergen = this.mt.numbergen

        if (x.numbers) {
            let amount = count(/\$\w\b/g, x.question)
            return numbergen.generate({
                range: x.numbers,
                amount,
            })
        }
        return 'bbbbbbbbbbbb'
    },
    /* currently we are in mathsolvermixins ... */
    questionFromAnswerRunner(x) {
        throw 'not in use'
        const numbers = this.numbergetter(x)
        console.log({ numbers, x })
        throw ''
        const [answer, argRef] = x.answer(numbers)
        const question = templaterMixedRef(x.question, argRef)
        return {
            question,
            answer,
        }
    },
    qacRunner(x) {
        /* somehow it needs to be preserved */
        /* so that we can get an essay type  */
        //console.log(x); throw '';
        return x.children.map((child) => {
            child = edit(
                child,
                'question',
                (y) => {
                    const value = this.mt.run(
                        x.question + ' ' + y
                    )
                    this.mt.clear()
                    return value
                },
                Object
            )

            return this.questionRunner.run(child)
        })
    },
    qaRunner(x) {
        const question = this.mt.replace(
            x.question,
            /(\d+)/g,
            rngAround
        )
        const numbers = this.mt.numbers
        const answer = isFunction(x.answer)
            ? x.answer(...numbers)
            : this.mt.run(x.answer, {
                  eval: true,
                  ref: numbers,
              })

        return {
            question,
            answer,
        }
    },
    dollarRunner(s) {
        const question = this.mt.run(s)
        //throw ''
        const answer = this.questionSolver.run(question)
        //console.log(answer); throw "";
        return { question, answer }
    },
}

/*  */
const WorksheetUtils = {
    numberf(x) {
        console.log('noooooooooot in use')
        console.log({ x })
        console.log(x)
        throw ''
        if (isArray(x)) {
            let range = x[level]
            console.log(range)
            throw ''
        }
        const level = this.studentConfig.level
    },
    //numbergetter(x) {
    //if (isObject(x)) {
    //return rngf(x)
    //}
    //}
}

function isCodeWord(s) {
    return /^[a-zA-Z][a-zA-Z\d]+$/.test(s)
}
//function deepString(x) {
//return walk(x, String)
//}
var deepString = curryEnd(walk, String)

function checkpointf(requirements, o = { fallback: yes }) {
    if (!requirements) {
        return isDefined
    }

    if (isFunction(requirements)) {
        return requirements
    }

    if (isTruthy(requirements)) {
        return isDefined
    }

    if (o.key) {
        return lambdaObjectCheckpoint
    }
    return lambdaCheckpoint
    /*  */

    function lambdaObjectCheckpoint(x, a) {
        return lambdaCheckpoint(x[o.key], a)
    }

    function lambdaCheckpoint(s, additionalRequirements) {
        if (o.transform) {
            s = o.transform(s)
        }
        for (let requirement of requirements) {
            if (!requirement(s)) {
                return false
            }
        }

        if (isArray(additionalRequirements)) {
            for (let requirement of additionalRequirements ||
                []) {
                if (!requirement(s)) {
                    return false
                }
            }
        }
        return true
    }
}
function isTruthy(x) {
    return x == 1 || x == true
}
var sampleStudentConfig = {
    preferences: {
        food: 'donuts',
        name: ['john', 'bob', 'lina'],
        sam: ['john', 'bob', 'lina'],
        friends: null,
    },
    level: 1,
}

function noDecimals(s) {
    return !/\.\d/.test(s.toString())
}

function isPositive(n) {
    return Number(n) >= 0
}

function noFractions(s) {
    return !/\w\/\w/.test(s)
}
function no() {
    return false
}

function logObject(a, b, ...args) {
    a = a.trim().replace(/ /g, '_')
    b = deepString(b)
    const p = { [a]: b }
    if (exists(args)) {
        p.args = smallify(args)
    }
    console.log(p)
    return p
}
function toPercentage(amount, total) {
    let value = (amount * 100) / total
    if (hasDecimal(value)) value = value.toFixed(2)
    return value + '%'
}

class NumberCache {
    constructor() {
        this.clear()
    }
    clear() {
        this.store = {}
        this.seen = new Set()
        this.numberRange = [1, 9]
    }
    rng() {
        return rng(...this.numberRange)
    }

    get(key, value) {
        if (this.store.hasOwnProperty(key)) {
            return this.store[key]
        }
        if (!isDefined(value)) value = this.rng

        let newValue
        let count = 0

        if (isFunction(value)) {
            do {
                newValue = value(key)
                if (count++ > 50) {
                    break
                }
            } while (this.seen.has(newValue))
        } else {
            newValue = value
        }

        this.seen.add(newValue)
        this.store[key] = newValue
        return newValue
    }
}
function atBoth(a, b, mode) {
    if (isObject(a)) {
        return (x) => {
            return reduce(a, (k, v, i) => {
                return [k, v(x[i])]
            })
        }
    }
    if (mode == Object) {
        return (k, v) => [a(k), b(v)]
    }
    return (x) => [a(x[0]), b(x[1])]
}
function BreakerFactory(n = 20, o = {}) {
    let count = 0
    let dontThrowCount = 0
    function breaker(item, ...args) {
        if (++count >= n) {
            if (item == true) {
                return '[breaker.true]'
            }
            if (item) {
                console.log(item, ...args)
            }
            if (o.dontThrow) {
                count = 0
                if (dontThrowCount++ > 3) {
                    return 404
                }
                return true
            }
            throw new Error()
        }
    }
    breaker.reset = breakerReset
    return breaker
    function breakerReset() {}
}
function exporter2(classObject, key) {
    return classObject[key].bind(classObject)
}

function ensureUniqueQuestion(o = {}) {
    let requirements = toArray(o.requirements)
    const storage = new UniqueStorage(requirements, {
        transformSeen: (x) => x.question,
    })
    return exporter2(storage, 'add')
}

class UniqueStorage {
    constructor(conditions, options = {}) {
        this.checkpoint = checkpointf(conditions)
        this.transformSeen = options.transformSeen || identity
        this.transformCheckpoint =
            options.transformCheckpoint || identity

        this._transformCheckpoint = this.transformCheckpoint
        this._transformSeen = this.transformSeen
        this._checkpoint = this.checkpoint
        this.clear()
    }

    clear() {
        this.store = []
    }

    add(fn, ...args) {
        let value
        let count = 0
        while (++count < 50) {
            value = fn(...args)
            let seenValue = this.transformSeen(value)

            if (this.store.includes(seenValue)) {
                continue
            }

            let checkpointValue =
                this.transformCheckpoint(value)

            if (!isDefined(checkpointValue)) {
                continue
            }

            if (!this.checkpoint(checkpointValue)) {
                continue
            }

            this.store.push(seenValue)
            return value
        }
        logError({ fn, args, count })
        return null
    }
}

function stringToObject(x, key) {
    if (isString(x)) {
        return { [key]: x }
    }
    return x
}

const QuestionGeneratorTemplates = {
    multiplication: ['a * b', 'a * x'],

    tens: [
        'a * 10^b * 10^x',
        'a * 10^c * b * 10^d =',
        '2 * 10^3 * 5 * 10^4 =',
        '2 * 10^3 * 5 * 10^4 = 2^x',
    ],
    fractions: [
        //'1/(a/b)',
        //'((b/a) / (a/b))',
        '((4)/(b/a))/(a/b)',
        //'1 / ((a/b) - b)',
        'a/b - b/${2b} - b/${3b}',
        'a/b - a/c',
        'a/b - a',
        'a/b - b',
    ],
    roots: [
        // some connection ... to the other side of exponents.
        // when the child reflects poorly ...
        // kids have to be super careful ...
        // to trust me ...
    ],

    exponents: {
        //'a/b - x - b*c',
        //'ax - bc',
        //'2x - 3',
        //'ax - 3',
        1: [
            '2^a * 2^b = 2^x',
            '2^a * 2^b * 2^c = 2^x',
            '4^a * 2^x = 2^{x + x}',
            '2^a * 2^x = $pow2^{b + x}',
            '2^a * 2^{-b}',
        ],
        2: [
            'a^a * a^${2a} = a^(3x)',
            'a^b * a^(c+2) = a^x',
            'a^(-x) = a^(b+x+c)',
        ],
        3: [
            '$pow2^a * $pow2^x',
            '$pow3^a / $pow3^x',
            '$pow3^a * $pow3^x',
            '($pow3^a * (1/$pow3^c)) / ($pow3^b / $pow3^x)',
        ],
    },

    mixed: [
        'a ÷ b',
        'a + b',
        'a - b',
        'a * b',
        'a + b * c',
        'a + b - c',
        'a + b + c',
        'a * b * c',
        'a - b + a * a + d',
        '(a + b * c) - d * e + c',
        'a/b + c/d',
        'a/b - c/d',
        'a/a + a/b',
        'a/b * c',
        'a * b/c',
        'a + b * c + d',
        '(a + b) * (c + d)',
        '(a - b) * (c + d)',
        '(a + b) * (c - d)',
        '(a + b) * (c + d)',
        'a * (b - c * d)',
        'a + (b + c * d)',
        'a/b - c/d + a/d',
    ],
    arithmetic: [
        'a + b',
        'a - b',
        'a * b',
        'ab + c',
        'ab - c',
        'ab + cd',
        'ab - cd',
        'ab * b',
        //'2 + 3^2 * 6 - 4'
        /* the absolute value can be added from anywhere */
    ],
    absoluteValue: [
        '|a + b|',
        '|a - b|',
        '|ab - c|',
        '|ax - b| = r',
        '|ax - bx| = r',
        //'|ax - b| + |cx + d| = r',
        //'|ax - b| - |cx + d| = r',
    ],

    fractions: ['a + b - c/d'],
    equations: [
        'x - a = b',
        //'x + a = b',
        'ax - b = c',
        'ax + b = c',
        //'(2x - 3)/4 = 5',
        //'(2x - 3)/4 = 5x - 3',
        //'(2x - 3)/4 = 3',
    ],
}

function templatef(template) {
    return function lambda(x, i) {
        let ref = [null, x, i]
        return template.replace(/\$([12])\b/g, (_, y) => {
            return ref[Number(y)]
        })
    }
}

class PageStorage extends Storage {
    constructor() {
        super()
        this.count = 0
    }
    add(item) {
        super.add(this.count, item)
    }
}

function partitionSplit(items, f) {
    const storage = new PageStorage()
    let enter
    let last
    for (let item of items) {
        enter = f(item)
        if (enter == last) {
            storage.add(item)
        } else {
            storage.count++
            storage.add(item)
        }
        last = enter
    }
}

function isXEquation(s) {
    return /[x=\\]/.test(s)
}
function hasFactorial(s) {
    return /!\w/.test(s)
}
function fixFactorial(s) {
    if (hasFactorial(s)) {
        s = s.replace(/!(?=\w)/, '! *')
    }
    return s
}
function dunno() {
    if (!test(/\b[=?s-z]\b/, s)) {
        s = s.replace(/c(?=frac)/g, '')
        s = nerdamer.convertFromLaTeX(s)
        return decimalToFraction(nerdEval(s), 'force')
    }
}
function noNerdamer() {
    if (typeof nerdamer == 'undefined') {
        console.log('NERDAMER UNDEFINED')
        return 1
    }
}

function nerdSolver(s) {
    /* active */

    if (noNerdamer()) return 1

    const template = fixEquationForNerdamerSolver(s)
    const answer = getAnswer(template)
    const after = postParse(answer)
    return after

    function postParse(s) {
        return toNumber(s)
    }

    function getAnswer(s) {
        if (s.includes('$input')) {
            return solveFor(s, '$input')
        } else if (/[<>]/.test(s)) {
            return nerdSolveInequality(s)
        } else if (isEquation(s)) {
            return nerdSolveEquation(s)
        } else {
            return nerdEval(s)
        }
    }
}

function nerdSolveEquation(s) {
    //if (!hasLatex(s)) s = s.replace(/[{}]/g, '') /* what does this do ... */

    function runner(s) {
        let solution = solveForVariable(s)
        if (hasValue(solution)) {
            return solution
        }

        let variable = search(/yyy|[xyz]/i, s)
        assert(variable, s)
        let solution1 = nerdamer(s).solveFor(variable)
        let solution2 = nerdEval(solution1)
        return orderByPolynomialDegree(solution2)
    }

    const answer = runner(s)
    if (answer == 0) {
        if (!checkEquationAnswer(s, answer)) {
            return null
        }
    }
    if (test(/0\.\d+ *\*/, answer)) {
        console.log(answer)
        throw ''
        return answer.replace(/0\.(\d+) *\*/g, (x, y) => {
            return toLatexFraction(...simplifyRatio(y, 100))
        })
    }
    return answer
}
class NerdamerValueError extends Error {
    constructor(...args) {
        super(...args)
    }
}
function nerdEval(s, mode) {
    if (typeof nerdamer == 'undefined') {
        try {
            return eval(s)
        }
        catch {
            return -111
        }
    }

    try {
        const nerd = nerdConvert(s)
        const text = mode ? nerd.text(mode) : nerd.text()
        if (mode) return text
        if (isLongDecimal(text)) {
            const value = nerd.evaluate().toString()
            //console.log('a looooooooooong decimal', text, value)
            return value
            throw new NerdamerValueError(nerd)
        } else {
            return nerd.text()
        }
    } catch (e) {
        console.log({ s: s.toString(), e: e.stack })
        throw ''
    }
}

function fixExponentNegatives(s) {
    return s.replace(/^-\w+(?=\^)/, (x) => parens(x))
}

//

function hasProse(s) {
    const regex = /[a-zA-Z\']+ \w+ [a-zA-Z\']+/
    return regex.test(s)
}
function dictgetter(ref, ...a) {
    ////console.log(dictgetter({a:{b: 123}, b:2, c:3}, 'a', 'b'))
    // 4 comments means it is for runDemo
    const g = (a) => {
        /* eval version */
        /* for teaching */
        /* dont use it */
        let s =
            'ref' +
            range(a.length)
                .map((_, i) => {
                    return `[a[${i}]]`
                })
                .join('')
        return eval(s)
    }

    //console.log(getCaller(-1))
    const f = (a) => {
        //console.log(a)
        switch (a.length) {
            case 1:
                return ref[a[0]]
            case 2:
                return ref[a[0]][a[1]]
            case 3:
                return ref[a[0]][a[1]][a[2]]
            case 4:
                return ref[a[0]][a[1]][a[2]][a[3]]
            case 5:
                return ref[a[0]][a[1]][a[2]][a[3]][a[4]]
        }
    }

    const value = f(a)
    return value
}
function getVariables(s, mode) {
    const regex = /(?:\b|\d)([abcdenxyzsir])\b/g
    if (mode == Tally) {
        return new Tally(match(regex, s))
    }

    if (mode == Object) {
        return tally(match(regex, s))
    }
    return unique(match(regex, s))
}
function isCleanNerdamerAnswer(s) {
    let regexes = [/\w{5,}\/\w{5,}/]
    return regexes.every((r) => !r.test(s))
}

function templateFromQuestion(s) {
    /* todo later
     * 2^4/2^6 = ? ... each number is kind of like an identifier.
     * */
    return s
}
function linegetterold(x, regex = /\n/) {
    return isArray(x) ? x : x.trim().split(regex)
}
function linegetter(x) {
    if (arguments.length == 2) {
        return x.split('\n')
    }
    return isArray(x) ? x : split(smartDedent(x), /\n+/)
}
function hasArithmetic(s) {
    /* inferior to hasOperator */
    return /[+*]/.test(s)
}
function chunkgetter(s) {
    return s.trim().split(/\n\n+/)
}

function endsWith(r, s) {
    let regex = RegExp(reWrap(r) + ' *$')
    return test(regex, s)
}
function removeEndingEquals(s) {
    return s.replace(/ *= *\?? *$/, '')
}
function atMiddle(middle) {
    return function lambda(s) {
        return s[0] + middle + s[1]
    }
}

function hasOperator(s) {
    return /[^*+-=]/.test(s)
}

function fixMultiplication(s) {
    const r = /\d[a-z]|[a-z]\d|\)[(a-z)]/g
    //console.log('hi'); throw '';
    return s.replace(r, middleMultiplicationSign)

    if (/\d[a-z]|[a-z]\d/.test(s)) {
        s = s.replace(/\d[a-z]|[a-z]\d/g, f)
    }
    if (/\)[(a-z]/.test(s)) {
        s = s.replace(/\)[(a-z]/g, f)
    }
    return s
}

//s = removeEndingEquals('2 + 2 = ')    /* 2 + 2 =  => 2 + 2 */
//console.log(s); throw '';
s = `
nerdSolver

//1 + 1
//1 + 1 =
//2x = 4
//3x = 100
//a + a + a + 3a
//2^6/2^x = 2
//2^6 * 2^6 * 2^6 = 2^x
//2^(x + 1) * 2^x = 2^(x + 5)
//2^4 * 2^x = 2^(3 - x)
2^4 * 2^x = 2^7 * 2^x 
//2^x = 2^(2 + 2)
//2x + 3 = 3
//2^4 * 2^x = 2^(7 + x)


`

function checkEquationAnswer(s, answer) {
    function runner(s) {
        return nerdsub(s, { x: answer }).toString()
    }
    let [a, b] = s.split(/ *= */)
    return runner(a) == runner(b)
}

function aggBuildQuestionsFromString0802() {
    /* no */
}
function calculateGradeFromAge() {}
function hasTemplateDollar(s) {
    return /\$\w(?!\.\d)/.test(s)
}
function calculateAgeFromGrade() {}
const students = [
    {
        name: 'nihan lobo',
        gender: 'female',
        type: 'tutoring',
        subject: 'SHSAT-MATH',
        grade: 9,
        startDate: '07/11/2022',
        endDate: 'sdfsdfsdfsdf',
        class: null,
    },
    { name: 'michelle', class: 'g5math', grade: 5 },
    { name: 'alvin', class: 'g5math', grade: 5 },
    { name: 'hao xiang', class: 'g5math', grade: 5 },
    { name: 'aaron', class: 'g7math', grade: 7 },
    { name: 'kaylee', class: 'g7math', grade: 7 },
    { name: 'kloe', class: 'g7math', grade: 7 },
    { name: 'lynn', class: 'g7math', grade: 7 },
]
//toc a1.html, a.js examples of slot

function repeatUntil(runner, checkpoint, ...args) {
    let count = 0
    let value
    while (count++ < 100) {
        value = runner(...args)
        if (checkpoint(value)) {
            return value
        }
    }
    throw 'repeat ntil'
}

s = `
translation
hey guys... how is dr. steve are you? doing okay. u?
`
//runClass(ExplanationService, s)

/* translation should convey a class to the table */
//foo()

//this context
//const ref = {
//a() {
//console.log(this.b)
//},
//b: 1,
//}

function wrngf(o) {
    var i,
        j,
        table = []
    for (i in o) {
        for (j = 0; j < o[i] * 10; j++) {
            table.push(i)
        }
    }
    return function lambda() {
        return table[Math.floor(Math.random() * table.length)]
    }
}

function rngf(a, b) {
    if (!a) return partial(rng)
    if (isObject(a)) {
        var i,
            j,
            table = []
        for (i in a) {
            for (j = 0; j < a[i] * 10; j++) {
                table.push(i)
            }
        }
        return function lambdaWrng() {
            return table[
                Math.floor(Math.random() * table.length)
            ]
        }
    }
    if (isNestedArray(a)) {
        return function lambdaArrayRNG() {
            return a.map((x) => rng(...x))
        }
    }
    if (isArray(a)) {
        b = a[1]
        a = a[0]
    }
    return function lambdaRng(c, d) {
        return rng(c || a, d || b)
    }
}
function pow10(n) {
    return Math.pow(10, n)
}

function getNDigitNumber(n) {
    switch (n) {
        case 1:
            return range(9)
        default:
            return range(log10(n), pow10(n) - 1)
    }
}
function splitNumber(x) {
    return x.toString().split('').map(Number)
}
function getDigitSum(n) {
    return sum(splitNumber(n))
}
function mixinsForWS3() {
    //classMixin(ExplanationService, ExplanationServiceParsers)
    classMixin(Worksheet3, MathSolverMixins, WorksheetUtils)
    classMixin(
        MathTemplater3,
        MathTemplaterMixins,
        UtilityMixins,
        mathTemplaterHelperFunctions
    )
    classMixin(Numbergen, UtilityMixins)
}
function isVariable(s) {
    return /\b[xyz]\b/i.test(s)
}

function isInteger(n) {
    return Number.isInteger(Number(n))
}
function clear(o) {
    o.clear ? o.clear() : o.reset()
}

const NumberRanges = {
    /** nr **/
    '-99': {
        1: [-9, 9],
        2: [2, 20],
        3: [2, 50],
    },

    students: {
        1: [40, 50, 60, 80, 100, 120],
        2: [2, 20],
        3: [2, 50],
    },

    addition: {
        1: [5, 20],
        2: [2, 20],
        3: [2, 50],
    },

    population: {
        1: [10, 100],
        2: [2, 20],
        3: [2, 50],
    },

    min2: {
        1: [2, 10],
        2: [2, 20],
        3: [2, 50],
    },

    all: {
        1: [-10, 10],
        2: [1, 20],
        3: [1, 50],
    },

    listSize: {
        1: [3, 7],
        2: [1, 20],
        3: [1, 50],
    },

    any: {
        0: [1, 5],
        1: [1, 10],
        2: [1, 20],
        3: [1, 50],
    },

    default: {
        0: [1, 5],
        1: [1, 10],
        2: [1, 20],
        3: [1, 50],
    },
    percents: {
        1: [10, 20, 30, 40, 50, 60, 70, 80],
    },
}
class Numbergen {
    constructor(config) {
        this.config = config || { level: 1 }
        this.storage = new UniqueStorage()
        this.cache = new Cache()
        this.random = () => this.create(1)
    }

    getRange(key) {
        return NumberRanges[key || 'default'][this.config.level]
    }

    create(amount, key = 'default') {
        const range = this.getRange(key)
        if (key == 'any') {
            return smallify(map(amount, () => rng(range)))
        }
        return fillUp(amount, rng, range)
    }

    generate(x, key) {
        let range
        if (isArray(key)) {
            range = key
        }

        let f = (range) => {
            return this.storage.add(() => {
                return rng(range)
            })
        }

        if (isObject(x)) {
            console.log(x)
            throw 'fix this'
            return fillUp(x.amount, f, this.getRange(x))
        }

        if (isNumber(x)) {
            return fillUp(x, f, range)
        }

        if (isString(x)) {
            return this.cache.get(x, () =>
                rng(this.getRange(key))
            )
        }
    }

    clear() {
        clear(this.storage)
        clear(this.cache)
    }
}

function rngAround(n) {
    function numberRunner(n) {
        n = Number(n)
        if (n == 0) return 0
        if (n < 5) return rng(2, 5)
        if (n < 10) return rng(7, 13)
        if (n < 20) return rng(15, 30)
        if (n < 100) return rng(n - 10, n + 10)
        return rng(n - 100, n + 100)
    }

    function decimalRunner(n) {
        return n
            .split('.')
            .map(Number)
            .map(numberRunner)
            .join('.')
    }

    function fractionRunner(n) {
        let count = 0
        let numbers = parseArithmetic(n)
        let bigger = numbers[0] > numbers[1]
        let store = []
        if (bigger) {
            store.push(numbers[0] + rng(1, 5))
            store.push(Math.max(1, numbers[1] - rng(1, 5)))
            if (allEqual(store)) store[0] = store[0] + rng(1, 3)
        } else {
            store.push(Math.max(1, numbers[0] - rng(1, 5)))
            store.push(numbers[1] + rng(1, 5))
            if (allEqual(store)) store[1] = store[1] + rng(1, 3)
        }
        return toFraction(
            n.replace(/\d+/g, (x) => store[count++])
        )
    }

    const runner = fractionDecimalNumberFactory(
        fractionRunner,
        decimalRunner,
        numberRunner
    )
    return runner(n)
}
function fractionDecimalNumberFactory(a, b, c) {
    return function lambda(s) {
        if (isFraction(s)) {
            return a(s)
        }

        if (hasDecimal(s)) {
            return b(s)
        }
        return c(s)
    }
}
function changeAnswer(n, i, index) {
    function changeNumber(n) {
        let number = parseInt(n)
        let increment

        if (number < 10 || isPrime(number)) {
            increment = 1
        } else {
            for (let i of [
                1000, 100, 10, 9, 8, 7, 6, 5, 4, 3,
            ]) {
                if (number % i == 0) {
                    if (number - index * i <= 0) {
                        increment = Math.floor(i / 2)
                        if (number - index * increment <= 0) {
                            increment = Math.floor(i / 4)
                        }
                    } else {
                        increment = i
                    }
                    break
                }
            }
        }
        return number + (i - index) * increment
    }
    function changeDecimal(n) {
        if (/^0\./.test(n)) {
            return fixFloatingPoint(n * Math.pow(10, i - index))
        }
        let [front, decimal] = search(/(\d+)\.(\d+)/, String(n))
        let base = Math.pow(10, decimal.length - 1)
        let number = rng(base - 1, 1 + base * 10)
        return rngAround(front) + '.' + number
    }
    function changeFraction(n) {
        let [a, b] = parseArithmetic(n)
        if (a == 1) {
            return toFraction(a + i, b + i)
        }
        a += rng(1, rngAround(a))
        b += rng(1, rngAround(b))
        return toFraction(a, b)
    }

    if (isFraction(n)) {
        return changeFraction(n)
    }

    if (hasDecimal(n)) {
        return changeDecimal(n)
    }
    return changeNumber(n)
}

function generateMultipleChoice(
    answer,
    {
        question = 0,
        length = 4,
        letter = null,
        conditions = [],
    } = {}
) {
    let ref = letter ? char2n(letter) : rng(1, 20)
    if (ref == 24) ref -= 1
    if (ref == 25) ref -= 2
    let answerIndex = ref % length
    let increment
    let count = 0
    let condition = numberf(conditions)
    let storage = new UniqueStorage(condition)

    let runner = (i) => {
        return i == answerIndex
            ? answer
            : modifyNumber(answer, changeAnswer, i, answerIndex)
    }

    for (let i = 0; i < length; i++) {
        storage.add(runner, i)
    }

    let choices = toJSON(storage)
    if (question) {
        choices = addWordsToChoices(choices, question)
    }
    return {
        choices: choices,
        answerIndex,
    }

    function addWordsToChoices(choices, question) {
        let r = /miles$/
        let m = search(r, question)
        if (m) {
            return choices.map((choice) => {
                return f(choice, m)
            })
        }
        return choices

        function f(choice, m) {
            return joinString(choice, m)
        }
    }
}

function modifyNumber(s, fn, ...args) {
    let allNumbersRE = /-?\d+(?:\.\d+)?(?:\/\d+(?:\.\d+)?)?/g
    let changeSuffix = false
    s = s.toString()
    s = s.replace(allNumbersRE, (oldNumber) => {
        //console.log(fn, oldNumber); throw '';
        if (!isFunction(fn)) {
            return fn
        }
        let newNumber = fn(toNumber(oldNumber), ...args)
        if (newNumber == 1) changeSuffix = true
        return newNumber
    })
    if (changeSuffix) {
        s = s.replace(/\w+?s/, (x) => x.slice(0, -1))
    }
    if (test(/^1[a-z]$/, s)) {
        return s.slice(1)
    }
    return s
}
//console.log(generateMultipleChoice('3.23'))
function isFraction(s) {
    if (isString(s)) {
        return /\/|\\[dc]?frac/.test(s)
    }
}
function onlyPositive(x) {
    return parseInt(x) > 0
}
function templaterMixedRef(s, ref) {
    let regex = /\$(\w+)/g

    let arrayRef = null
    let mapRef = []
    let otherRef = []

    for (let [k, v] of Object.entries(ref)) {
        if (isPlural(k)) {
            arrayRef = v
        } else {
            otherRef.push(v)
        }
    }

    let count = 0
    const f = (_, key, ...args) => {
        if (isNumber(key)) {
            return getArrayItem(arrayRef, key)
        }
        const value = getArrayItem(otherRef, ++count)
        return value
    }
    return s.replace(regex, f)
}

function mtShortcut(mt, x, type) {
    const question = hasTemplateDollar(x.question)
        ? mt.run(x.question)
        : mt.replace(x.question, /(\d+)/g, rngAround)

    const numbers = mt.numbers

    if (!type) return [question, numbers]
    let answer

    switch (type) {
        case 'callable':
            let f = bringToLife(x.answer)
            answer = f(...numbers)
            break

        case 'callable':
            answer = bringToLife(x.answer)(numbers)
            break

        case 'callable':
            answer = bringToLife(x.answer)(numbers)
            break
    }

    return { question, answer }
}
function getArrayItem(a, key, offset = 1) {
    return a[Number(key) - offset]
}
function randomIndex(numbers) {
    return rng(0, numbers.length - 1)
}

function joinString(...args) {
    return filter(gatherArgs(args)).join(' ')
}

function generateArithmetic(config) {
    const numberConfig = map(config, ['between'])

    const expressionConfig = map(config, ['between'])
    const calculator = exporter(Calculation)
    const f = partial(buildTree(terms, expressionConfig))
    const g = (expr) => [expr, calculator(expr)]
    const exprs = iter(amount, compose(g, f)).filter(
        filterf(numberf(numberConfig), { at: 2 })
    )

    storage = new Storage()
    for (let [a, b] of exprs) {
        storage.add(b, a)
    }
    console.log(storage.value)
    //ofile('calculations.json', storage.value)
}
//console.log(generateArithmetic())

//console.log(map({a:1, b:1}, ['a']))

//console.log(buildTree(3, {string: 1}))
//

function todo0803() {
    s = `

    1 2 3
    4 5 6
    7 8 9
    `
    //The groupings would be: [2, 3, 6], [1, 5, 9], [4, 7, 8]
    items = partition(range(9), 3)
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        let splitIndex = i + 1
        console.log(splitArray(item, splitIndex))
        items.length
    }
    //console.log(s)
}

function asciiLetterCoordinates(key) {
    let s = asciiLetters[char2n(key.toLowerCase())]
    s = s.replace(/^ *\n*/, '')
    s = s.replace(/\n* *$/, '')
    s = s.replace(/^ /gm, '')
    s = s.replace(/ $/gm, '')

    const store = []
    const lines = linegetter(s, null).map((s) => s.split(''))

    lines.forEach((row, y) => {
        row.forEach((item, x) => {
            if (exists(item)) {
                store.push([x, y])
            }
        })
    })
    return {
        height: lines.length,
        width: lines[0].length,
        coordinates: store,
        lines: lines,
    }
}
async function previewItems(items, f) {
    for (let item of items) {
        const value = f(item)
        if (value) console.log(value)
        await sleep(1000)
        console.clear()
    }
}
//previewItems(alphabet, asciiLetter)

function fillMatrix(matrix, items) {
    if (isArray(items[0])) {
        items = map(items, (x) => ['#', x])
    }

    for (let [value, pos] of items) {
        let [x, y] = pos
        value = String(value)
        for (let i = 0; i < value.length; i++) {
            matrix.set(x + i, y, value[i])
        }
    }
    return matrix
}
function iterateMatrix(matrix, callback) {
    let x = 0
    let y = 0
    for (let i = 0; i < matrix.width * matrix.height; i++) {
        callback(matrix, x, y)
        x += 1
        if (x == matrix.width) {
            x = 0
            y += 1
        }
    }
}
function simulateAscii(items, width = 30, height = 10) {
    if (isObject(items)) {
        width = items.width
        height = items.height
        items = items.coordinates || item.store
    }
    const matrix = new Matrix(width, height)
    fillMatrix(matrix, items)
    iterateMatrix(matrix, (matrix, x, y) => {
        const value = matrix.get(x, y)
        if (!value) matrix.set(x, y, ' ')
    })

    let s = ''
    for (let i = 0; i < matrix.height; i++) {
        const row = matrix.getRow(i)
        s += row.join('') + '\n'
    }
    return box(s, width, height)
}
function box(s, width, height, padding = 2) {
    let line = '_'.repeat(width + padding * 2 + 2) + '\n'
    let totalWidth = line.length - 1
    let middle = linegetter(s, null).map((x) => {
        let value =
            '|' + ' '.repeat(padding) + x + ' '.repeat(padding)
        value += ' '.repeat(totalWidth - value.length - 1) + '|'
        return value
    })

    let empty = '|' + ' '.repeat(width + padding * 2) + '|\n'
    let top = empty.repeat(parseInt(padding / 2))
    const p = line + top + middle.join('\n') + '\n' + top + line
    console.log(p)
    return p
}
//foo()
//simulateAscii()

function mapTable(table, f) {
    return table.map((line) => line.map(f))
}

function mathLetter(letter) {
    const { lines } = asciiLetterCoordinates(letter)
    const data = mapTable(lines, mapConditional(exists, f, g))
    console.log(data)
    return data
}

//MondayMathLetter
//$monday's math letter

colorPairs = [
    ['yellow', 'green'],
    ['yellow', 'green'],
    ['yellow', 'green'],
]
//isEven,
//isOdd,
//multipleOfThree,
//isOddAndMultipleOfThree,
//multipleOfFour,
//can combine it together into a story.

function mondayMathLetterData() {
    let instructions = `

        Find $monday's math letter by coloring in each of the answer boxes. 
            If the answer is $cond1, color the box $color1. 
            If the answer is $cond2, color the box $color2. 
        Once you have colored in all of the answer boxes, the final letter will appear!`

    ref = {
        monday: 'tuesday',
        cond1: 'foo',
        cond2: 'boo',
        color1: 'green',
        color2: 'red',
    }

    instructions = templater2(instructions, ref)
    const p = AlanParser(s)
    consoleThrow(p)
    return p
}
//console.log(mondayMathLetterData())

function consoleThrow(...args) {
    console.log(...args)
}

//console.log(mondayMathLetterData())
//console.log(AlanParser(s))

function loadConsoleString() {
    if (!console.hasOwnProperty('string')) {
        console.string = compose(
            wrapf(console.log, exists),
            stringify
        )
    }
}
function wrapf(fn, wrapperFn) {
    return function lambda(...args) {
        let before = wrapperFn(...args)
        if (isTruthy(before)) {
            return fn(...args)
        }
    }
}

const _AlanParsers = {
    parseItem(s) {
        let value = this.childSolver.run(s)
        return value
    },
    parseGroup(name, children) {
        let props = null

        let A = this.parentSolver.run(name)
        if (isObject(A)) {
            if (A.name) name = a.name
            if (A.props) props = a.props
            if (A.children) {
                /* mutative */
                children.push(...A.children)
            }
        }
        /*  */
        let B = this.parentSolver.run(children)
        if (isObject(B)) {
            if (B.props) {
                if (props) {
                    Object.assign(props, B.props)
                } else {
                    props = B.props
                }
            }
            if (B.children) {
                children = B.children
            }
        }
        return { name, children, props }
    },
    parentSentence(s) {
        /* thi */
        return s
    },
    word(s) {
        return s + 'fff'
    },
    yes(s) {
        return s
    },
    childHasDollar(s) {
        console.log('ggggggggggggg')
        console.log(s)
        throw ''

        return this.mt.split(s)
    },
    childYes(s) {
        return saybye(s)
        /* this works.
        //return {s}
    },
    childrenYes(s) {
        /* it is a mapping function. 
         * ... 
         * */
    },
}
class AlanParser {
    setup() {
        classMixin(this, _AlanParsers)

        const ref = {
            parent: [isWord, isSentence, yes],
            child: [hasDollar, yes],
        }

        /* builds mathSolvers based on the ref... */
        assignMathSolver(this, ref)
    }
    constructor(options = {}) {
        this.depth = 0
        this.setup()
        this.mt = new MathTemplater3(null, {
            regexKey: 'html',
            baseDollarRef: options.baseDollarRef,
            dollarRef: options.dollarRef,
        })
        /* At AlanParser */
    }

    run(s) {
        const result = this.runner(s)
        //console.string(result); throw "";
        const output = divify('div', 'root', result)
        return output
    }
    runnerFlatHtml(s) {
        const value = linegetter(s).map((item, i) => {
            return this.mt.split(item)
        })
        return smallify(value)
        //return smallify(value)
    }
    runner(s, depth = 0) {
        s = smartDedent(s)
        let r = /\n(?=\w)/
        let m = s.split(r)
        if (m.length == 1) {
            return this.runnerFlatHtml(s)
        }

        return map(m, (text) => {
            if (!/^ /m.test(text)) {
                return this.runnerFlatHtml(text)
            }
            let [name, b] = splitonce(text, /\n/)
            return b
                ? this.parseGroup(
                      name,
                      this.runner(b, depth + 1)
                  )
                : this.parseItem(text)
        })
    }
}

class AlanParser2 {
    constructor(options = {}) {
        this.depth = 0
    }

    run(s) {
        const result = this.runner(s)
        return result
    }

    runner(s, depth = 0) {
        s = smartDedent(s)
        let r = /\n(?=\w)/
        let m = s.split(r)
        console.log(m)
        breaker(3)

        return map(m, (text) => {
            //console.log({text})
            if (!/^ /m.test(text)) {
                return text
            }
            return this.runner(text, depth + 1)
        })
    }
}

function doublef(fn, position) {
    return function lambda(s) {
        const value = fn(s)
        return position == 1 ? [value, s] : [s, value]
    }
}
function assignMathSolver(state, ref) {
    function f(k, v) {
        if (isNestedArray(v)) {
            return v
        }
        return v.map(
            doublef((x) => {
                let name = parseFunctionName(x.name)
                //console.log(k, capitalize(name), 'hiii')
                let g =
                    state[k + capitalize(name)] || state[name]
                return g.bind(state)
            })
        )
    }

    for (let [k, v] of Object.entries(ref)) {
        const tests = f(k, v)
        const solver = new MathSolver3(tests, {
            debug: 0,
        })
        state[k + 'Solver'] = solver
        /* binding the object */
    }
}
function parseFunctionName(s) {
    return toCamelCase(s.replace(/^(?:is|to)/, ''))
}
s = `
top
    goo
        foo
    topbb
        df
        df
        df
B
    bchild
    achild
`

alanParserString = `

    Find monday's math letter by coloring in each of the answer boxes.
        If the answer is $cond1, color the box $color1.
        If the answer is $cond2, color the box $color2.

    Once you have colored in all of the answer boxes, the final letter will appear!`

function regexBuilder(key, capture) {
    /* R0714
     * is a previous version of it
     * */

    const REGEXES = {
        sp: '[.,]? ',
        w: '\\w+',
        word: "[a-zA-Z]+(?:'s)?",
        wordOrNumber: "(?:[a-zA-Z]+(?:'s)?|\\d+)",
    }

    const dict = {
        isSentence: '^$word(?:$sp$wordOrNumber){2,}',
    }

    let s = ''

    if (dict.hasOwnProperty(key)) {
        s = dict[key]
    }

    let templaterRE = /\$(\w+(?:-\w+)*)/g
    let regex = s.replace(templaterRE, (_, x) => {
        const value = REGEXES[x]
        if (capture) return parens(value)
        return value
    })
    const f = toFunction({
        name: key,
        params: ['s'],
        body: `return /${regex}/.test(s)`,
        mode: Function,
    })
    return f
}

//How many $condNumbers satisfy the inequality $inequality?
//nerdSolver()

//console.log(partitionVertical([1,2,3,4,5,6], 3))

function partitionVertical(items, n = 2) {
    //console.log(type(items))
    const storage = new Storage()
    items.forEach((item, i) => {
        let index = i % n
        storage.add(index, item)
    })
    return Object.values(toJSON(storage))
}

//Honor the Student ...

studenthw = {
    lynn: 'solveForX fractionArithmetic',
    elina: 'fractionWordProblems fractionArithmetic',
    kloe: 'percentages ratios lcm gcf',
    kaylee: 'percentages ratios lcm gcf',
    aaron: 'percentages ratios lcm gcf',
    alan: 'math',
    /* tracking current progress */
}

const difficultyRanking = ['Arithmetic', 'WordProblems']
/* the questions need tags */

var difficultyTable = {
    1: {
        alias: 'easy',
        description: `
            one-step or simple-two-step operations
            operations which do not have any tricks
            very operational in nature
            @brae
            @lynn
            @markChristensen
            @nihan
            no tricks, no twists
        `,
    },
    2: {
        alias: 'medium',
        description: `
            
        `,
    },
}
var globalStudentConfig = {
    /* gsc */
    homeworkPacket: [
        { topic: 'equations', amount: 2 },
        { topic: 'inequalities', amount: 2 },
        { topic: 'exponents', amount: 2 },
        { topic: 'absoluteValue', amount: 3 },
    ],
    level: 1,
    topic: 'inequalities',
    name: 'Nihan',
    difficulty: 1,

    //topic: 'equations',
}

function buildHomeworkPacket(studentConfig, packetConfig) {
    var randomInequality = randomf(['<', '>', '<=', '>='])
    qgBuildTopic('inequalities')
    //qgBuildTopic('absoluteValue')
    mixinsForWS3()
    classMixin(Numbergen, UtilityMixins)
    classMixin(
        MathTemplater3,
        MathTemplaterMixins,
        UtilityMixins,
        mathTemplaterHelperFunctions,
        HTMLTemplaterMixins
    )

    isSentence = regexBuilder('isSentence')
    loadConsoleString()
    var defaultHomeworkPacketConfig = {}

    if (!studentConfig) {
        studentConfig = globalStudentConfig
    }

    if (!packetConfig) {
        packetConfig = defaultHomeworkPacketConfig
    }

    const packet = studentConfig.homeworkPacket /* array */
    const worksheet = new Worksheet3(studentConfig)
    const toc = map(packet, 'topic')
    const name = studentConfig.name

    const titleData = {
        name,
        date: true,
        toc,
    }

    const questionPages = map(packet, (config) => {
        return generateAll(worksheet, config)
    })

    return {
        pages: [titleData, ...questionPages],
    }
    /* --------------------------------- */

    const titlePage = `
        $name's Homework Packet
        $date
        ------------------------
        $toc
        ------------------------
    `

    var alanOptions = {
        dollarRef: {
            name,
            toc,
        },
        baseDollarRef: {
            date: datePhrase,
        },
    }
    const alan = new AlanParser(alanOptions)
    const htmlTitlePageResult = alan.run(titlePage)
    return htmlTitlePageResult
}

function announceTheFunction() {
    const name = getCaller(-1)
    const p = bringToLife(name).toString()
    console.log('anouncing the function')
    console.log(p)
}
function foo15() {
    announceTheFunction()
    qgBuildTopic('inequalities')
    mixinsForWS3()
    const worksheet = new Worksheet3(globalStudentConfig)
    console.log(worksheet.qg.generateAll())
    /* this exists now at buildHomeworkPacket */
}

//

function hasDollar(s) {
    return /\$/.test(s)
}
function templateToHTML() {
    const titlePage = `
        $name's Homework Packet
        $date
        ------------------------
        $toc
        ------------------------
    `
    const ref = {
        name: 'sam',
        date() {
            return datePhrase()
        },
        toc,
    }

    //const parser =
}

//Jacob -> Jake
//Johnathan - John - Johnny
//Thomas - Tom - Tommy
//mu chuang
//grazing mountans and rivers
//Oliver
//Callum
//playing together ...
//

function typeTransform(s, o) {
    let t = type(s).toLowerCase()
    let value = o[t](s, o.type || t)
    if (o.transform) {
        return o.transform(value)
    }
    return value
}

function fval(s, tests) {
    for (let [test, value] of tests) {
        if (ftest(test, s)) {
            return fparse(value, s)
        }
    }
    return s
}

/*
 * These items will be used via MathTemplater.
 * They are added in and jsut work.
 * */
var HTMLTemplaterMixins = {
    typeTransform(s) {
        let type
        if (this.dollarWordRef.hasOwnProperty(s)) {
            type = s
            s = this.dollarWordRef[s]
        }
        return typeTransform(s, {
            type,
            string(s, name) {
                if (name != 'string') {
                    return divify('span', name, s)
                }
                var tests = [
                    /^---/,
                    '<hr class="h-line"/>',
                    /./,
                    (x) => divify('span', '', x),
                ]
                return fval(s, partition(tests))
            },
            array: shList,
            object: shObject,
            transform(value, t) {
                return value
                //if (!t) t = type(value)
                //return {type: t, value}
            },
            function(s, name) {
                const value = s()
                return divify('div', name, value)
            },
        })
    },
    htmlWord(s) {
        const item = this.dollarWordRef[s]
        return item
    },
}

function foo16() {
    classMixin(
        MathTemplater3,
        MathTemplaterMixins,
        UtilityMixins,
        mathTemplaterHelperFunctions
    )
    classMixin(MathTemplater3, HTMLTemplaterMixins)

    isSentence = regexBuilder('isSentence')
    runClass(AlanParser, alanParserString, alanParserConfig)
}
function shObject(s) {
    //return 'hibf'
}
function shList(items, name) {
    let childName = name + '-child'
    let parentName = name + '-parent'
    const p = divify(
        'ul',
        parentName,
        items.map((item, i) => {
            return divify('ul', childName, item)
        })
    )
    return p
}

function divify(tag, attrs, x) {
    if (!x) x = ''
    if (!attrs) attrs = ''

    let s = toOpeningTag(tag, attrs)

    if (tag == 'input' || tag == 'hr') {
    } else if (
        isArray(x) ||
        (isString(x) && (hasNewline(x) || hasHtml(x)))
    ) {
        s += newlineIndent(x)
    } else {
        s += x
    }

    return s + toClosingTag(tag)
}
function isCssWord(s) {
    return /^[\w-]+$/.test(s)
}
function toOpeningTag(tag, attrs) {
    let s = ''
    let spaces = ' '

    const suffix = hasHtmlSuffix(tag) ? '>' : '/>'
    if (isString(attrs)) {
        if (isCssWord(attrs)) attrs = attrEntry('class', attrs)
        if (attrs) return '<' + tag + ' ' + attrs + suffix
        return '<' + tag + attrs + suffix
    }
    //else if (isObject(attrs)) {
        
    //}

    for (let [k, v] of prepareIterable(attrs, 'entries')) {
        if (!exists(v)) {
            continue
        }
        s += spaces
        if (k == 'classNames') {
            s += attrEntry('class', v.join(' '))
        } else if (k == 'class' || k == 'className') {
            if (/^[A-Z]/.test(v)) {
                v = toDashCase(v)
            }
            s += attrEntry('class', v)
        } else if (k == 'dataAttributes') {
            s += v.join(' ')
        } else {
            s += attrEntry(k, v)
        }
    }

    return '<' + tag + s + suffix
}
function hasHtmlSuffix(el, force) {
    if (force) return true
    return closers.includes(el)
}
const closers = [
    'style',
    'footer',
    'header',
    'p',
    'pre',
    'script',
    'body',
    'ul',
    'li',
    'p',
    'textarea',
    'button',
    'section',
    'div',
    'h1',
    'h2',
    'h3',
    'main',
    'blockquote',
    'span',
    'article',
    'body',
    'html',
    'head',
    'template',
    'h4',
    'h5',
    'h6',
]
function attrEntry(a, b, newline) {
    if (b == null || b == '') return ''
    if (isArray(a)) {
        newline = b
        b = a[1]
        a = a[0]
    }
    return `${a}=${addQuotes(b)}${newline ? '\n' : ''}`
}
function hasHtml(s) {
    return test(/<\/?[a-z\/]/, s)
}
function toClosingTag(el) {
    const noclosers = ['input', 'hr', 'br', 'link', 'img']
    if (noclosers.includes(el)) return ''
    if (looksLikeComponent(el)) return ''
    return '</' + el + '>'
}
function looksLikeComponent(s) {
    return /-/.test(s) || /^[A-Z]/.test(s)
}

var QGAnswerRequirements = {
    inequalities: {
        options: {
            transformCheckpoint(s) {
                return parseNumber(s.answer)
            },
        },
        1: [isNumber],
        //1: [isNegative, isFraction],
        2: [isNumber],
        3: [isNumber],
        4: [isNumber],
        5: [isDecimal],
        6: [isFraction],
    },
    equations: {
        options: {
            transformCheckpoint(s) {
                return parseFloat(s.answer)
            },
        },
        1: [isNumber],
        2: [isNumber],
    },
}

function parseNumber(s) {
    return s.toString().replace(/\w+ *[<>]=? */, '')
}

//
// to take money from the kid
//console.log(divify('span', '', 'hi'))

//foo15()
//foo16()

loadConsoleString()
var randomInequality = randomf(['<', '>', '<=', '>='])
//console.log(nerdSolver('|x + 2| + |x| = 4'))

function isNumericalAnswer(s) {
    return isNaN(parseFloatAnswer(s))
}
//console.log(nerdamer('abs(-2 +)').toString())

function generateInstructions(topic, level) {
    return
    /* used at generateAll ... */
    const instruction = MasterTemplates[topic]
    /* letterAnswerBox */
    /* a table for fraction or inequality */
}

function parseFloatAnswer(x) {
    return isObject(x) ? parseFloat(x.answer) : parseFloat(x)
}

function wordProblemFilter(x, topic) {
    if (x.tags && !x.tags.includes(topic)) return
    if (x.tag && !x.tag.includes(topic)) return
    if (x.difficulty && level < x.difficulty) return
    return true
}
function getWorksheetTemplates(topic, level) {
    let templates = QuestionGeneratorTemplates[topic]
    if (!templates) {
        let f = partial(wordProblemFilter, topic)
        templates = wordProblems.filter(f)
    }

    if (isNestedArray(templates) || isObject(templates)) {
        templates = templates[level]
    }
    //console.log({templates})
    return flat(templates)
}

/* worksheet utils */
function defaultWorksheet(s) {
    return new Worksheet3(globalStudentConfig)
}
function generateAll(ws, config) {
    if (!ws) ws = defaultWorksheet()
    if (!config) config = {}

    let { topic, level, amount } = config
    if (!topic) topic = ws.studentConfig.topic
    if (!level) level = ws.studentConfig.level
    if (!amount) amount = 1

    //console.log(topic)
    let templates = qg.getTemplates()
    //console.log(templates); throw "";
    let qg = ws.qg
    qg.setAnswerRequirements(topic, level)
    qg.setOption('multipleChoice', config.multipleChoice)

    const questions = config.presetAnswers
        ? qgOrdered(qg, templates, config.presetAnswers)
        : qgRandom(qg, templates)

    const instructions =
        config.instructions &&
        generateInstructions(topic, level)
    const answerBox =
        config.answerBox && generateAnswerBox(questions)

    qg.setOption('multipleChoice', null)
    qg.setAnswerRequirements(null)
    return { questions, topic }
}

var wordProblems = [
    {
        type: 'wordProblem',
        tags: 'fractions time ratio',
        question:
            '$name eats $frac of a $pizza every day. How many $days will it take $name to eat $a $pizzas?',
    },
]

//require('./node-utils.js').clip(buildHomeworkPacket)

const allMathOperators = ['=', '-', '+', '*', '/']
function exponentQuestionFromLinear(
    s,
    { base = 2, level = 1 } = {}
) {
    if (level == 2) {
        base = rng(2, 3)
    } else if (level == 3) {
        base = rng(2, 8)
    }

    const runner = (x) => {
        let numbers = convertifyExponent(base, x, level)
        return latexExponent(...numbers)
    }
    const items = iterate(split(s), (el, i, items) => {
        if (allMathOperators.includes(el)) {
            const [prev, next] = [items[i - 1], items[i + 1]]
            switch (el) {
                case '-':
                    return {
                        next: true,
                        popPrev: true,
                        value: latexFraction(
                            runner(prev),
                            runner(next)
                        ),
                    }
                case '+':
                    return '*'
            }
            return el
        }
        return runner(el)
    })
    const value = items.join(' ')
    if (value.includes('NaN')) {
        console.log({ s, value, items })
    }
    return value
    return nerdQA(value)
}
//require('./node-utils.js').clip(s)

function dictFunctionToFunction(s, baseName) {
    if (baseName) {
        return (
            'function ' +
            baseName +
            capitalize(v.toString()).replace(/^    /gm, '')
        )
    }
    return 'function ' + v.toString().replace(/^    /gm, '')
}
//console.log(d); throw '';
//require('./node-utils.js').appendSelf(d)

function latexExponent(a, b) {
    return `${a}^{${b}}`
}

function latexFraction(a, b) {
    return `\\frac{${a}}{${b}}`
}

function latexDfrac(a, b, parentheses) {
    let left = '\\left('
    let right = '\\right)'
    if (!parentheses) {
        left = ''
        right = ''
    }
    return `\\dfrac{${a}}{${left}${b}${right}}`
}
var nerdamerSpellcheckDictionary = {
    '{': '(',
    '}': ')',
}

//console.log(nerdSolver('2^{2 * x} * 2^x = 2^4'))
//
//
function has(key, x) {
    try {
        if (key in x) {
            return true
        }
    } catch (e) {}
}
function iterate(items, f) {
    const store = []
    for (let i = 0; i < items.length; i++) {
        const item = items[i]
        const value = f(item, i, items)
        if (isDefined(value)) {
            if (isObject(value)) {
                if (value.next) {
                    i++
                }
                if (value.popPrev) {
                    store.pop()
                }
                if (value.popNext) {
                    store.pop()
                }
                if (isDefined(value.value)) {
                    store.push(value.value)
                }
            } else {
                store.push(value)
            }
        }
    }
    return filter(store, isDefined)
}

//
//const [prev, next] = [items[i - 1], items[i + 1]]

function convertifyExponent(base, n) {
    let o = n
    let log

    if (n == 'x' || n == 1) return [base, n]
    if ((log = logn(n, base))) {
        if (coinflip(0.1)) {
            let r = rng(1, 3)
            base = Math.pow(base, r)
            log = log / r
        } else {
            base = Math.pow(base, log)
        }
        return [base, log]
    }
    /* x + 4
     * base = 2
     * n = 4
     * leave it as 4
     * write it as 4^1
     * write it as 2^2
     * write it as 8^1/2
     * write it as 16^1/4
     * write it as 32^1/8
     * */
    n = parseInt(n)
    //console.log(n); throw "";
    let k = randomPick(getPrimeFactors(n))
    if (!k) return [ba]
    //console.log(k); throw "";
    //if (k == n) return [base, n]
    let g = n / k
    let mod = modifyNumber(o, g)
    //console.log(mod); throw "";
    base = Math.pow(base, k)
    return [base, mod]
}

function modifyEquation(s, f) {
    let touched
    let count = 0
    s = s.replace(/\d+/g, (x) => {
        count++
        if (touched) return x
        if (coinflip(count / 3)) {
            touched = true
            if (f) {
                return isFunction(f) ? f(Number(x)) : f
            }
            return rngAround(x)
        }
        return x
    })
    if (!touched) return modifyEquation(s, f)
    return s
}
function addOne(x) {
    return x + 1
}

function subtractOne(x) {
    return x - 1
}
function coinflipf(a, b) {
    return function lambda(...args) {
        return coinflip() ? a(...args) : b(...args)
    }
}
var addOrSubtract = coinflipf(addOne, subtractOne)
//console.log(exponentQuestionFromLinear())

function mixinMaster(...keys) {
    nerdamer = require('nerdamer/all.min')
    mtMixin()
    classMixin(Numbergen, UtilityMixins)
    classMixin(QuestionGenerator3, QuestionGeneratorMixins)
    //classMixin(ExplanationService, ExplanationServiceParsers)
    classMixin(Worksheet3, MathSolverMixins, WorksheetUtils)
    //mixinsForWS3()
    ///* not using wk3 */
}
function qgGenerate(o = {}) {
    if (!o.key) o.key = 'equations'
    if (!o.amount) o.amount = 10

    const qg = new QuestionGenerator3({
        topic: o.key,
    })

    //qg.slowlyIncreaseNumbers()

    //const questions = o.answers ?
    //qgOrdered(qg, qg.getTemplates(), o.answers) :
    //qgRandom(qg, qg.getTemplates(), o.amount)

    const linear = new NiceLinear()
    //const context = new MathContext()
    const runner = ensureUniqueQuestion({
        requirements: (x) => !x.question.includes('-'),
    })
    const questions = o.answers.map((answer, i) => {
        context.set('answer', answer)
        return runner(() => linear.generate(context))
    })

    if (o.related) {
        const relatedFunctions = {
            equations: {
                exponents: exponentQuestionFromLinear,
            },
        }
        const f = relatedFunctions[o.key][o.related]
        const relatedQuestions = edit(questions, 'question', f)
        return [
            {
                key: o.key,
                questions,
            },

            {
                key: o.related,
                questions: relatedQuestions,
            },
        ]
    }
    return questions
}
var QuestionGeneratorMixins = {
    //slowlyIncreaseNumbers(s) {
    //this.onSuccess = (item) => {
    //console.log('got one success')
    //this.mt.numbergen.increaseRange()
    //}
    //},

    getTemplates() {
        let topic = this.studentConfig.topic || 'equations'
        let level = this.studentConfig.level || 1
        return getWorksheetTemplates(topic, level)
    },

    getTemplate(config) {
        let topic = config.topic || this.studentConfig.topic
        let level = config.level || this.studentConfig.level
        const value = dictgetter(
            QuestionGeneratorTemplates,
            topic,
            level
        )
        return fget2(value)
    },

    rngAround(n) {
        return rngAround(n)
    },
}
function qgRandom(qg, templates, amount = 10) {
    if (!templates) templates = qg.getTemplates()
    let t
    const store = fillUp(amount, () => {
        t = modularIncrement(templates, t)
        return qg.generate(t)
    })
    return store
}

function qgOrdered(qg, templates, answers = 10) {
    if (!templates) templates = qg.getTemplates()
    let t
    let store = []
    let breaker = BreakerFactory(100, { dontThrow: 1 })

    if (isNumber(answers)) {
        answers = range(answers)
    }
    let copied = copy(answers)

    while (copied.length) {
        let errorCode404 = breaker()
        if (errorCode404) {
            throw 404
            breaker.reset()
        }
        t = modularIncrement(templates, t)
        let item = qg.generate(t)
        console.log(item.question)
        if (item == null) {
            console.log('null generated at qg')
        }
        if (copied.includes(item.answer)) {
            store.push(item)
            popValue(copied, item.answer)
            qg.mt.numbergen.increaseRange()
        }
    }
    return rigidSort(store, answers, parseFloatAnswer)
}
function fillUp(amount, f, ...args) {
    if (amount == 1) return f(...args)
    const store = []
    const breaker = BreakerFactory(10)
    while (store.length < amount) {
        breaker()
        const value = f(...args)
        push(store, value, true)
    }
    return store
}

function fixAbsoluteValue(s) {
    /* fix absolute value */
    return s.replace(/\|(.*?)\|/g, (_, x) => {
        return stringcall('abs', x)
    })
}

function findIndex(value, store) {
    const index = isFunction(value)
        ? store.findIndex(value)
        : store.indexOf(value)
    return index
}

function popValue(store, value) {
    if (isArray(store)) {
        let index = findIndex(value, store)
        if (index < 0) {
            //console.log('didnt have')
            return
        }
        return store.splice(index, 1)[0]
    }

    if (isObject(store)) {
        let index = findIndex(Object.values(store), store)
        if (index < 0) return
        let key = Object.keys(store)[index]
        let value = store[key]
        delete store[key]
        return value
    }
}
function gen(s) {
    return { q: Math.random(), answer: s }
}

//I will not get anything done sitting in the library.
//That is absolutely true. Bu I may have a chance at the other library.

s = `
numberPatterns
123454321
12123123412345
`

function numberPattern(key, o = {}) {
    if (isString(key)) {
        if (hasSpaces(key)) {
            return split(key, ' ')
        }
    }
    if (isObject(key)) {
        o = key
        key = key.pattern
    }
    if (!o.pattern) {
        return earlyReturn('no number pattern')
    }
    if (o.presets) return o.presets
    let offset = o.offset || 0
    let from = o.from || 0
    let increment = o.increment || 1
    let amount = o.amount || 10
    let start = o.start || o.from || 0

    if (isNumber(key)) {
        return map(amount, () => Number(key))
    }

    if (/\d+ \d+ \d+/.test(key)) {
        return getNumbers(key)
    }
    if (mathSequencesDictionary.hasOwnProperty(key)) {
        let sequence = mathSequencesDictionary[key]
        let index = sequence.findIndex((n) => n >= key)
        return sequence.slice(index, index + amount)
    }
    if (isLinearEquation(key)) {
        let f = bringToLife(key)
        return range(amount).map((i) => {
            return f(i) + start
        })
    }

    function helper(n) {
        let top = Math.ceil(n / 2)
        let extraTop = -1
        let topValue = top
        if (increment > 1) {
            extraTop += Math.floor(top / increment) + 1
            topValue += increment * 2
        }
        let middle = isEven(n)
            ? [topValue, topValue]
            : [topValue]
        let forward = range(1, top + extraTop, increment)
        //console.log(forward); throw "";
        let backward = copy(forward).reverse()
        return [forward, middle, backward]
    }
    const ref = {
        ['321'](n) {
            let offset = isEven(amount) ? 2 : 2
            return range(
                start - amount * increment + offset,
                start,
                increment
            ).reverse()
        },

        ['123'](n) {
            return range(
                start,
                start + amount * increment - 1,
                increment
            )
        },
        fibonacci(n) {
            return fibonacci(n, o.start, amount)
        },
        bigRandom(n) {
            return map(n, () => rng(10, 100))
        },

        random(n) {
            const value = map(n, () => rng())
            return value
        },
        spiral(n) {
            /* needs to be a spiralable number */
            let a = Math.sqrt(n)
            assert(isInteger(a))
            return flat(numberSpiral(a, a))
        },
        pyramid(n) {
            let [forward, middle, backward] = helper(n)
            let values = [...forward, ...middle, ...backward]
            let dir = 1
            if (offset) {
                values = values.map((item, i) => {
                    let val = item + offset
                    return val
                })
            }
            return values
        },
        rotatingFunnel(amount, o) {
            if (o.from > o.to) {
                let from = o.from
                let to = o.to
                o.to = from
                o.from = to
            }
            return oscillator(amount, o)
        },
        funnel(n) {
            let a = this.pyramid(n)
            let e = isEven(n)
            let middleIndex = e
                ? Math.floor(a.length / 2)
                : Math.ceil(a.length / 2)

            if (e) {
                return [
                    ...a.slice(0, middleIndex).reverse(),
                    ...a.slice(0, middleIndex),
                ]
            } else {
                return [
                    ...a.slice(1, middleIndex).reverse(),
                    ...a.slice(0, middleIndex),
                ]
            }
        },
        increasing(n) {
            //242468246810
            /* 121231234 */
            /* also decreasing is a thing */
        },
    }
    return ref[key](amount, o)
}

/*  */

function fibonacci(s, store, amount = 10) {
    if (!store) store = [0, 1]
    for (let i = 2; i < amount; i++) {
        store[i] = store[i - 2] + store[i - 1]
    }
    return store
}

var mathSequencesDictionary = {
    primes: [],
    fibbonacci: [],
}

function fixConfig(s) {
    if (!s) {
        return {
            level: 1,
        }
    }
    if (!s.level) s.level = 1
    return s
}
const questions = [
    function fractionRank() {
        const fractions = fgen(fractionrng, 3)
        const answer = fractions.slice()
        answer.sort((a, b) => eval(a) - eval(b))
        return (h) => {
            return h(FractionRankComponent, {})
            /* this is arguably a quiz. */
        }
    },
]
/*** 08-10-2022 ***/

/* niceLinear and then the sloted table */

s = `
    <v-table :value="value">
        <template v-slot:headers="{headers}">
            <v-row :value="headers"/>
        </template>

        <template v-slot:cell="{{cell}}">
            <div class="fo">{{cell}}</div>
        </template>
    </v-table>
`

var MathOperationsRef = {
    percentChange(base, change) {
        return base * ((100 + change) / 100)
    },
    divide(a, b) {
        return a / b
    },
    exp10(s) {
        return Math.pow(10, s)
    },
    stdev(numbers) {
        const mean = this.average(numbers)
        const sumMinusMean = numbers.reduce(
            (a, b) => a + (b - mean) * (b - mean),
            0
        )
        return Math.sqrt(sumMinusMean / (numbers.length - 1))
    },
    multiply(a, b) {
        return sum(a, (k, v) => k * v)
    },
    average(...args) {
        args = gatherAllArgs(args)
        return sum(args) / args.length
    },
    add(a, b) {
        return a + b
    },

    square(a) {
        return a * a
    },

    proportion(a, b, c, d) {
        return 4
        //return solveProportions(a, b, c, d)
    },
    times(a, b) {
        return a * b
    },
}
function latexer(a, b) {
    return `\\${a}{${b}}`
}
var MathLatexDisplayRef = {
    /** ld **/
    toLatex(x, operator) {
        if (isArray(x)) {
            return x.join(latex.fixOperator(operator))
        }
        return x
    },
    newline(s) {
        return '\\\\'
    },
    emptyBox(s = '*', color = 'white') {
        const background = `\\color{${color}}`
        return `\\boxed{${background}${s}}`
    },

    spaces(n) {
        return '\\,'.repeat(n)
    },
    fixOperator(x = '+') {
        if (x == '*') return '\\times'
        return x || '+'
    },
    prose(s) {
        if (isEndOfSentence(s)) {
            s += '\\\\'
        }
        s = s.replace(/^([.?]) /g, '$1} \\\\ \\text{')
        return latexer('text', s)
    },
    fractify(a) {
        if (isFraction(a)) {
            return this.frac(...split(a, '/'))
        }
        return a
    },

    wrapFraction(a, ref) {
        if (isNull(a)) {
            return
        }
        if (isDecimal(a)) {
            let length = longestDecimal(a).length
            return nerdamer(a).text('decimal', length)
        }

        if (isFraction(a)) {
            return parens(a)
        }

        return a
    },

    cancel(a) {
        return `\\cancel{${a}}`
    },

    add(...args) {
        return args.join(' + ')
    },

    subtract(...args) {
        return args.join(' - ')
    },
    wrap(s) {
        return `$${s}$`
    },
    proportion(a, b, c, d) {
        return latex.equality(
            latex.frac(a, b),
            latex.frac(c, d)
        )
    },
    parens(s) {
        return '\\left(' + s + '\\right)'
    },

    nnfrac(n) {
        n = 8
        let [a, b, c, d, e, f, g, h] = map(n, () => rng(1, 10))

        if (n == 4) {
            return latex.pfrac(
                latex.pfrac(a, b),
                latex.pfrac(c, d)
            )
        }

        if (n == 8) {
            let A = latex.pfrac(
                latex.pfrac(a, b),
                latex.pfrac(c, d)
            )

            let B = latex.pfrac(
                latex.pfrac(e, f),
                latex.pfrac(g, h)
            )
            return latex.divide(A, B)
        }
    },
    eq(a, b) {
        return `${a} = ${b}`
    },

    equality(a, b) {
        return `${a} = ${b}`
    },
    multiply(...args) {
        args = gatherArgs(args).map((x) => {
            if (
                isString(x) &&
                x.includes(' ') &&
                hasOperator(x)
            ) {
                return this.parens(x)
            }
            return x
        })
        return args.join(' \\cdot ')
    },
    times(...args) {
        return args.join(' \\times ')
    },
    exp10(x) {
        return `${10}^{${x}}`
    },

    exp(a, b) {
        return `${a}^{${b}}`
    },

    divide(a, b) {
        return `${a} \\div ${b}`
    },

    exponent(a, b) {
        return `${a}^{${b}}`
    },
    pfrac(a, b) {
        return this.parens(this.frac(a, b))
    },

    frac(a, b) {
        if (isFraction(a)) {
            a = this.parens(a)
        }

        if (isFraction(b)) {
            b = this.parens(b)
        }
        return `\\dfrac{${a}}{${b}}`
    },
    dfrac(a, b, parentheses) {
        let left = '\\left('
        let right = '\\right)'
        if (!parentheses) {
            left = ''
            right = ''
        }
        return `\\dfrac{${a}}{${left}${b}${right}}`
    },

    conditionalParens(s) {
        return hasSpaces(s) ? latex.parens(s) : s
    },
    //times(a, b) {
        //return `${latex.conditionalParens(a)} \\cdot ${b}`
    //},
}

latex = MathLatexDisplayRef
math = MathOperationsRef
var StringMathRef = {
    math: MathOperationsRef,
    latex: MathLatexDisplayRef,
}

var xStringMathRef = {
    /* functions are the bulidnig blocks */
    latexSquare(s) {
        return `${s}^2`
    },
    mathSquare(s) {
        return s * s
    },
    latexSum(s) {
        return s.join(' + ')
    },
    mathSum(s) {
        return sum(s)
    },
    /* colors is a whole other aspect to this... */
    /* can perhaps color it afterwards */
}
class StringMathNode {
    constructor(s, f, d, k) {
        this.type = k

        if (isArray(s)) {
            if (getConstructorName(s[0]) == 'StringMathNode') {
                let values = s.map((x) => x.value)
                let displays = s.map((x) => x.display)
                this.value = f(values)
                this.display = d(displays)
            } else {
                if (countParameters(f) == 1) {
                    this.value = f(s)
                    this.display = d(s)
                } else {
                    this.value = f(...s)
                    this.display = d(...s)
                }
            }
        } else {
            if (getConstructorName(s) == 'StringMathNode') {
                this.value = f(s.value)
                this.display = d(s.display)
            } else {
                this.value = f(s)
                this.display = d(s)
            }
        }
    }
    toString() {
        return this.display
    }
    toJSON() {
        return {
            display: this.display,
            value: this.value,
        }
    }
    expr() {
        return this.display + ' = ' + this.value
    }
}
class StringMath {
    constructor() {
        this.ref = StringMathRef
    }
    map(a, key) {
        const items = items.map((item) => this[key](item))
        return new StringMathGroup(items)
    }
    sum(s) {
        return this.create(s, 'sum')
    }
    square(s) {
        return this.create(s, 'square')
    }

    create(s, key) {
        const f = this.ref.math[key]
        const d = this.ref.latex[key]
        return new StringMathNode(s, f, d, key)
    }

    divide(...args) {
        return this.create(args, 'divide')
    }
}

function isHappyNumber(n) {
    const store = []
    const sm = new StringMath()
    function runner(n) {
        breaker(100)
        const digits = splitNumber(n)
        const squares = digits.map((x) => sm.square(x))
        const sum = sm.sum(squares)

        store.push({
            digits,
            n,
            sum,
        })

        if (sum.value == 1) {
            return true
        } else {
            return runner(sum.value)
        }
    }
    const outcome = runner(n)
    return {
        store,
        outcome,
        length: store.length,
    }
}
//console.log(stringify(isHappyNumber(7))); throw '';
//console.log(pascalTriangle(10)); throw '';

/* happy numbers ... */
/* if it works for one, it will work for both */
s = `
decimals
fractions

to have nearly infinite options ... 
to have an inspired product ...
to have something ...

ax + b = c
ax - b = c
ax + b = c
ax + b = c

Satisfying Crunches ...

2x + 6  = 4

function isSatisfyingLinear(a, b, c) {
    return (c - b) > 0 && (c - b) % a == 0
}

`

function niceLinear(answer = 1) {
    let [a, b, c] = getNumbers()
    return `${a}x ${operator} ${b} = ${c}`
    return `${b} ${operator} ${a}x = ${c}`
    return `${c} = ${b} ${operator} ${a}x`

    templates = []
    return templater(template, getNumbers())

    function getNumbers(answer) {
        let m = rng()
        let A = answer * m
        let B = rng()
        let C
        let op
        if (coinflip()) {
            op = '-'
            C = A - B
        } else {
            op = '+'
            C = A + B
        }
        return { op, c: C, a: m, b: B }
    }
}

//b = BreakerFactory()
//console.log(b.reset()); throw "";

//a = [{a:1}, {a:2}]
//b = edit(a, 'a', (x) => x + 1)
//console.log(b)
//console.log(b == a)
//console.log(a); throw '';

function pascalTriangle(numRows, o = {}) {
    if (numRows === 0) return []
    if (numRows === 1) return [[1]]
    let r = []
    for (let row = 1; row <= numRows; row++) {
        let arr = []
        for (let col = 0; col < row; col++) {
            if (col === 0 || col === row - 1) {
                arr.push(1)
            } else {
                arr.push(r[row - 2][col - 1] + r[row - 2][col])
            }
        }
        r.push(arr)
    }
    return r
}

const difficultyLevels = [
    'remedial',
    'easy',
    'medium',
    'hard',
    'super',
]

function templaterMathProblem(s, ref) {
    let count = 0
    const f = (x) => {
        switch (x) {
            case '+':
            case '-':
                if (ref.op) return ref.op
                return ref.operators[count++] || x
            case 'a':
            case 'b':
            case 'c':
            case 'd':
                return ref[x]
        }
    }
    return s.replace(/\b[abcdef](?=[xyz ]|$)|[+-]/g, f)
}

function proliferateTheTemplatedoitoneday(s) {
    s = 'ax + b = c'
    let [a, b] = split(s, '=').map(partial(split))
    let A = reverse(copy(a))
    let B = a

    console.log([a, b])
    throw ''
    /* too hard */
}
//proliferateTheTemplate(s)
var MPTemplates = {
    NiceExponent: {
        easy: `
            2^a * 2^b
            2^a * 2^b * 2^c
            2^a * 2^b * 2^c * 2^d
            /* from latex */
        `,
    },

    NiceLinear: {
        easy: `
            ax + b = c
            //c = b + ax
            //b + ax = c
            //c = ax + b
        `,

        medium: `
            ax + b / c = d
            ax / c + b / c = d
        `,

        hard: `
        
        `,
    },
}
class MathProblem {
    constructor(level) {
        this.level = level || 1
        this.difficulty = difficultyLevels[this.level]
        this.name = getConstructorName(this)
        const s = MPTemplates[this.name][this.difficulty]
        this.templates = linegetter(s)
    }

    generate(context) {
        if (context.answer) {
            return this.generateFromAnswer(context.answer)
        }
    }
    generateFromAnswer(answer) {
        const fn = this[this.difficulty]
        const args = fn(answer)
        const template = randomPick(this.templates)
        const question = templaterMathProblem(template, args)
        return {
            question,
            answer,
        }
    }
}

class NiceLinear extends MathProblem {
    constructor() {
        super()
    }
    toString() {}

    easy(answer) {
        let m = rng()
        let A = answer * m
        let B = rng()
        let C
        let op
        if (coinflip()) {
            op = '-'
            C = A - B
        } else {
            op = '+'
            C = A + B
        }
        return { op, c: C, a: m, b: B }
    }
    medium(answer) {}
    hard(answer) {}
}

class NiceExponent extends MathProblem {
    constructor() {}
}
class ThreeNMinusOne {
    constructor() {}
}
class HappyButOne extends MathProblem {
    /* i dont think that it is supposed to be a class */
    constructor(context) {
        super(context)
        this.text = `
            In the following list of numbers, 
            only one of them qualifies as a "happy" number. 
            Which number is it?
        `
        this.definition = {
            name: 'happy number',
            definition: 'Ughhh. Complicated.',
        }
    }
}
function generateHappyButOne(context) {
    const config = {
        /* there will require multiple iterations */
        /*  */
    }
    map(4, partial(numbergen, config))
}

class MathContext {
    constructor() {
        this.answer = 3
    }
    sdfsdf(s) {}
    set(k, v) {
        this[k] = v
    }
}

//console.log((new NiceExponent).generate(new MathContext))
// to have a solid understanding...

function creator({
    pattern = 'pyramid',
    amount = 20,
    key = 'equations',
    related = null,
} = {}) {
    /*
     *
     *
     * */

    mixinMaster()
    const answers = numberPattern(pattern, {
        amount,
        offset: 0,
        increment: 1,
    })
    const results = qgGenerate({
        answers: answers,
        key: 'equations',
        related: 'exponents',
    })
    clip(results)
}
module.exports.creator = creator

//console.log(convertifyExponent(2, 4))
//console.log(exponentQuestionFromLinear('3x - 3 = 4'))

function alternate(a, b, amount = 2) {
    const store = []
    for (let i = 0; i < Math.floor(amount * 0.5); i++) {
        store.push(a)
        store.push(b)
    }
    if (isOdd(amount)) {
        store.push(a)
    }
    return store
}

s_for_alanparser_hopefully = `
page
    header
        title
        instructions

    body
        questions
            data: {
                return [1,2,3]
            }
            style: {
                outline = red
            }
        letter-table
        answer-array
            style: {
                flex = row
                border = 1
            }

        style: {
            grid = ab/cc
        }

    footer
        name = student.name
        date = 1
        pagenumber = 1

`

//var {
//NodeArgParser
//} = require('./node-utils.js')
//console.log((new NodeArgParser()).toJSON())
//

class NiceDivisible {
    constructor() {}
}
//console.log((new NiceLinear).generate(new MathContext))

s = `What is the remainder when $divideEnd is divided by $divisor?
`

const questions0811 = [
    {
        question:
            'What is the remainder when $1 is divided by $2?',
        answer(remainder, context) {
            let [quotient, divisor] =
                context.numbergen.create(2)
            let divideEnd = divisor * quotient + remainder
            return [divideEnd, divisor]
        },
    },

    {
        question:
            'The remainder when $1 is divided by $2 is how much more than the remainder when $3 is divided by $4?',
        answer(difference, context) {
            let [a, d, r, a2, d2] = context.numbergen.create(5)
            let remainder = r + difference
            if (remainder > d) return
            let A = a * d + remainder
            let B = d
            if (A % B == 0) return
            let C = a2 * d2 + r
            let D = d2
            if (r > d2) return
            //console.log({remainder, d, d2, r})
            if (C % D == 0) return
            //console.log( [A, B, C, D]); throw "";
            return [A, B, C, D]
        },
    },

    {
        question:
            'The price of milk has increased by $1%. The original price was $$2. What is the new price?',
        answer(price, { numbergen }) {
            const percentIncrease = numbergen.create(
                1,
                'percents'
            )
            const newPrice = solveForPercentChange(
                price,
                percentIncrease
            )
            if (isLongDecimal(newPrice)) return
            return [percentIncrease, newPrice]
        },
    },

    {
        question:
            "Shoes are on sale at Tom's shoe store by $1%. If Sally pays $$2 for her purchase, what was the original price of the shoes before the discount?",
        answer(price, { numbergen }) {
            const percentDiscount = numbergen.create(
                1,
                'percents'
            )
            const newPrice =
                (price * (100 - percentDiscount)) / 100
            if (isLongDecimal(newPrice)) return
            return [percentDiscount, newPrice]
        },
    },

    {
        question: 'The average of $1 numbers: [$numbers] is',
        //difficulty: 0,
        answer(average, context) {
            let n = context.numbergen.create(1, 'listSize')
            let total = average * n
            let numbers = divyUp(total, n)
            return [[n], [numbers.join(', ')]]
        },
    },
    {
        question:
            'The average of $1 numbers is $2. When a ${ordinal($1 + 1)} number is added to the list, the average $decreases by $3. What is the new number that was added?',
        answer(newNumber, { numbergen }) {
            const n = rng(3, 10)
            const numbers = numbergen.create(n, 'any')
            const average = new MathAverage(numbers)
            average.push(newNumber)
            if (!average.assert()) return
            const d3 = average.compare('delta')
            const base = average.baseAverage
            return [[n, base, d3.delta], [d3.word]]
        },
    },

    {
        //only: 1,
        difficulty: 10,
        question:
            'A list of $0 numbers has an average value of $1. When the first number is removed from the list, the average $decreases by $2. If instead the last number is removed from the list, the average $decreases by $3. How much $larger is the first number compared to the last number?',
        answer(difference, context) {
            return []
            let number0 = context.numbergen.create(1)
            let number10 = plusOrMinus(number0, difference)
            let l6 = increaseOrDecrease(
                number0,
                number10,
                'size'
            )
            let amount = rng(4, 7)
            let numbers = context.numbergen.create(amount)

            let average = new MathAverage(numbers)
            average.unshift(number0)
            average.push(number10)

            numbers.unshift(number0)
            numbers.push(number10)
            let avg = math.average(numbers)
            let avg2 = math.average(numbers.slice(1))
            if (!isInteger(avg2)) return
            let avg3 = math.average(numbers.slice(0, -1))
            if (!isInteger(avg3)) return
            let d4 = increaseOrDecrease(avg, avg2)
            let d5 = increaseOrDecrease(avg, avg3)
            let dec1 = Math.abs(avg - avg2)
            let dec2 = Math.abs(avg - avg3)
            return [
                [amount, dec1, dec2],
                [d4, d5, l6],
            ]

            /*  */
        },
    },

    {
        difficulty: 2,
        question:
            'When A is divided by x, the remainder is $1. When A is divided by x - $4, the remainder is $2. What is the remainder when A is divided by $3?',
        answer(remainder, context) {
            let offset4 = rng(-3, 3)
            if (!offset4) {
                return
            }
            let [a1, r, d1] = context.numbergen.create(3)
            let d2 = d1 - offset4
            let Ans = a1 * d1 + r
            let d3 = getDivisorFromRemainder(Ans, remainder)
            if (!d3) {
                return
            }
            let R1 = r
            let R2 = Ans % d2
            //console.log({Ans, R1, R2, d1, d2, d3, remainder})
            return [R1, R2, d3, offset4]
        },
    },
]

function fooWorkingWS() {
    mixinMaster()
    //x = algebrawordquestions
    x = wordProblemTemplates
    itemgetter = itemgetterf(x)
    const config = {}
    const sheet = new Worksheet3(config)
    const values = sheet.run(x)
    console.log(values)
}

var QAMathMixin = {
    qaBraces(s, ref) {
        if (/^\d+-\d+$/.test(s)) return getNumbers(s)
        console.log('onot done')
        throw ''
    },
    qaBracket(s, ref) {
        s = this.replaceObject(s, ref)
        return eval(s)
    },

    qaVariable(s, ref) {
        return getter(s)

        function getter(s) {
            if (isObject(ref)) {
                return ref[s]
            }

            if (isNestedArray(ref)) {
                return ref[1].shift()
            }

            return ref.shift()
        }
    },
    qaDollarWord(s, ref) {
        if (s.startsWith('last')) {
            let expressions = this.mtTempRef.expressionValues
            switch (s) {
                case 'last2':
                    return getLast(expressions, -2)
                case 'last':
                    return getLast(expressions, -1)
            }
        }

        if (s == 'answer' && this.mtTempRef.answer) {
            return this.mtTempRef.answer
        }

        if (s in MathTemplaterCallableMixins) {
            return this.callable1(s)
        }

        if (isObject(ref)) {
            return ref[s]
        }

        if (isNestedArray(ref)) {
            return ref[1].shift()
        }
        if (s in DefaultMathMixins) {
            return 2
        }

        const value = ref.shift()

        if (s == 'twice') {
            switch (value) {
                case 2:
                    return 'twice'
                default:
                    return value + ' times'
            }
        }
        if (s == value) {
            console.log('s equals value ... interesting')
            /* i feel like it is for increaseDecreasers */
            return value
        }

        switch (s) {
            case 'opposite':
                increaseDecreaseRef[this.lastIDRKey][
                    opposite(this.lastIDRIndex)
                ]
            case 'moneyUnit':
                let [a, b] = randomPick(
                    Object.entries(moneyUnitRef)
                )
                console.log(value)
                return value * b + ' ' + a
            case 'cents':
            case 'dollars':
                return value + ' ' + s
            case 'fee':
            case 'charge':
                return toMoney(value)
        }

        if (isCapitalized(s) && isPlural(s)) {
            return (
                value + ' ' + pluralize(s.toLowerCase(), value)
            )
        }
        if (s in increaseDecreaseRef) {
            this.lastIDRKey = s
            switch (value) {
                case true:
                case value > 0:
                    this.lastIDRIndex = 0
                    return increaseDecreaseRef[s][0]
                default:
                    this.lastIDRIndex = 1
                    return increaseDecreaseRef[s][1]
            }
        }
        return value
    },

    qaCallable(s, ref) {
        let [caller, args] = parseCallable(s)
        args = args.map((arg) => this.replace(arg, ref))

        if (caller in CALLABLES) {
            return CALLABLES[caller](...args)
        } else {
            return this.callable1(caller, ...args)
        }
    },
    qaNumber(s, ref) {
        return runner(s)

        function getValue(b) {
            if (isNestedArray(ref)) {
                if (isNumber(b)) {
                    return ref[0][Number(b) - 1]
                } else {
                    /* possible-error due to shift */
                    return ref[1].shift()
                }
            } else if (isArray(ref)) {
                return ref[Number(b) - 1]
            } else if (isObject(ref)) {
                return ref[b]
            }
        }

        function runner(s) {
            let money
            let a
            let b
            let sign

            if (s.includes('$$')) {
                money = true
                b = s.split('$$')[1]
            } else {
                ;[a, b] = s.split('$')
                if (a) {
                    sign = a[0]
                }
            }

            let value = getValue(b)
            if (money) {
                return toMoney(value)
            }
            if (value < 0 && sign == '-') {
                return '+ ' + value * -1
            } else if (value < 0) {
                return '- ' + value * -1
            } else {
                return a + value
            }
        }
    },
}

function getDivisorFromRemainder(n, r) {
    return randomFactor(n - r)
}
function randomFactor(n) {
    if (isPrime(n)) return
    return randomPick(getFactors(n).slice(1, -1))
}

function isLongDecimal(n) {
    return len(n) > 5
}
function toMoney(value) {
    value = Number(value)
    if (value < 1) return value * 100 + ' cents'
    if (value == 1) return '1 dollar'
    if (isInteger(value)) {
        return value + ' dollars'
    }
    let [a, b] = value.toString().split('.')
    if (b.length == 1) return '$' + value + '0'
    if (b.length == 1) b = '0.' + b + '0'
    else {
        b = '0.' + b
    }
    return toMoney(a) + ' and ' + toMoney(b)
    //.map((item, i) => {
    //if (!item) return null
    //return toMoney(item)
    //}).filter(isDefined).join(' and ')
}
function solveForPercentChange(price, percent) {
    const percentage = (100 + parseFloat(percent)) / 100
    return parseFloat(price) / percentage
}
function divyUp(total, length) {
    const store = []
    for (let i = 0; i < length - 1; i++) {
        const value = rng(1, total - length)
        total -= value
        store.push(value)
    }
    store.push(total)
    return store
}
function plusOrMinus(n, difference) {
    return coinflip() ? n + difference : n - difference
}
function increaseOrDecrease(a, b, key = 'increase') {
    let index
    if (arguments.length == 2) {
        key = b
        if (isNumber(a)) {
            index = a > 0 ? 0 : 1
        } else {
            index = a ? 0 : 1
        }
    } else {
        index = a > b ? 0 : 1
    }
    return increaseDecreaseRef[key][index]
}

var DefaultMathMixins = {
    peekaBoo(s) {
        return '$peekaBoo'
    },
}

function active0812a(questions = questions0811, o = {}) {
    announcement()
    classMixin(MathTemplater3, QAMathMixin)
    const sheet = new Worksheet4()
    const value = sheet.run(questions, o)
    sheet.value = value
    //console.log(value)
    console.log({ countStore: sheet.mainRunner.countStore })
    return sheet
}

function degreeMeasure(angle, { mode = 'sin' } = {}) {
    const radians = toRadians(angle)
    const value = Math[mode](radians)
    return trigRound(value)
}

function radianMeasure(n) {
    return
}

//console.log(degreeMeasure(45))

function toRadians(angle) {
    return (angle * Math.PI) / 180
}

function toDegrees(radians) {
    return (radians * 180) / Math.PI
}
function trigRound(number, decimals = 5) {
    return (
        Math.round(number * Math.pow(10, decimals)) /
        Math.pow(10, decimals)
    )
}
function oscillator(
    amount = 10,
    { from = 1, to = 3, increment = 1 } = {}
) {
    let direction = 1
    let lowerLimit = from
    let upperLimit = to
    let n = lowerLimit

    if (from > to) {
        direction = -1
        lowerLimit = to
        upperLimit = from
        n = upperLimit
    }

    let store = []

    function go(s) {
        let inc = increment * direction
        store.push(n)
        n += inc
    }
    for (let i = 0; i < amount; i++) {
        go()
        if (n >= upperLimit) direction = -1
        else if (n <= lowerLimit) direction = 1
    }
    return store
}
//console.log(oscillator(10, {from: 1, to: 3, increment: 2}))

function mtMixin() {
    classMixin(Numbergen, UtilityMixins)
    classMixin(
        MathTemplater3,
        QAMathMixin,
        MathTemplaterMixins,
        UtilityMixins,
        mathTemplaterHelperFunctions,
        HTMLTemplaterMixins
    )
}

//mtMixin()
//const mt = (new MathTemplater3(null, {regexKey: 'qaMath'}))
//console.log(mt.replace('hi $abc $def $1 ${ordinal($1 + $2 + 4)} $dfgdfg', [[1, 2], ['a', 'b', 'b']]))

function isArrayOrObject(x) {
    const name = getConstructorName(x)
    return ['Array', 'Object'].includes(name)
}

function nextf(items) {
    if (!items) return
    let count = 0
    return function lambda() {
        return items[count++]
    }
}
class MathAverage {
    constructor(numbers) {
        this.store = []
        if (numbers) {
            this.numbers = numbers
            this.baseAverage = math.average(numbers)
        }
    }
    setTarget(average) {
        this.numbers = numbersAroundMean(average)
        if (!this.numbers) return
        this.baseAverage = average
        return true
    }
    pop(key) {
        for (let i = 0; i < this.numbers.length; i++) {
            let n = this.numbers[i]
            if (n < 1) continue
            let arr = copy(this.numbers)
            let popped = arr.splice(i, 1)
            let avg = math.average(arr)
            if (isInteger(avg)) {
                this.numbers = arr
                return popped[0]
                return arr
            }
        }
        return
    }
    assert(condition = isInteger) {
        return (
            condition(this.baseAverage) &&
            this.store.every(condition)
        )
    }
    getValue() {
        const value = math.average(this.numbers)
        this.store.push(value)
        return value
    }
    compare(key = 'delta') {
        return smallify(
            this.store.map((average) => {
                const args = [this.baseAverage, average, key]

                const word = increaseOrDecrease(...args)
                const delta = Math.abs(
                    this.baseAverage,
                    average
                )

                return {
                    word,
                    delta,
                }
            })
        )
    }
    push(n) {
        this.numbers.push(n)
        this.getValue()
    }
}
function getLast2(a) {
    /* legit */
    return a.slice(-2)
}
//console.log(getLast2(['a', 'b', 'c', 'd', 'e'])); throw '';

function valueTransform(value, transform) {
    /* legit */
    if (!transform) {
        return value
    }
    if (isString(transform)) {
        return value[transform]
    }
    if (isFunction(transform)) {
        return transform(value)
    }
}
function repeatUntilFactory(config = {}) {
    /* legit */
    let countStore = []
    let limit = config.limit || 100
    let checkpoint = config.condition || isDefined
    if (config.endingArgs && !isArray(config.endingArgs)) {
        config.endingArgs = [config.endingArgs]
    }

    if (config.startingArgs && !isArray(config.startingArgs)) {
        config.startingArgs = toArray(config.startingArgs)
    }
    //console.log(config); throw '';

    function getValue1(fn, ...args) {
        return fn(...args)
    }

    function getValue2(fn, ...args) {
        return fn(...args, ...config.endingArgs)
    }

    function getValue3(fn, ...args) {
        return fn(...config.startingArgs, ...args)
    }

    function getValue4(fn, ...args) {
        return fn(
            ...config.startingArgs,
            ...args,
            config.endingArgs
        )
    }

    function onEnd() {
        if (config.onError) {
            config.onError()
        }
        if (config.throw) throw ''
    }

    function onError(e, fn, args) {
        console.log({ e: e.stack, fn, args })
        throw 'handle-error'
    }

    function onDebug(count, args) {
        if (config.debug) {
            if (count > 50) {
                console.log('ERROR COUNT:', count)
                console.log('ARGS:', args)
            }
            countStore.push(count)
        }
    }

    let getValue =
        config.endingArgs && config.startingArgs
            ? getValue4
            : config.endingArgs
            ? getValue2
            : config.startingArgs
            ? getValue3
            : getValue1

    if (config.runner) {
        console.log(config.runner, 'RUNNER')
        function lambda(...args) {
            /* config.runner is bound in a separate place */
            return gambda(config.runner, ...args)
        }

        lambda.countStore = countStore
        return lambda
    }
    if (config.state) {
        const key = config.key
            ? config.key
            : config.state.run
            ? 'run'
            : config.state.run
            ? 'run'
            : 'getValue'

        const _fn = config.state[key].bind(config.state)
        console.log('return urning state malbmda')
        function lambda(...args) {
            return gambda(_fn, ...args)
        }

        lambda.countStore = countStore
        return lambda
    }
    function lambda(fn, ...args) {
        return gambda(fn, ...args)
    }
    function gambda(fn, ...args) {
        let count = 0
        let value
        while (count++ < limit) {
            try {
                value = getValue(fn, ...args)
            } catch (e) {
                if (isNerdError(e)) {
                    continue
                }

                if (config.continueOnError) {
                    console.warn('continue on error')
                    continue
                }
                onError(e, fn, args)
            }

            if (checkpoint(value)) {
                onDebug(count, args)
                return value
            }
        }

        onDebug(count)
        return onEnd()
    }
    lambda.countStore = countStore
    return lambda
}

//

function toLambda(x) {
    if (isRegExp(x)) {
        return testf(x)
    }
}
const regexsuper = {
    w: '(\\w+)',
    //'S': '\\S+',
    //'w': '\\w+',
    //'w': '\\w+',
    //'w': '\\w+',
}
function runf(tests, options = {}) {
    function f(x) {
        if (isFunction(x)) {
            return x
        }
        if (isRegExp(x)) {
            let ref = regexsuper
            let s = reStr(x)
            s = rescape(s, '[()]')
            s = s.replace(/\$(\w+)/g, (_, key) => {
                return ref[key]
            })
            return matchf(RegExp(s))
        }
    }
    const partitions = options.partitions || 2
    const g =
        partitions == 2
            ? atFirst(f)
            : ([a, b, c]) => {
                  const fa = f(a)
                  const fb = (x) => {
                      return {
                          type: b,
                          value: c && c(x),
                      }
                  }
                  /* fa and fb are functions */
                  return [fa, fb]
              }
    const tests2 = partition(tests, partitions).map(g)
    return function lambda(item, i) {
        for (let [a, b] of tests2) {
            let m = a(item)
            if (m) {
                if (m === true) return item
                return b(m)
            }
        }
    }
}

/*
 * To see two friends laugh.
 * To do it with friends.
 * To be the type that I am looking for.
 * Read Math Stories with Kids
 * Try a story ...
 * */

function active0812() {
    /*
     * it is essentially creating a new language
     * reads math.txt
     * turns the text into functions
     * works sometimes ...
     * but there is already a much better solution
     * which is the cog3runner and doing it with nerdamer
     *
     * */
    const dollarRE = /\$(\w+)/g

    let numbergen
    let dollars

    function runner1(s) {
        let vars = unique(dollars, numbergen)
        let r = RegExp(boundary(reWrap(vars)))
        //console.log({r, s}); throw ""
        let m = search(r, s)
        if (m) {
            if (s.startsWith(m)) {
                return 'let ' + s
            }
            return 'let ' + solveForVarRearrangement(m, s)
        } else if (/^\w+ = /.test(s)) {
            return 'let ' + s
        } else {
            return s
        }
    }

    const p = runf(
        [
            /^assert (.+)/,
            (x) => `if (!(x)) return `,
            /$w = r()/,
            (x) => {
                numbergen.push(x)
                return
            },

            /.+/,
            runner1,
        ],
        [
            /^average = .+/,
            (x) => x + '\n' + 'if (!isInteger(average)) return',

            /* run it twice */
        ]
    )
    function parse(q, a) {
        numbergen = []
        dollars = findall(dollarRE, q)
        //console.log(dollars, 'hhhhhhh')
        const lines = linegetter(a)
        const result = lines.map(p).filter(isDefined)
        const type = getMathQuestionType(q)
        if (exists(numbergen)) {
            const numbergenString = createVariable(
                numbergen,
                `context.numbergen.create(${numbergen.length}, '${type}')`
            )
            result.unshift(numbergenString)
        }
        const returnString = `return [${dollars.join(', ')}]`
        result.push(returnString)
        const output = join(result)
        return output
        console.log(output)
        throw ''
    }
    s = read('math.txt')
    s = removeComments(s)
    s = del(/^--+/gm, s)
    function f(s) {
        let count = 1
        return s.replace(dollarRE, (x) => '$' + count++)
    }
    function g(a, b) {
        return toFunction({
            name: 'answer',
            args: ['answer', 'context'],
            body: parse(a, b),
            mode: String,
            form: 'dict',
        })
    }
    const items = partition(split(s, /(^.+?\?(?:\n|$))/m))
    const items2 = items.map(([a, b]) => {
        return [f(a), g(a, b)]
    })
    const items3 = items2.map(([question, answer]) => {
        return (
            '{' +
            newlineIndent(
                `question: "${question}",\n${answer}`
            ) +
            '}'
        )
    })
    return `[${newlineIndent(items3.join(',\n\n'))}]`
}

//console.log(Math.pow(10, -1)); throw '';
//const nerdamer = require("nerdamer/all.min")

function solveForVarRearrangement(targetVar, s) {
    if (typeof nerdamer == 'undefined') {
        nerdamer = require('nerdamer/all.min')
    }

    let r = /\(([^()]+)\)\^\(([^()]+)\)/g
    let parser = (_, a, b) => {
        return stringcall('Math.pow', a, b)
    }
    s = nerdamer(s).solveFor(targetVar).toString()
    s = s.replace(r, parser)
    return targetVar + ' = ' + s
}

function checkjs(s) {
    try {
        require('./pretty.js').prettify(s, 'js')
        return s
    } catch (e) {
        console.log(e)
        throw ''
    }
}
//console.log([].push('3')); throw '';
function getMathQuestionType(s) {
    return 'default'
}

function numbersAround(n) {
    const store = map(rng(4, 8), () => rngAround(n))
    return store
}

cog = [
    {
        question: '\\frac{$a}{$b} = \\frac{x}{$f} + $e',
    },
    {
        skip: 1,
        question:
            'Lucy scored $scores on her first $n math exams. What combined score must Lucy obtain for her next $m exams to have an average of exactly $average?',
        answer(answer, context) {
            const scores = numbersAround(answer)
            const scores2 = numbersAround(answer, 3)
            /* it is hard to think about */
            const n = scores.length
            let avg = math.average(scores.concat(answer))
            console.log({ avg, scores })
            if (!isInteger(avg)) return
            return {
                n,
                scores: scores.join(', '),
                average: avg,
            }
        },
    },

    {
        question:
            'Lucy scored $scores on her math exams. What score must Lucy obtain on the next exam to have an average of exactly $average?',
        answer(answer, context) {
            const scores = numbersAround(answer)
            let avg = math.average(scores.concat(answer))
            if (!isInteger(avg)) return
            return { scores: scores.join(', '), average: avg }
        },
    },
    {
        skip: 1,
        question:
            'How many #numberCondition integers are there from $a to $b #inclusive?',
        answer(answer, context) {
            const n = context.numbergen.create(1)
            const { start, end } = rangeFrom(n, {
                amount: answer,
                condition: context.hash.numberCondition,
                inclusive: context.hash.inclusive,
            })
            return [start, end]
        },
    },
    {
        question:
            'Judy is $n years $older than Carmen and $twice as old as Frances. If Frances is $f years old, how old is Carmen?',
        answer(carmenAge, context) {
            /* multiplier effects */
            const n = context.numbergen.create(1, 'any')
            let j = carmenAge + n
            if (j < 0) return
            let twice = rng(2, 6)
            let f = j / twice
            if (f < 1) return
            if (!isInteger(f)) return
            return [Math.abs(n), n, twice, f]
        },
    },

    {
        question:
            'The average of $1 numbers is $2. A new number $m is added to this group of numbers. What is the new average?',
        answer(newAverage, context) {
            const n = context.numbergen.create(1, 'min2')
            const avg = new MathAverage()
            const success = avg.setTarget(newAverage, n)
            if (!success) return
            const newNumber = avg.pop('random')
            if (!newNumber) return
            return [n - 1, avg.getValue(), newNumber]
        },
    },

    {
        question: '$zoop($a, $b)',
        answer: 'a + b',
    },

    {
        question: 'What is the $percentIncrease from $a to $b?',
        answer: '((b - a) / b) * 100',
    },
    {
        question:
            'A taxicab charges a flat fee of $fee and an additional $charge for every mile traveled. What is the price for a $c mile trip?',
        answer(price, context) {
            let [fee, b] = context.numbergen.create(2)
            if (fee >= price) {
                fee /= 100
                b /= 100
            }
            let c = (price - fee) / b
            if (!isInteger(c)) return
            return [fee, b, c]
        },
    },
    {
        skip: 1,
        question: `x is $a% #moreOrLess than $b. What is x?`,
        answer(answer, context) {
            let op = context.hash.moreOrLess
            let t = `b * (100 ${op} a) / 100`
            let numbers = contextSolver(answer, t, context)
            return numbers
        },
    },

    {
        skip: 1,
        source: 'SAT',
        question:
            'Two similar triangles have areas in the ratio of $1:$2. The perimeter of the $smaller triangle is $3. What is the perimeter of the $opposite triangle?',
        answer(answer, context) {
            const [a, b] = context.numbergen.create(2)
            const k = math.square(b / a)
            if (!isInteger(k)) return
            const smbig = coinflip()
            const peri = smbig ? answer / k : answer * k
            if (!isInteger(peri)) return
            return [a, b, peri, smbig]
        },
    },
    {
        skip: 1,
        //type: 'absolute vlaue',
        question: 'x > $1 and < $2',
        answer(answer, context) {
            //5 3/7
            //6 4/7
        },
    },
    {
        detail: 'This can be written with the solver.',
        question: '$n = $m/10^x',
        answer(answer, context) {
            let n = rng(101, 999)
            let m = n * math.exp10(answer)
            return [n, m]

            k = rng(3, 5)
            n = n / math.exp10(k)
        },
    },
    {
        skip: 1,
        question:
            'How many different ways can you make exactly $$cents using only nickels, dimes, and, quarters?',
        answer(answer, context) {
            let numbers = shuffle(
                range(rng(10, 20, rng(300, 500)))
            )
            for (let i of numbers) {
                const possibles = coinCombinations(i)
                if (possibles == answer) {
                    return [i]
                }
            }
            return ['err']
        },
    },
    {
        //only: 1,
        question: [
            '$a is what percent of $b?',
            'What percent of $b is $a?',
        ],
        answer: '100 * a/b',
    },
    {
        question:
            'If $a apples are $b dollars, how many apples can you buy for $d dollars?',
        answer: 'd * a/b',
    },
    {
        precursor() {
            const args = this.numbergen.create(3).concat('x')
            const value = latex.proportion(...shuffle(args))
            return value
        },
    },
    {
        question: '$a/$b//$c/$d = $e/$f//$g/$h',
        answer(answer, context) {
            return [randomPick([4, 8])]
        },
    },

    {
        skip: 1,
        question:
            '$a students have gym in the morning. There are $b students total. What percent of students dont have gym in the morning?',
        answer: '100 * (b - a) / b',
    },
]
const CALLABLES = {
    ...latex,
    zoop(a, b) {
        return latex.add(a, b)
    },
}

//const sx = shuffle(x.map((x) => x.question)).join('\n\n\n\n')
//clip(sx)

function eitherOr(a, b) {
    if (isArray(a)) {
        return coinflip() ? a : reverse(a)
    }
    return coinflip() ? a : b
}
class LatexTree {
    setOperations(ops) {
        const ref = {
            '*': 'multiply',
            '+': 'add',
            '-': 'subtract',
            '/': 'divide',
        }

        this.operations = ops.map((op, i) => {
            op = ref[op] || op
            return latex[op]
        })
    }
    constructor(config = {}) {
        this.f = config.f
        this.setOperations(config.operations || ['+', '-'])
    }
    get() {
        return this.f ? this.f() : this.numbergen.random()
    }

    run(n, depth = 0) {
        if (n < 2) return this.get()
        n = Math.round(n)

        const modes = eitherOr(
            ['floor', 'ceil'],
            ['ceil', 'floor']
        )
        const cuts = rng(2, 3)
        const childTrees = modes.map((mode, i) => {
            let m = Math[mode](n / cuts)
            return this.run(m, depth + 1)
        })

        const operation = randomPick(this.operations)
        return this.create(childTrees, {
            depth,
            operation,
        })
    }

    create([left, right], config) {
        return new LatexTreeNode(left, right, config)
    }
    generate(n = 4) {
        const value = this.run(n).toString()
        return value
    }
}

class LatexTreeNode {
    constructor(left, right, config) {
        this.left = left
        this.right = right
        Object.assign(this, config)
    }
    toString() {
        const left = this.left.toString()
        const right = this.right.toString()
        console.log([left, right])
        return this.operation(left, right)
    }
}

//runClass(LatexTree, 3)

function numbersAroundMean2(mean, n, range) {
    let total = 0
    for (let i = 0; i < n; i++) {
        let value = rng(range)
        total += value
    }
}
function numbersAroundMean(mean, { n = 5, sd = 4 } = {}) {
    const list = map(n, partial(rng))
    const AVG = math.average(list)
    const SD = math.stdev(list)

    const f = (n) => Math.round((sd * (n - AVG)) / SD + mean)
    const newNumbers = list.map(f)
    let avg = math.average(newNumbers)
    let delta = avg > mean ? -1 : 1
    if (avg != mean) return
    return newNumbers
}
//console.log(addDecimals(2))
//decimalify(s)

fm1tests = `
    2/3^x
    //aem * aen=ae[mpn]
    //(a^m)^n = ae[mn]
    //(ab)en = aenben
    //a/ben = aem/ben
    //(ab)en = aen * ben
    //ae[-n] = 1/aen
    //ae[fracmn]=nrtaem

    //xe-1 = 3 and ye-1 = 9. Find (x+y)e-1/2
    //(2^{x+1})^{-4} = 1/64. Find x.
    //16^1/2 * 256^3/4 =
    //6rtxe4 * 4rtxe6 =
    //If xe-1/2 = 1/8, what is the value of xe2/3?
    //If 10ek = 64, what is the value of 10^{\\frac{k}{2} + 1}?
    //(2rs)e-1 = 3se-2. Find r/s.
`
function testsuite2(f, s) {
    const items = linegetter(s)
    const value = items.map((item, i) => {
        let display = f(item)
        return JSON.stringify(display)
        return [item, f(item)]
    })
    console.log(value)
}

class MathPercentage {
    constructor() {}
    generateFrom(answer) {}
}

/*
 * ugh ... the difficulties ...
 *
 * */

//nihan hw
// percents
// averages
// averages
// there is a hardness threshold and the work stops the moment we cross that threshold
// the appearance of certain things.
// the key is templates... the absolute key is templates
//10% of 10 is what percent of 20?

//10% of 5 equals?
//8 is what percent of 20?
//What percent of 20 is 8?
//A dynamic question set up.

//Everything comes from this direction?
//Maybe.

//testsuite2(fixMath, fm1tests)

function coinCombinations(sum, vals = [5, 10, 25]) {
    if (sum < 0) {
        return 0
    }
    if (vals == null || vals.length == 0) {
        return 0
    }

    let dp = map(sum + 1, () => 0)
    dp[0] = 1
    for (let i = 0; i < vals.length; ++i) {
        for (let j = vals[i]; j <= sum; ++j) {
            dp[j] += dp[j - vals[i]]
        }
    }
    return dp[sum]
}
//console.log(coinCombinations(7, [1, 5, 25]))

function solveForTwoNumbers(template) {
    /* what percent of 40 is 8 */
    ;(8 / 40) * 100
    percentage = (a * 100) / b
}

/* algebraic combination */
/* (3x - 2) + (-3 - 5x) */

//Cannot correct Nihan. You can do it like that ... but you might make a mistake. No idea.

function identical(A, B) {
    return A.every((x, i) => B[i] == x)
}

function getQuestionTypeFactory(s) {
    const t = [
        'algebra-fractions',
        'algebra-linear',
        'algebra-exponent',
        'fractions',
        'proportions',
        /at this rate/,
        'percents',
        /percent|percentage/,
        'ratios',
        'decimals',
        'conversions',
        'patterns',
        'table',
        'mean',
        /mean|average/,
        'median',
        /median/,
        'counting',
        /count|pizza/,
        'distance',
        /taxi/,
        'probability',
        /chance/,
    ]

    const f = (x) => testf(reWrap(reStr(x), { boundary: 1 }))
    const tests = partition(t).map(atSecond(f))

    return function lambda(item) {
        let s = item.question ? item.question : item
        for (let [a, b] of tests) {
            if (b.test(s)) return a
        }
    }
}

var cog2 = [
    {
        skip: 1,
        question:
            'The ratio of prime numbers to odd numbers from $a to $b is',
        answer(answer, context) {
            const odd = range(a, b).filter(isOdd).length
            const prime = range(a, b).filter(isPrime).length
            return mhsr(prime, odd)
        },
    },
    {
        precursor() {
            const value = this.latexTree.generate(3)
            return value
        },
    },
    { question: '$a + $c * x = $b' },
    { question: '2^x = 4^$a' },
    {
        skip: 1,
        question: 'If $a/$b of $x is $c, what is $d/$e of $y?',
        answer(answer, context) {
            const [a, b, c, d, e] =
                context.numbergen.createAnswer(
                    answer,
                    '(d * c * b) / (e * a)'
                )

            let x = 'X'
            let y = 'X'

            return { a, b, c, d, e, x, y }
        },
    },
]

function getDollars(s) {
    return findall(/\$(\w+)/g, s)
}

function isJsonParsable(s) {
    return /^[{\[]/.test(s) && /^[\]\}]/.test(s)
}

function isChinese(s) {
    let r = /[\u4e00-\u9fa5]/
    return r.test(s)
}
class Timestamp {
    toString() {
        return this.s
    }
    constructor(s) {
        this.s = s
        let numbers = getNumbers(s)
        if (numbers) {
            ;[this.hours, this.minutes, this.seconds] = numbers
        }
    }
    getTime() {
        return (
            this.hours * 3600 + this.minutes * 60 + this.seconds
        )
    }
    closeTo(other) {
        return (
            this.hours == other.hours &&
            this.minutes == other.minutes &&
            delta(this.seconds, other.seconds) < 3
        )
    }
}

function preParseMath(s) {
    s = fixAbsoluteValue(s)
    s = fixFactorial(s) /* 5!4! => 5! * 4! */
    s = fixMultiplication(s) /* 3a => 3 * a */
    s = fixExponentNegatives(s) /* -3^4 => (-3)^4 */
    s = removeEndingEquals(s) /* 2 + 2 =  => 2 + 2 */
    return s
}

///* the children ... measured into it.  */
//math
//console.log(loremer2())
//1 + 9
//2 + 8
//3 + 7
//4 + 6
//5 + 5

function groupMath({
    answer = 20,
    amount = 20,
    mode = 'addition',
} = {}) {
    switch (mode) {
        case 'addition':
            return addition(answer, amount)

        case 'subtraction':
            return subtraction(answer, amount)
    }

    function addition(
        answer = 16,
        amount = 10,
        from = 0,
        inc = 1
    ) {
        return map(amount - 1, (x) => {
            return mhsa(from + answer - x, x + from)
        }).filter((x, i) => {
            return i % inc == 0
        })
    }

    function subtraction(answer = 10, amount = 10, inc = 1) {
        let from = answer
        return map(amount, (x) => {
            return mhss(n + x + from, x + from)
        }).filter((x, i) => {
            return i % inc == 0
        })
    }
}

//console.log(groupMath())

/*** 08-17-2022 ***/
function colSafe(a, c, n) {
    return !a.some((row) => row[c[1]] === n)
    //return a.someRowIncludes()
}

function boxSafe(a, c, n) {
    return true
    let length = Math.sqrt(a)
    if (!isInteger(length)) return true

    let startRow = c[0] - (c[0] % length)
    let startCol = c[1] - (c[1] % length)

    let safe = true
    for (row of numbers) {
        for (col of numbers) {
            if (a[startRow + row][startCol + col] == n) {
                safe = false
            }
        }
    }
    return safe
}

function rowSafe(a, c, n) {
    return a[c[0]].indexOf(n) === -1
}

function safeToPlace(puzzleArray, emptyCell, num) {
    return (
        rowSafe(puzzleArray, emptyCell, num) &&
        colSafe(puzzleArray, emptyCell, num) &&
        boxSafe(puzzleArray, emptyCell, num)
    )
}

const pokeHoles = (
    startingBoard,
    holes,
    numArray,
    errorLimit
) => {
    const removedVals = []
    const rowLength = numArray.length

    while (removedVals.length < holes) {
        const val = rng(1, math.square(rowLength))
        const randomRowIndex = Math.floor(val / rowLength)
        const randomColIndex = val % rowLength

        if (!startingBoard[randomRowIndex]) continue // guard against cloning error
        if (startingBoard[randomRowIndex][randomColIndex] == 0)
            continue // If cell already empty, restart loop

        removedVals.push({
            // Store the current value at the coordinates
            rowIndex: randomRowIndex,
            colIndex: randomColIndex,
            val: startingBoard[randomRowIndex][randomColIndex],
        })
        startingBoard[randomRowIndex][randomColIndex] = 0 // "poke a hole" in the board at the coords
        const proposedBoard = startingBoard.map((row) =>
            row.slice()
        ) // Clone this changed board

        // Attempt to solve the board after removing value. If it cannot be solved, restore the old value.
        // and remove that option from the list
        if (!fillPuzzle(proposedBoard, numArray, errorLimit)) {
            startingBoard[randomRowIndex][randomColIndex] =
                removedVals.pop().val
        }
    }
    return [removedVals, startingBoard]
}

/*--------------------------------------------------------------------------------------------
--------------------------------- Initialize -------------------------------------
--------------------------------------------------------------------------------------------*/

newSolvedBoard = (_) => {
    const newBoard = this.BLANK_BOARD.map((row) => row.slice()) // Create an unaffiliated clone of a fresh board
    return newBoard
}

function multiplePossibleSolutions(boardToCheck) {
    const possibleSolutions = []
    const emptyCellArray = emptyCellCoords(boardToCheck)
    for (
        let index = 0;
        index < emptyCellArray.length;
        index++
    ) {
        // Rotate a clone of the emptyCellArray by one for each iteration
        emptyCellClone = [...emptyCellArray]
        const startingPoint = emptyCellClone.splice(index, 1)
        emptyCellClone.unshift(startingPoint[0])
        thisSolution = fillFromArray(
            boardToCheck.map((row) => row.slice()),
            emptyCellClone
        )
        possibleSolutions.push(thisSolution.join())
        if (Array.from(new Set(possibleSolutions)).length > 1)
            return true
    }
    return false
}

// This will attempt to solve the puzzle by placing values into the board in the order that
// the empty cells list presents
function fillFromArray(startingBoard, emptyCellArray) {
    const emptyCell = nextStillEmptyCell(
        startingBoard,
        emptyCellArray
    )
    if (!emptyCell) return startingBoard
    for (num of shuffle(numArray)) {
        pokeCounter++
        if (pokeCounter > 60000000)
            throw new Error('Poke Timeout')
        if (safeToPlace(startingBoard, emptyCell, num)) {
            startingBoard[emptyCell.rowIndex][
                emptyCell.colIndex
            ] = num
            if (fillFromArray(startingBoard, emptyCellArray))
                return startingBoard
            startingBoard[emptyCell.rowIndex][
                emptyCell.colIndex
            ] = 0
        }
    }
    return false
}

// As numbers get placed, not all of the initial cells are still empty.
// This will find the next still empty cell in the list
function nextStillEmptyCell(startingBoard, emptyCellArray) {
    for (coords of emptyCellArray) {
        if (startingBoard[coords.row][coords.col] === 0)
            return {
                rowIndex: coords.row,
                colIndex: coords.col,
            }
    }
    return false
}

// Generate array from range, inclusive of start & endbounds.
// Get a list of all empty cells in the board from top-left to bottom-right
function emptyCellCoords(startingBoard) {
    const listOfEmptyCells = []
    for (const row of range(0, 8)) {
        for (const col of range(0, 8)) {
            if (startingBoard[row][col] === 0)
                listOfEmptyCells.push({ row, col })
        }
    }
    return listOfEmptyCells
}
//console.log(range(3, 44))
function copyBoard(x) {
    return JSON.parse(JSON.stringify(x))
}
function getHoles(size, difficulty) {
    const ref = {
        'easy-2': 2,
        'easy-3': 3,
        'easy-4': 4,
        'easy-5': 5,
        'easy-6': 6,
        'easy-7': 7,
        'easy-8': 8,
        'easy-9': 9,
        'medium-2': 2,
        'medium-3': 3,
        'medium-4': 4,
        'medium-5': 5,
        'medium-6': 6,
        'medium-7': 7,
        'medium-8': 8,
        'medium-9': 9,
        'hard-2': 2,
        'hard-3': 3,
        'hard-4': 4,
        'hard-5': 5,
        'hard-6': 6,
        'hard-7': 7,
        'hard-8': 8,
        'hard-9': 9,

        //'hard-9': 9,
        //9 2 3 4 5 6 7 8 9
    }
    return ref[difficulty + '-' + size]
}

class SudokuBoard {
    constructor(size, holes) {
        this.k = 0.65
        if (holes && holes < 1) {
            this.k = holes
            holes = null
        }
        this.size = size || 3
        this.holes = holes ||
            Math.floor(math.square(this.size) * this.k)
        //console.log(this.holes); throw '';
        this.numbers = range(this.size)

    }

    toString(board) {
        if (!board) board = this.board
        const value = board.map((x) => {
            return x.map(y => (y.hole ? 'X' : y.value)).join('|')
        })
        console.log(stringify(value))
        return value
    }

    getNextAvailable() {
        for (let i = 0; i < this.board.length; i++) {
            let row = this.board[i]
            let j = row.findIndex((x) => x === 0)
            if (j < 0) continue
            return [i, j]
        }
    }
    safeToPlace(n) {
        return (
            rowSafe(this.board, this.nextPos, n) &&
            colSafe(this.board, this.nextPos, n) &&
            boxSafe(this.board, this.nextPos, n)
        )
    }
    getNumbers() {
        return shuffle(this.numbers, true)
    }

    run() {
        do {
            this.board = createBoard(this.size)
            this.fill()
            breaker(100)
        } while (!this.board || flat(this.board).includes(0))
        breaker.reset()

        const board = this.pokeHoles()
        this.toString(board)
        return board
    }

    pokeHoles() {
        const store = []
        const board = copy(this.board)
        const length = board.length * board.length
        const locations = shuffle(range(length))
        const removableIndexes = locations.slice(0, this.holes)
        //console.log({removableIndexes}); throw ""

        return mutationIteration(board, (value, i, j, index) => {
            let hole = removableIndexes.includes(index)
            return {value, hole}
        })
    }

    fill(s) {
        this.nextPos = this.getNextAvailable()
        if (!this.nextPos) return this.board
        for (let n of this.getNumbers()) {
            if (this.safeToPlace(n)) {
                this.place(n)
                if (this.fill()) return this.board
            }
        }
    }
    place(n) {
        let [x, y] = this.nextPos
        this.board[x][y] = n
    }
}
function createBoard(size) {
    return map(size, () => map(size, () => 0))
}

function findColumnIndex(board, row, f) {
    const g = isFunction(f) ? f : (x) => x === f
    return board[row].findIndex(g)
}

function boardFromAnswer(n) {
    const holes = splitIntoSmallerNumbers(n)
    const size = Math.max(...holes)
    const board = new Board(size, holes)
    return board.run()
}

function splitIntoSmallerNumbers(
    n,
    { range = [2, 5], mustHave = [] } = {}
) {
    if (n < 20) return
    let value
    store = []
    while (n > 0) {
        value = rng(range)
        n -= value
        store.push(value)
    }
    let last = store.pop()
    n += last
    store.push(n)
    for (let item of toArray(mustHave)) {
        let index = mostFrequentIndex(store)
        edit(store, index, (x) => {
            let change = delta(item, x)
            distributeChanges(store, change)
            return item
        })
    }
    return store
}
//
function mostFrequentIndex(a) {
    const best = mode(a)
    const indexes = a
        .map((item, i) => {
            return best == item && i
        })
        .filter(exists)
    return randomPick(indexes)
}
//console.log(splitIntoSmallerNumbers(30, {mustHave: 10}))
//
//

class Grid {
    constructor(n, m) {
        if (isNumber(n)) {
            this.store = map(n, () => map(m, () => 0))
        } else if (isNestedArray(n)) {
            this.store = n
        } else {
            this.store = []
            this.temp = []
        }
    }

    get height() {
        return this.store.length
    }

    get width() {
        return this.store[0].length
    }

    set(x, y, value) {
        if (!this.store[x]) {
            this.store[x] = []
        }
        this.store[x][y] = value
    }

    get(x, y) {
        return this.store[x] && this.store[x][y]
    }
    rotate(degrees) {
        const grid = new Grid()
        for (let i = 0; i < this.width; i++) {
            for (let j = 0; j < this.height; j++) {
                grid.add(this.get(i, j))
            }
            grid.newline()
        }
        return grid
    }
    add(value) {
        this.temp.push(value)
    }
    newline() {
        this.store.push(this.temp)
        this.temp = []
    }
}

function foo0817(s) {
    let m = 4
    let n = 1
    let i = 0
    let j = 0

    const square = new Grid(m, m)
    m = Math.floor(n / 2)

    while (n <= m * m) {
        square.set(i, j, n)
        n += 1
        let i2 = (i - 1) % m
        let j2 = (j + 1) % m
        if (square.get(i2, j2)) {
            console.log('hi')
            throw ''
            i += 1
        } else {
            i = i2
            j = j2
        }
    }
    console.log(square)
}

function checkerboard(
    n = 20,
    width = 5,
    symbols = ['x', 'y', 'z']
) {
    const grid = new Grid()
    for (let i = 0; i < n; ) {
        for (let symbol of symbols) {
            grid.add(symbol)
            i++
            if (i % width == 0) grid.newline()
        }
    }
    return grid
}
//checkerboard(9, 6)
//console.log(grid)
//

//console.log(checkerboard())
//

var grid = [
    [0, 2],
    [0, 3],
    [1, 2],
    [1, 3],
]

function buildRotations(grid) {
    const store = []
    for (let i = 0; i < 4; i++) {
        grid = rotateMatrix(grid)
        store.push(grid)
        store.push(reverseMatrix(grid))
    }
    return store
}
function reverseMatrix(s) {
    return map(s, reverse)
}
function deepEqual(objA, objB, map = new WeakMap()) {
    // P1
    if (Object.is(objA, objB)) return true

    // P2
    if (objA instanceof Date && objB instanceof Date) {
        return objA.getTime() === objB.getTime()
    }
    if (objA instanceof RegExp && objB instanceof RegExp) {
        return objA.toString() === objB.toString()
    }

    // P3
    if (
        typeof objA !== 'object' ||
        objA === null ||
        typeof objB !== 'object' ||
        objB === null
    ) {
        return false
    }

    // P4
    if (map.get(objA) === objB) return true
    map.set(objA, objB)

    // P5
    const keysA = Reflect.ownKeys(objA)
    const keysB = Reflect.ownKeys(objB)

    if (keysA.length !== keysB.length) {
        return false
    }

    for (let i = 0; i < keysA.length; i++) {
        if (
            !Reflect.has(objB, keysA[i]) ||
            !deepEqual(objA[keysA[i]], objB[keysA[i]], map)
        ) {
            return false
        }
    }

    return true
}

function deepFind(a, f) {
    return a.find((row) => {
        return row.find(f)
    })
}

function deepMap(a, f) {
    return a.map((item, i) => {
        return item.map(f)
    })
}

function rotateGridVertical(grid) {
    grid = new Grid(grid)
    return toJSON(grid.rotate())
}
function getAdditionQuestionsFromMagicSquare(square) {
    const horo = square
    const vertical = rotateGridVertical(square)
    const items = horo
        .concat(vertical)
        .map(partial(katexVertical))
    return items
}

function easyMediumHard(key, level) {
    /* it is an arg-getter for the various level elements. */
}
const magicSquareData = {
    title: 'Magic Square',
    instruction:
        'Every row and every column in this magical square  adds up to the same number. Find the magical number!',

    data(level) {
        const width = easyMediumHard('magic-squares')
        const squares = magicSquares[width]
        const sq = rotateOrTranslate(randomPick(squares))
        return {
            square: sq,
            arithmetic: getAdditionQuestionsFromMagicSquare(sq),
        }
    },

    data(config) {
        const questions = groupMath(config)
    },
    data(s) {
        //symbolicMath(emojis, and hearts, and other)
    },

    bottomAnswerBox: 'The magic number is',
}
function rotateOrTranslate(matrix) {
    if (coinflip()) matrix = rotateMatrix(matrix)
    if (coinflip()) matrix = rotateMatrix(matrix)
    return matrix
}

ms = [
    [4, 9, 2],
    [3, 5, 7],
    [8, 1, 6],
]

function runRecursive(
    fn,
    { from = 0, to = 0, outbound = 0, targets = 0 } = {}
) {
    if (isString(fn)) {
        fn = toPiecewiseFunction(fn)
    }
    function endCondition(store, n) {
        breaker(1000)

        if (store.length < 4) return false
        if (store.includes(n)) return true
        if (store.length > 50) return true

        const [a, b, c, d] = store.slice(-4)
        if (a == c && b == d) return true
        if (a == c && b == c) return true
    }

    if (from && to) {
        return range(from, to).map(runner)
    } else if (targets) {
        return targets.map(runner)
    } else {
        return runner(rng())
    }

    function runner(n) {
        const store = []
        while (true) {
            if (endCondition(store, n)) {
                if (outbound) return outbound(store)
                return store
            }
            store.push(n)
            n = fn(n)
        }
    }
}
function reStrip(r) {
    return isString(r) ? RegExp(r) : RegExp(r.source)
}
function toPiecewiseFunction(s) {
    let r = /(\w+): *(.*?)(?=,|$)/g
    let r2 = /(\w+) *= *(.*?)(?=,|$)/g
    let regex = reStrip(r).test(s) ? r : r2
    let m = findall(regex, s)
    const ref = {
        even: isEven,
        odd: isOdd,
        prime: isPrime,
    }
    if (regex == r) {
        let f = ([a, b]) => {
            return [ref[a] || bringToLife(a), bringToLife(b)]
        }
        let tests = m.map(f)

        return function lambda(s, ...args) {
            for (let [a, b] of tests) {
                if (a(s)) {
                    return b(s, ...args)
                }
            }
        }
    } else {
        return function lambda(n, i) {}
    }
}
function threeNPlusOneOutbound(store) {
    return store.map((item, i) => {
        if (item == 1) {
            return [`${item} equals 1`, `Reached the end!`]
        }
        if (isEven(item)) {
            return [
                `${item} is even`,
                'divide by 2',
                stringMath`${item} / 2 = ${item / 2}`,
            ]
        } else {
            return [
                `${item} is odd`,
                'times 3 add 1',
                `${item} * 3 + 1 = ${item * 3 + 1}`,
            ]
            /* there should be other ways of doing this
             *
             * */
        }
    })
}

//console.log(runRecursive("even: n/2, odd: 3n + 1", {outbound: threeNPlusOneOutbound, targets: [100]}))
//console.log(stringify(isHappyNumber(7)))
//const sm = new StringMath()
//s = sm.divide(8, 4)
//console.log(s.expr())

class StringMathNode2 {
    constructor(value, display) {
        this.value = value
        this.display = display || value
    }
}
function setupStringMathNode() {
    const keys = ['add', 'subtract', 'times', 'divide']
    keys.forEach((key, i) => {
        StringMathNode2.prototype[key] = function (n) {
            const ref = StringMathRef
            const f = ref.math[key]
            const g = ref.latex[key]
            const display = g(this.display, n)
            const value = f(this.value, n)
            //const value = nerdEval(display)
            return new StringMathNode2(value, display)
            /* returns the self value */
        }
    })
}
//console.log(s2)
//console.log(runRecursive("a0 = 0, a1 = 1, an = a_n-1 + a_n-2"))
//
//
function nerdCompare(a, b) {
    try {
        return eval(a) > eval(b)
    } catch (e) {
        return nerdEval(a) > nerdEval(b)
    }
}

function nameChange(s) {
    return s
    const names = shuffle(copy(babyNames.map(capitalize)))
    return dreplace2(s, {
        Judy: names.pop(),
        Frances: names.pop(),
        Carmen: names.pop(),
    })
}
function rangeFrom(
    n,
    { inclusive = 0, amount = 10, condition = 0 } = {}
) {
    const store = []

    let start = n
    if (inclusive == 'exclusive') inclusive = 0
    let exclusive = !inclusive

    while (store.length < amount) {
        if (condition(n)) {
            store.push(n)
        }
        n++
    }
    let buffer = 0
    let end = n
    while (true) {
        n++
        if (condition(n)) {
            break
        }
        buffer++
    }
    end += rng(0, buffer)
    //console.log({store, start, end, buffer})
    //
    if (exclusive && condition(start)) start--
    if (exclusive && condition(end)) end++
    return {
        start,
        end,
        store,
    }

    //return buffer
    return store
}

//console.log(fooWorkingWS())
function getEndpoints(numbers) {
    return [numbers[0], getLast(numbers)]
}

function contextSolver(answer, template, context) {
    if (template.includes('answer')) {
        template = template.replace('answer', answer)
    } else {
        template = answer + ' = ' + template
    }

    const tally = getVariables(template, Tally)
    const [lowest, dollars] = tally.pop()
    const r = reWrap(dollars, 'rbg')
    const store = {}

    template = template.replace(r, (s) => {
        const value = context.numbergen.generate(s, 'default')
        store[s] = value
        return value
    })

    context.numbergen.clear()
    const solution = solveFor(template, lowest, identity)
    store[lowest] = solution
    return store
}

function mathf(s) {
    return bringToLife(s)
}

var options = { amounts: 3, pattern: 'pyramid' }
var options = {
    //2: [1,2,3,4,5,4,3,2,1].map(mathf('x + 40')),
    //2: [1,2,3,4,5],
    //3: [1,2,3],
    //4: [10, 20, 30, 40, 50],
    //5: [10, 20, 30, 40, 50],
    //6: [10, 20, 30, 40, 50],
    //6: [1,2,3],
    1: [1, 80, 70],
}

function unitConverter(s) {
    const numberRE = '(-?\\d+\\.?\\d*%?(?:/\\d+)?)'
    const r = reWrap(
        timeRef.map((x) => x[0]),
        numberRE + ' ($1).*?\\b($1)'
    )
    const m = search(r, s)
    if (!m) return
    let [n, a, b] = m
    let node = new MathUnitNode(n, a)
    return node.to(b)
}

const timeRefRatio = [
    '1 year = 365 days',
    '1 day = 24 hours',
    '1 hour = 60 minutes',
    '1 minute = 60 seconds',
]

const timeRef = [
    ['years', 24],
    ['days', 24],
    ['hours', 60],
    ['minutes', 60],
    ['seconds', 1],
    ['milliseconds', 1000],
]

class MathUnitNode {
    constructor(value, unit) {
        this.value = value
        this.unit = unit
    }
    toString() {
        return this.value + ' ' + this.unit
    }

    to(unit) {
        //console.log(this.unit, unit); throw '';
        const f = (x) => x[0]
        const [a, b] = findIndexes(timeRef, f, this.unit, unit)
        //console.log({a,b}); throw ""
        const dir = b > a ? 1 : -1
        const mathStore = []

        const f1 = (item, i, a) => {
            if (i == a.length - 1) return
            let num = item[1] + ' ' + a[i + 1][0]
            let den = '1' + ' ' + item[0]
            mathStore.push(item[1])
            return latex.frac(num, den)
        }

        const f2 = (item, i, a) => {
            let prior = a[i - 1] ? a[i - 1][0] : this.unit
            prior = latex.cancel(prior)
            let next =
                i == a.length - 1
                    ? item[0]
                    : latex.cancel(item[0])
            let num = '1' + ' ' + next
            let den = item[1] + ' ' + prior
            mathStore.push(latex.frac(1, item[1]))
            return latex.frac(num, den)
        }

        const store =
            dir > 0
                ? timeRef.slice(a, b + 1).map(f1)
                : timeRef.slice(b, a).reverse().map(f2)

        mathStore.unshift(this.value)
        store.unshift(
            this.value + ' ' + latex.cancel(this.unit)
        )

        const latexValue = latex.multiply(store)
        const mathValue = latex.multiply(mathStore)
        //console.log({mathValue}); throw ""
        const start = this.toString()
        const [expr, answer] = nerdExpr(mathValue)
        const decimal = nerdDecimal(answer)
        const latter = decimal
            ? `${decimal} or ${answer} of a ${depluralize(
                  unit
              )}`
            : `${answer} ${unit}`
        const statement = `${start} is the same as ${latter}.`
        return [latexValue, expr, statement]
    }
}
function nerdDecimal(s, n = 7) {
    if (isInteger(s)) return null
    return nerdamer(s).text('decimal', n).slice(1)
}
function nerdExpr(s) {
    const value = nerdConvert(s).toString()
    return [s + ' = ' + value, value]
}

var options = {
    1: [10, 20, 30, 40, 50],
    2: [20, 20, 30, 40, 50],
    3: [30, 20, 30, 40, 50],
    4: [40, 20, 30, 40, 50],
    5: [50, 20, 30, 40, 50],
    6: [60, 20, 30, 40, 50],
    7: [70, 20, 30, 40, 50],
    8: [80, 20, 30, 40, 50],
}
function mathchaCompiler(x) {
    clip(
        x
            .map((el) => {
                el = el.question
                if (hasLatex(el)) {
                    return latex.wrap(el)
                }
                return el
            })
            .join('\n\n')
    )

    /* to have a feeling of certainty.
     * is why the answer homogenization is necessary
     * Notes on how to approach it
     * Tables ...
     * super-nesters*/
}
//foo(x)

function storager(items, f) {
    const storage = new Storage()
    map(items, (x) => {
        n = f(x)
        storage.add(n, x)
    })
    console.log(storage.value)
    return storage.value
}
//storager(100, (x) => getFactors(x).length) /* gets factors */

nerd = {
    subtract(a, b) {
        return a + '-' + b
    },

    add(a, b) {
        return a + '+' + b
    },

    times(a, b) {
        return a + '*' + b
    },

    divide(a, b) {
        return a + '/' + b
    },
}

//`2 cogs is 5 bogs. 8 sos is 4 cogs. How many bogs is 2 sogs?`

function findIndexes(ref, f, ...keys) {
    return keys
        .map((key, i) => {
            const index = ref.findIndex((x) => f(x) == key)
            if (index > -1) return index
        })
        .filter(exists)
}

/* need to make a ratio function. */
//var x = nerdamer('3 + 4/5 + x/2')
//console.log(x.text('decimals'));
//console.log(x.text('decimals', 1));
//console.log(x.text('decimals', 7));
//console.log(x.text('recurring'));
//console.log(x.text('fractions'));m
//console.log(nerdamer(2).gte(1))
//console.log(nerdamer('x/2').divide(2).toTeX())
//console.log(nerdamer('(x/2) / (2)').toTeX()) /* same */

//console.log(toDictionary(alist, sayhi, saybye)); throw '';
//get it by type

function functionInfo(fn) {
    const s = fn.toString()
    const returnStatement = search(/return (.+)/, s)
    const params = getParameters(s)
    const name = getFunctionName(s)
    return {
        name,
        params,
        body: returnStatement,
        text: s,
    }
}

function showFormula(fn) {
    const name = fn.name
    const data = functionInfo(fn)
    console.log({ data })
    throw ''
    return `The formula for ${name} is ${expr}`
}
//showFormula(formulas.distance)

//2021 =
//summer 2022 = grade5

class Student extends Person {
    constructor(...args) {
        super(...args)
    }
}

var ASSIGNMENTS = [
    {
        grade: 5,
        assignments: [
            {
                name: 'theDifferentQuestion',
                args: [
                    'a + b * c + d',
                    'fooo',
                    'asdfasdfasdf',
                    'leave before then',
                ],
            },
        ],
    },
]
var STUDENTS = [
    {
        favorites: {
            food: ['donuts'],
        },
        parent: {
            phoneNumber: '123123123',
            email: null,
            fullName: 'Xu',
        },
        name: 'michelle',
        nicknames: ['Mishy'],
        teacherName: ['Miss Michelle'],
        aliases: ['mch'],
        fullName: 'Michelle Lam',
        joinDate: 2021,
        joinGrade: 4,
        level: 0,
        /* name */
        /* age */
        /* elo */
        /* calculated from questions that are attempted */
    },
    { name: 'alvin', joinDate: 2021, joinGrade: 4 },
    { name: 'hao xiang', joinDate: 2021, joinGrade: 4 },
]

function getCurrentGradeYearFromJoinDate(name) {
    const year = getYear()
    const student = STUDENTS.find((x) => test(name, x.name))
    return year - student.joinDate + student.joinGrade
}

/* fddsfsd */

//michelle
//to be super perfect

const pify = (s) => divify('p', '', s)
const input = (s) => divify('input', 'input', '')

class MathParser0820 {
    constructor() {
        this.keys = getClassMethods(this.constructor)
        this.regex = reWrap(this.keys, 'brc')
        this.text = parse(read('m.txt'))

        function parse(s) {
            return s
        }
    }

    parse123(s) {
        function propConverter(s) {
            const ref = {
                b: 'bold',
            }
            return ref[s]
        }

        const r = /(^\w+:\n[^]+?\n\n|\n)/g
        const lines = split(s, r)
        return lines.map((line, i) => {
            if (/^\w+:/.test(line)) {
                const inner = linegetter(line)
                const name = inner[0].slice(0, -1)
                return [name, inner]
            }
            const parts = split(line, /\b(b|sdf) (.*?\.)/)
            if (!exists(parts)) {
                return { type: 'linebreak' }
            }
            if (parts.length == 1)
                return {
                    type: 'prose',
                    value: parts[0],
                }
            else {
                const store = []
                let m
                for (let i = 0; i < parts.length; i++) {
                    let part = parts[i]
                    if ((m = propConverter(part))) {
                        store.push({
                            props: m,
                            value: parts[i++ + 1],
                            type: 'text',
                        })
                    } else {
                        store.push({
                            type: 'text',
                            value: part,
                        })
                    }
                }
                return smallify(store)
            }
        })
    }

    instructions(data) {
        return
        return this.parse(data)
        return {
            type: 'paragraph',
            value: data,
        }
    }

    answerbox(s) {
        let r = /(\[.*?\])/
        return split(s, r).map((item, i) => {
            let answer = item.slice(1, -1)
            answer = del('this.', answer)
            if (!answer) answer = 'answer'
            if (r.test(item))
                return { type: 'input', value: answer }
            return { type: 'text', value: item }
        })
    }
    body(s) {
        if (s) {
            return eval(fixEvalArgs(s))
        } else {
        }
    }
    run() {
        const f = ([key, b]) => {
            const value = this[key](b) || this.parse123(b)
            return [key, value]
        }

        const base = split(this.text, /^###/m).slice(0, 1)

        this.preRegex = /function [^]+?\n}/g
        const items = base.map((item, i) => {
            let [title, b] = splitonce(item, /\n+/)
            //title = capitalizeTitle(title)
            if (!/^instruction/m.test(b)) {
                b = 'instructions ' + b
            }
            let preStore
            ;[b, preStore] = mget(this.preRegex, b)
            let els = partition(split(b, this.regex))
            let children = els.map(f)
            let body = children.find((x) => x[0] == 'body')
            if (!body) {
                let el
                if (preStore) {
                    el = {
                        value: preStore[0],
                        type: 'dataFunction',
                    }
                } else {
                    let key = toCamelCase(title)
                    el = {
                        type: 'consumerFunction',
                        value: key,
                    }
                }
                body = ['body', el]
                children.splice(1, 0, body)
            }
            return [
                ['title', { type: 'title', value: title }],
                ...children,
            ]

            return {
                title,
                ...children,
            }
        })

        return items
    }

    /*
     * reads m.txt
     * partitions are via @answerbox | @body | @instructions
     * */
}

////// 08-20-2022
function arithmeticVariations(s, answer, amount = 10) {
    const length = getVariables(s).length

    const value = map(amount, () => {
        let n = rng(1, length - 2)
        let m = length - n
        let start = '\\w+ \\S '.repeat(rng(0, 2))
        let rstr = '\\w+' + '(?: \\S \\w+)'.repeat(n)
        let r = RegExp(parens(start) + parens(rstr))
        return s.replace(r, (_, a, x) => a + parens(x))
    })

    const letters = ['a', 'b', 'c', 'd'].slice(0, length)
    return value.map((item, i) => {
        return runner(item)
    })

    function runner(item) {
        const [letters2, popped] = randomPop(letters)
        const r = reWrap(letters2, 'bgr')
        const value = item.replace(r, (x) => {
            return rng(1, 10)
        })
        const expr = value + ' = ' + answer
        //console.log(expr)
        //return
        const sol = solveFor(expr, popped, isInteger)
        if (!sol || sol == 0) return runner(item)
        let v = value.replace(popped, sol)
        v = fixPlusMinus(v)
        v = moveMinusToEnd(v)
        v = beginnerNegatives(v)
        return v
    }
}
function randomPop(a) {
    let g = copy(a)
    let i = randomIndex(g)
    let el = g.splice(i, 1)[0]
    return [g, el]
}

//console.log(isInteger('-23')); throw '';
//console.log(arithmeticVariations(s))
function fixPlusMinus(s) {
    return s.replace(/\+ - */g, '- ')
}
function moveMinusToEnd(v) {
    let [a, b] = mget(/^-(.*?) \S */, v)
    if (b) return a + ' - ' + b
    return v
}
function beginnerNegatives(v) {
    return v.replace(/\+ \((\d+[ *]+)-(\d+)\)/g, (_, a, b) => {
        return `- (${a}${b})`
    })
}
function hasQuote(s) {
    return /["']/.test(s)
}
function fixStringArgs(x) {
    if (isNumber(x)) {
        return x
    }
    if (hasQuote(x)) {
        return x
    }
    return quotify(x)
}
function fixEvalArgs(s) {
    return s.replace(/\((.*?)\)/, (_, x) => {
        return parens(split(x, ',').map(fixStringArgs))
    })
}
//console.log(getCurrentGradeYearFromJoinDate('mich'))
//nerdamer = require("nerdamer/all.min")
//console.log(mathParser0820('m.txt'))

//It is hard to be grounded when you have a

const currentStudents = [
    'kloe',
    'kaylee',
    'elina',
    'mch',
    'michelle',
    'aron',
    'aaron',
    'alvin',
    'sam',
    'sara',
]

//const data2 = runClass(MathParser0820)[0]
//console.log(stringify(data2))

class ExplanationService {
    constructor() {
        classMixin(MathTemplater3, QAMathMixin)
        this.worksheet = new Worksheet4()
        this.runner = this.buildRunner()
        this.repeatUntil = repeatUntilFactory({
            continueOnError: true,
            state: this,
        })
    }
    run(s) {
        return this.repeatUntil(s)
    }
    render(s) {
        /** exp **/
        //const [a, b] = firstSecond(s)
        const a = firstLine(s)
        const item = this.worksheet.runner(a, rng())
        this.args = this.worksheet.args
        const table = tablegetter(s, this.runner, {
            1: 'vvvvv',
        })
        console.log(stringify(table))
        return table
    }
    buildRunner(s) {
        const latexParser = (s) => {
            s = this.worksheet.mt.replace(s, this.args)
            s = postFixLatexFraction(s)
            return s
        }

        const runner = function f(s) {
            if (!s.trim()) {
                return {
                    type: 'linebreak',
                    value: s.length,
                }
            }
            if (s.includes('$')) {
                return {
                    type: 'katex',
                    value: latexParser(s),
                }
            }

            return {
                type: 'prose',
                value: s,
            }
        }
        const runner2 = (s) => {
            return splitKatex0820(s).map(runner)
        }
        return runner2
    }
}

function dialogue0820(s) {
    let first
    const names = ['Sam', 'George']
    let r = reWrap(currentStudents, 'rbgi')
    let secondRef = names.pop()
    let firstRef = search(r, s) || names.pop()
    const lines = linegetter(s)
    return lines.map((item, i) => {
        let speaker = isEven(i) ? secondRef : firstRef
        speaker = capitalize(speaker)
        /* use the same parser */
        return [speaker, item]
    })
}

function demonstrator(s) {
    s = 'Convert 5 hours into seconds'
}

//console.log(dialogue0820('kloe let store = [] go.\nokay fine let store = []do it.\nyay.'))

function randomPassword(s) {
    /* 65 = A
     * 65 + 25 = Z
     * 97 = a
     * 97 + 25 = z
     * */
    //let t = Math.random().toString().slice(2)
    //let m = findall(/1[012]\d|[6789]\d/g, t).map(Number)
    //console.log({m}); throw ""
    //const value = String.fromCharCode(65 + 25)
    //console.log({value}); throw ""
    //return randomPick()
}
//randomPassword()
//write('gui.txt', join(cog.map((x) => x.question)))

function filterCog(cog) {
    let s = read('gui.txt')
    let elements
    if (/^only/m.test(s)) {
        elements = findall(/^only (.+)/gm, s)
    } else {
        elements = linegetter(s)
    }
    const items = cog.filter((x) => {
        if (isArray(x.question)) {
            return elements.some((y) =>
                y.includes(x.question[0])
            )
        }
        return elements.includes(x.question)
    })
    //console.log(items); throw '';
    return items
}

function convertToLatex(s) {
    //s = "$a/$bp3e4//$c/$d = $e/$f//$g/$h"

    if (hasProse(s)) return s
    if (!s.includes('/')) return s
    let depth = getLongest(findall(/\/+/g, s)).length
    return runner(s, depth)

    function wrap(a, b) {
        return latex.dfrac(a, b)
    }
    function parseAtom(s) {
        return fixMath(s)
    }
    function runner(s, depth) {
        if (depth == 0) {
            return parseAtom(s)
        }
        let r = `(\\S+?)${'/'.repeat(depth)}(\\S+)`
        r = RegExp(r, 'g')

        const p = (_, a, b) => {
            let A = runner(a, depth - 1)
            let B = runner(b, depth - 1)
            return wrap(A, B)
        }
        return s.replace(r, p)
    }
}

//rpw('.clip.js', (x) => {
//const value = x.map((x) => x.question
//return value.join('\n\n' + linebreak + '\n\n')
//json(x)
//})

//console.log(unitConverter("Convert 5 seconds into years"))

answerstring1 = `
\\frac{$a}{$b} = \\frac{x}{$f} + $e

The goal when solving for x is to always get x by itself.

First we move $e to the left side.
\\frac{$a}{$b} - $e = \\frac{x}{$f}

Next move $f to the left side.
$f * (\\frac{$a}{$b} - $e) = x

Simplify the left side. 
$simp($f * (\\frac{$a}{$b} - $e))

The final answer is expr x = $answer 
`

//const service = new ExplanationService()
//service.render(answerstring1)
function firstSecond(s) {
    return search(/(.+)\n+([^]+)/, s.trim())
}
function splitKatex0820(s) {
    /*
     * $$$ target $$$
     * expr target
     * \\frac.+
     * $callableOrStuff
     * */

    const regex =
        /(\$\$\$[^]+?\$\$|$)|expr (.+)|(\n+)|((?:\\frac\S+|\$\w+(?:\(.+)?)(?: +[-*+=] +\S+)*)/
    return s.trim().split(regex).filter(hasValue)
}
function tablegetter(s, f = identity, obj) {
    let count = 0
    return split(s, /\n\n+/g).map((x) => {
        const lines = linegetter(x)
        const wrap = lines.length == 1 ? wrapAtom : wrapGroup
        const result =
            lines.length == 1 ? f(lines[0]) : lines.map(f)
        return wrap(result)
    })

    function wrapAtom(value) {
        count++
        if (obj && count in obj) {
            return {
                type: 'row',
                value,
                props: obj[count],
            }
        }
        return {
            type: 'row',
            value,
        }
    }

    function wrapGroup(a) {
        let [left, right] = splitonce(a)
        return {
            value: {
                left,
                right,
            },
            type: 'row-left-right',
        }
    }
}
//console.log(answer(s, xobj)

function hasValue(s) {
    return (s != null) & (s !== '')
}

function postFixLatexFraction(s) {
    return s.replace(
        /{(\w+)\/(\w+)}|(\w+)\/(\w+)/g,
        (_, a, b, c, d) => {
            if (a) return wrap(latex.frac(a, b), '{}')
            if (c) return latex.frac(c, d)
        }
    )
}

function firstLine(s) {
    return search(/\s*(.+)/, s)
}
////// 08-21-2022

function zoo(s) {}
//const [text, type] = mget(/^\W*(\w+)[:]? *\n/, s)
//return this[type || 'default'](text)

answerstring2 = `

Lucy scored 2, 2, 3, 4, 5, 5, 2 on her math exams. What score must Lucy obtain on the next exam to have an average of exactly 3?

Currently, there are 7 exams.
After taking one more exam, Lucy will have 8 exams.

$formula()

Plug into the formula:
The average is 3
The amount is 8 exams
----------------------
$solve()

Lucy's current total is 23. 
-------------
$sum(numbers)

24 - 23 = 1
For her next exam, all Lucy needs to score is a 1.

`
function zooper(s) {
    if (s.some(hasLineBreak)) {
        return partitionTable
    }
}
function explanationService(s) {
    let [a, b] = firstSecond(s)
    let items = split(b, /\n\n+/)
    let g = (x) => grouper(splitKatex0820(x).map(typer0820))
    return items.map(g)
}

function grouper(items) {
    let f = (x) => x.type == 'tableLineBreak'
    if (items.some(f)) {
        let [left, right] = splitArray(items, f)
        return { left, right }
    }
    return items
}

function latexParser(s) {
    return s
}
function typer0820(s) {
    /* used in explanationService noClass */
    if (!s.trim()) {
        return {
            type: 'linebreak',
            value: s.length,
        }
    }
    if (s.startsWith('---')) {
        return {
            type: 'tableLineBreak',
        }
    }

    if (s.includes('$')) {
        return {
            type: 'katex',
            value: latexParser(s),
        }
    }

    return {
        type: 'prose',
        value: s,
    }
}

function transmuteNumbers(s) {
    /* need to account for money and time */
    /* possibly add in a number function cause it happens alot */
    /* ! is used to ignore numbers */

    const numbers = {}

    const text = s.replace(/\b!?\d+\b/g, (x, offset, o) => {
        //console.log(x, 'hhhh')
        //if (test(/^!/, x)) {
        //console.log('ggggggggggggggg'); throw '';
        //return x.slice(1)
        //}

        if (numbers.hasOwnProperty(x)) return numbers[x]
        let value
        do {
            value = rngAround(x)
        } while (Object.values(numbers).includes(value))
        numbers[x] = value
        return value
    })
    return [text, numbers]
}

// 08-24-2022
/*
 * 08-24-2022
 * cog3 is the current newest version
 * uses cog3runner which uses cog3runner[1,2,3,4,355,354]
 * uses a double replacement to first switch the numbers
 * the answer must have "x" in order to trigger the solver
 * cannot use "y" or it will break the replacer
 * */
var cog3 = [
    {
        question:
            'A taxicab charges a flat fee of 10 dollars and charges X dollars for every mile. If Sam pays a total of 100 dollars for a 8 mile ride, what is the value of X?',
        answer: '100 = 10 + 8x',
    },

    {
        question:
            'A taxicab charges a flat fee of X dollars and charges 5 dollars for every mile. If Sam pays a total of 100 dollars for a 8 mile ride, what is the value of X?',
        answer: '100 = x + 8 * 5',
    },

    {
        question:
            'The sales tax on a purchase is 10%. If Sarah pays 60 dollars, what was the initial price of the item?',
        answer: '60 = $percentChange(10) * x',
    },

    {
        question:
            'There is a 10% discount on an item. If Sarah pays 60 dollars, what was the initial price of the item?',
        answer: '60 = $percentChange(-10) * x',
    },

    {
        question:
            'There is a 10% discount on an item. However, there is also a 5% tax, which is applied after the discount. If Sarah pays 60 dollars, what was the initial price of the item?',
        answer: '60 = $percentChange(-10, 5) * x',
    },
    {
        question:
            'Ryan needs to read 150 pages for school. The first 20 pages he read in 30 minutes. At this rate, how much more time does he need to finish the rest of the reading?',
        answer: '150 = 20 + (20/30)x',
        //answer:"(150 - 20) / (20/30)",
    },
    {
        question: 'If 4/5 of P is 48, what is 3/5 of P?',
        answer: `3/5 * 48*5/4`,
    },
    {
        question: 'How many integers are between 5/2 and 20/3?',
        answer: 'Math.floor(20/3) - Math.ceil(5/2)',
    },

    {
        skip: 1,
        question:
            '3 gallons of gasoline are needed to drive 65 miles. How many gallons are needed to drive m miles?',
        answer: '3/65 = x/m',
    },
    {
        question:
            'A roofing contractor uses shingles at a rate of 3 bundles for every 96 feet of roof. At this rate, how many bundles are needed to cover a roof that is 416 square feet?',
        answer: '3/96 = x/416',
    },

    { question: '0.21/0.33 = x/1.10' },
    { question: '3.99 / 1.5' },
    //{ question: "100(2 + 0.1)^2 - 100"}, doesnt work...
]

//console.log(explanationService(answerstring2))

function fixBackslashNumbers(s) {
    let r = /[\1\2\3\4\5\6\7\8\9]/g
    return s.replace(r, (item, i) => {
        switch (item) {
            case '\u0002':
                return 2
            case '\u0003':
                return 3
            case '\u0004':
                return 4
        }
    })
}

function uniqueNumber(s) {
    let ignore = findall(/[\1\2\3\4\5\6\7\8\9]/g, s).map(
        (item, i) => {
            switch (item) {
                case '\u0002':
                    return 2
                case '\u0003':
                    return 3
                case '\u0004':
                    return 4
                case '\u0005':
                    return 5
            }
        }
    )
    let initialNumbers = getNumbers(s, String)
    let numbers = unique(initialNumbers, ignore)
    let tally = new Tally(numbers)
    return tally.lowest(1)
}
//console.log(uniqueNumber('2 + 7 - 2 7 1 1 3'))
function fixMultipleFractions(s) {
    return s
        .replace(
            /\((\w+)\/(\w+)\) *\/ *(\d+(?!\.))/,
            (_, a, b, c) => {
                a = Number(a)
                b = Number(b)
                c = Number(c)
                return latex.frac(a, b * c)
            }
        )
        .replace(
            /(\d+(?!\.)) *\/ *\((\w+) *\/ *(\w+)\)/,
            (_, a, b, c) => {
                a = Number(a)
                b = Number(b)
                c = Number(c)
                return latex.frac(a * c, b)
            }
        )
}
function longestDecimal(s) {
    return getLongest(findall(/\d\.(\d+)/g, s.toString()))
}
function fixParensToLatexParens(s) {
    return s.replace(/\((.*?)\) *\/ *(.+)/, (_, a, b) => {
        return latex.frac(a, b)
    })
    //return s.replace(/^\(.*?\)/, (x) => x.slice(1, -1))
}
function fixNumberStartsWithZero(s) {
    return s.replace(/0(?=\d+\.)/g, '')
}
function hasTrailingZeroes(n) {
    return /\..*?0+$/.test(n.toString())
}
function isXEquation(s) {
    return s.includes('x') && s.includes('=')
}
function fixEqualSignToLatexSpaces(s) {
    let m = '\\medspace'
    s = s.replace(/ = *$/gm, [m, '=', m, '?', m].join(' '))
    return s
}
function fixFractions(s) {

    /* f-frac replacer RARE */
    s = s.replace(/f(\w+)\/([\w^]+)/g, (_, a, b) => {
        return `\\\\frac{${a}}{${b}}`
    })

    s = s.replace(/frac(\w+)/g, (_, x) => {
        let [a, b] = x.split('')
        return `\\frac{${a}}{${b}}`
    })
    return s.replace(
        /(\w+(?:\.\d+)?)\/([\w^]+(?:\.\d+)?)/g,
        (_, a, b) => {
            return `\\dfrac{${a}}{${b}}`
        }
    )
}
function hasCallable(s) {
    return /(?:^| )[a-zA-Z]{3,}(?:\.[a-zA-Z]{3,})*\(/.test(s)
}
function replaceNumbers(s, ref, exhibit) {
    return s.replace(/\b\d+\b/g, (x) => {
        if (exhibit && x == exhibit) {
            return isFraction(_answer)
                ? parens(_answer)
                : _answer
        }
        return ref[x] || x
    })
}

function isVeryWordy(s) {
    const regex = /[a-zA-Z\']+ [a-zA-Z\']+ [a-zA-Z\']+/
    return s.length > 10 && test(regex, s)
}

function data0823(
    data,
    { preview, runEverything, useNerd = true } = {}
) {
    assert(data)
    if (useNerd) nerdamer = require('nerdamer/all.min')
    let cog3 = data.filter((x) => x.question && !x.skip)
    let only = false

    /* scaffold */
    if (runEverything) {
        console.log('running everything')
    } else if (cog3.some((x) => x.only)) {
        cog3 = cog3.filter((x) => x.only)
        const max = Math.max(...cog3.map((x) => x.only))
        cog3 = cog3.filter((x) => x.only == max)
        only = true
    }

    let options = {
        amounts: 1,
        pattern: 'pyramid',
        runner: 'cog3runner',
    }

    let sheet = active0812a(cog3, options)
    if (only || preview) {
        console.log('done with selected only items')
        console.log(sheet.storeRef)
        return
    }
    let value = {
        date: datestamp(),
        storeRef: sheet.storeRef,
        value: sheet.value,
    }
    console.clear()
    console.log(value)
    const names = getBindings(read('vue-data.js'))
    const name = 'vuedata' + monthDay()
    let payload = createVariable(name, value, 'var')
    payload += '\n\n'
    payload += 'storeRef = ' + name + '.storeRef\n'
    payload += 'value = ' + name + '.value\n'
    const file = 'vue-data.js'
    //if (names.includes(name)) {
    //require('TextEditor.js').foo()
    //}
    write(file, payload)
}
function fixEquationForNerdamerSolver(s) {
    s = fixPlusMinus(s)
    s = fixAbsoluteValue(s)
    s = fixFactorial(s) /* 5!4! => 5! * 4! */
    s = fixMultiplication(s) /* 3a => 3 * a */
    s = fixExponentNegatives(s) /* -3^4 => (-3)^4 */
    s = removeEndingEquals(s) /* 2 + 2 =  => 2 + 2 */
    return s
}
function nerdTest(s) {
    nerdamer = require('nerdamer/all.min')
    console.log(nerdSolver(s))
    throw ''
}
//nerdTest('100 = 3x - 5')
function onlyXSide(s) {
    const m = splitonce(s, '=')
    const r = /x\b/
    return m.find((x) => r.test(x))
}
let middleMultiplicationSign = atMiddle('*')

function isNerdError(e) {
    return getConstructorName(e) == 'NerdamerValueError'
}

function seasonYear(caps = true) {
    const season = caps ? capitalize(getSeason()) : getSeason()

    return joinString(season, getYear())
}

function monthDay() {
    const date = new Date()
    const month = zeroPad(date.getMonth() + 1)
    const day = zeroPad(date.getDate())
    return month + day
}
function main() {
    return
    data0823(cog3, { runEverything: true, useNerd: true })
}
main()
data0824 = [
    {
        question:
            'A taxicab charges a flat fee of 28 dollars and charges X dollars for every mile. If Sam pays a total of 112 dollars for a 84 mile ride, what is the value of X?',
        answer: 1,
    },
    {
        question:
            'A taxicab charges a flat fee of 15 dollars and charges X dollars for every mile. If Sam pays a total of 164 dollars for a 74.5 mile ride, what is the value of X?',
        answer: 2,
    },
]
q1 = data0824[0].question

var typer0824 = runf(
    [
        isEmptyLine,
        'linebreak',
        len,
        isDashLine,
        'tableLineBreak',
        null,
        hasDollar,
        'katex',
        latexParser,
        yes,
        'prose',
        proser,
    ],
    { partitions: 3 }
)

function dataWriter(s) {
    const g = (x) => {
        const items = splitKatex0820(x)
        return grouper(items.map(typer0824))
    }
    const value = g(s)
    console.log({ value })
    throw ''
}
function proser(s) {
    const lines = periodGetter(s)
    console.log(s)
    throw ''
}
function sentenceGetter(s) {
    return s
}
function isDashLine(s) {
    return /^---/.test(s)
}

function isEmptyLine(s) {
    return s === ''
}
// 08-25-2022
//dataWriter(q1)
function reduceObject8(o, f) {
    function getG(f) {
        const params = getParameters(f).toString()
        switch (params) {
            case 'k,v':
                return f
            case 'k':
                return (k, v) => f(k)
            case 'v':
                return (k, v) => f(v)
            case '':
                return (k, v) => v
        }
    }

    const items = prepareIterable(o, 'entries')
    const store = {}
    const g = getG(f)

    for (let [k, v] of items) {
        const value = g(k, v)
        if (isDefined(value)) {
            store[k] = v
        }
    }
    return store
}

function yesNoFactory(o) {
    return console.log('nope yesnofac')
    const no = ftestFactory(o.no)
    const yes = ftestFactory(o.yes)
    return no && yes
        ? (x) => !no(x) && yes(x)
        : no
        ? (x) => !no(x)
        : (x) => yes(x)
}
f = 'math5.pdf.json'

function lenf(length) {
    //let gte
    //;[length, gte] = mget(/^ *[<>] *=*/, length.toString())
    let f = toFunction({
        name: 'lenLambda',
        params: 'x',
        body: `return x.length ${length}`,
    })
    return f
}
//const items = filter(flat(map(read(f), (x) => map(x, (x) => x[2]))), isWordProblem).map((x) => x.replace(/\n/g, ' ').trim()).join('\n\n')
//console.log(items)
//json(items)
//everything uses a table...

function getCoinflipPermutations(s, mapping = ['H', 'T']) {
    function runner(n) {
        return n <= 0
            ? ['']
            : [
                  ...runner(n - 1).map(
                      (r) => mapping[0].toString() + r
                  ),
                  ...runner(n - 1).map(
                      (r) => mapping[1].toString() + r
                  ),
              ]
    }
    const value = runner(s)
    return value
}
//console.log(getCoinflipPermutations(3, [3, 4]))

//if the process is random ...
//if it is a normal function , dont need to reconstitute
//Every Sunday, Sam flips a coin. If the coin is heads, Sam goes to work for 3 hours. If the coin is tails, Sam goes to work for 4 hours. In the span of 5 weeks, how many hours did Sam work?

//formula.coinflipWork(3, 4, 5)

function coinflipWork(amount, case1, case2) {
    const value = getCoinflipPermutations(amount, [
        case1,
        case2,
    ])

    //console.log(value)
    let values = value.map((item, i) => {
        return sum(split(item))
    })

    values = unique(values)
    if (values.length > 3) {
        values = values.slice(0, 3)
        s = `How many hours did Sam work in February`
    }
    return values
}

//console.log(coinflipWork(3, 6, 5))
function prettifyNerdamer(s) {
    return s
    //orderByPolynomialDegree
}

function getDaysInMonth(month) {
    const date = new Date()
    const year = date.getFullYear()
    return new Date(year, month, 0).getDate()
}
//console.log(getDaysInMonth(2))
//console.log(Quadratic.cancelToOne())
//

function fixXAndThenNumber(s) {
    return s.replace(/[abcdexyz]\d+/g, atMiddle('^'))
}
function fixSpacedDivision(s) {
    const items = split(s, ' / ')
    if (items.length > 2) return s
    return latex.dfrac(...items)
}
// it works ... but the answer is ugly.
//
// Quotient means the answer. Dividend means the dude being divided. Divsor means ...
function addTheMissingParentheses(s) {
    /* Add parentheses to make the statement true! */
}
s = '2x3p7x2p2xp1 / xp3'
//nerdamer = require("nerdamer/all.min")
//console.log(prettifyNerdamer(nerdSolver(fixMath(s))))

//setupStringMathNode()
//s = new StringMathNode2(4)
//s2 = s.add(5).add(4).times(3).divide(6)
//console.log(s2)

//console.log((new BuildMath()).run([6, 4, 3]))
//i dont like it ... doesnt really work
//nerdamer = require("nerdamer/all.min")
//console.log(arithmeticVariations('a + b * c', 5))
// WORKS

function removeParentheses(s) {
    return s.replace(/[()]/g, '')
}

function abcde(x) {
    return (x * 2 - 6 + x) / 3
    //x - 2 4x - 8 / 4
}

function appleCake(s) {
    //adj + fruit + dessert
    //verb + like a|an + subject
    //flylikeanapplecake ... no
    //abcdabcdabcdabcd
    //dcbadcbadcbadcba
    //a b c d d
    //a b c d d
    //a b c d d
    //a b c d d
    //answer-sheet
    //to print it out.
    //to grade it all at once.
    //akgjldfgbab
    //akjglfkdkg
    //alfkkkkfj
    //kevin afjdkfmclald
    //abbcbabdba
    //abbbbbbbb
    //gradeit
    // take a small quiz today
    // homework report
    // everyone the same ...
    // but for quizzes it is different
    // Alvin Chang - Homework 1 - Grade Report
    // Total Score = 100%
    // Question Analysis
    // Q1: Answer D. Score D.
    // Q2: Answer E. Score E.
    // abjgkfld
    // Give the homework.
    // Give a quiz.
    // class structure.
    // Hard Questions
    // The reason to do hard questions is because it will teach us a lot of important things.
    // After the hard Question, we will do medium questions.
    // We will take a quiz.
    // I dont need to say it. I just need to do it.
    // Give it out of 1 million
    // And then give a simpler version
    // The hostility is real
    // Super real.
    // nin ... .
    // nin is  the respectful term
    // The big packs
    //
    // Explanations
    // This was a pretty tricky question.
    // They dont
    // They cant go against their conditioning.
    // I am going to be teaching the children of Manhattan China Town.
    //
    //10 questions
    //20 or 20 questions
    //commentRE
    //Everyone benefits.
    //No one in the lib
}

//console.log(seasonYear())
//console.log(generateMultipleChoice('1.23'))
//f = incrementf(null, {offset: 1})
// scaled on it.
// 2% more than 3 ... do it in advance
// generate animations iniio
//
// 08-29-2022
function correctGrades(studentAnswers, answerKey) {
    studentAnswers = parse(studentAnswers)
    answerKey = parse(answerKey)

    function parse(s) {
        if (isArray(s)) {
            return s.map((x) => x.toUpperCase())
        }
        return split(s.toUpperCase(), '')
    }

    assert(answerKey.length == studentAnswers.length)
    let length = answerKey.length
    return range(length).map((index, i) => {
        let a = studentAnswers[i]
        let b = answerKey[i]
        let { type } = questionInfo(index)
        let isCorrect = a == b
        return {
            index,
            type,
            correct: isCorrect,
            studentAnswer: a,
            correctAnswer: b,
        }
    })
}
function questionInfo(index) {
    const type = 'testing'
    return {
        type: type,
    }
}

//console.log(correctGrades('aaa', 'aaa'))
/* answerSheet */

/*
 * To leaern about the processes
 *
 *
 * */
const cogFromAlgebra = [
    {
        question:
            'The sum of two numbers is 15. One of the numbers is 3 more than the other number. What is the smaller number?',
        answer: '(15 - 3) / \2',
        /* \ means fixed */
    },

    {
        question:
            '$peekaBoo I am a $[2-3]-digit $odd number. Reverse my digits and I will become an $other number. Add my digits up, and their sum is $rng(5, $lastNumber * 9 - 3). What number could I be?',
        skip: 1,
        answer(numbers, tempRef) {
            let config = {
                digitSum: numbers[1],
                odd: tempRef.odd,
                len: numbers[0],
                digits(digits) {
                    return tempRef.other == 'even'
                        ? isEven(digits[0])
                        : isOdd(digits[0])
                },
            }
            let f = numberf(config)
            console.log(numbers)
            return getNDigitNumber(numbers[0]).filter(f)
        },
    },
    {
        question:
            'I am a $rng(3, 3)-digit $odd number. My $rnp(1s, 10s, 100s) digit is $a less than my $rnp digit. My digits sum up to $rng(5, 25). What number could I be?',
        answer(numbers, tempRef) {
            let config = {
                len: numbers[0],
                digits(digits) {
                    let a = log10(parseInt(tempRef.a)) - 1
                    let b = log10(parseInt(tempRef.b)) - 1
                    return digits[a] - digits[b] == numbers[1]
                },
                digitSum: numbers[2],
            }

            let c = numberf(config)
            return getNDigitNumber(numbers[0]).filter(c)
        },
    },

    {
        numbers: 'default1',
        type: 'questionFromAnswer',
        question:
            'What is the $smallestLargest number X such that $1/$2 is $greaterLess than $3/$4?',
        answer(numbers) {
            let index = randomIndex(numbers)
            let greaterLess
            let smallestLargest

            if (index == 1 || index == 3) {
                smallestLargest = 'smallest'
                greaterLess = 'greater'
            } else {
                smallestLargest = 'largest'
                greaterLess = 'less'
            }

            edit(numbers, index, 'X')
            let argRef = {
                numbers,
                smallestLargest,
                greaterLess,
            }
            let solutions = [
                (a, b, c, d) => (b * c) / d,
                (a, b, c, d) => (a * d) / c,
                (a, b, c, d) => (a * d) / b,
                (a, b, c, d) => (b * c) / a,
            ]
            let answer = solutions[index](...numbers)
            if (isInteger(answer)) {
                if (smallestLargest == 'smallest') {
                    answer++
                } else {
                    answer--
                }
            } else {
                if (smallestLargest == 'smallest') {
                    answer = Math.floor(answer)
                } else {
                    answer = Math.ceil(answer)
                }
            }
            return [answer, argRef]
        },
    },

    {
        question:
            'What is the smallest number that is a multiple of both $a and ${a * c}',
        answer: 'lcm(a, b)',
    },

    {
        type: 'questionFromAnswer',
        question:
            'What is the lowest common multiple of $join($args)',
        answer(numbers) {
            numbers = [4, 6, 9]
            let seed = number
            /* the numbers arg comes from numbers... */

            let answer = lcm(numbers)
            return [answer, args]
        },
        numbers: {
            1: 5,
        },
    },

    {
        question:
            'How many prime numbers are there whose squares are less than 125?',
        answer(n) {
            return PRIMES.filter((x) => x * x < n).length
        },
        explanation(n) {
            const numbers = PRIMES.filter((x) => x * x < n)
            const length = numbers.length
            //return `
            //table(numbers)
            //`
        },
    },

    {
        question: 'How many different factors does 60 have?',
        answer: 'factor($1, Array)',
    },

    {
        question:
            'How many integers between $rng(5,10) and $rng(50,60) are multiples of $rng(2,4) and $rng(5,7)?',
        answer: '${range($1, $2).filter(x => x % lcm($3, $4) == 0).length}',
    },
    {
        question() {
            function creator() {
                let s = []
                let length = rng(2, 3)
                for (let i = 0; i < length; i++) {
                    let number = rng(isPrime)
                    let exponent = rng(1, 2)
                    s.push(interweave(number, ' * ', exponent))
                }
                return s.join(' * ')
            }

            let a = creator()
            let b = creator()
            let aa = getnumbers(a)
            let bb = getnumbers(b)
            let intersection = getAllShared(aa, bb)
            let question = `What is the greatest common factor of ${a} and ${b}?`
            answer = multiply(...intersection)
            return { question, answer }
        },
    },
    {
        question:
            'On Christmas, $name eats $1 cakes. The amount he eats is $2 times more than $3 more than $name2. How much does $name2 eat?',
        numbers: (answer, level) => {
            function runner(answer) {
                let offset = rng(1, 0.5 * answer)
                let multiplier = rng()
                let eats = (answer + offset) * multiplier
                return [eats, multiplier, offset]
            }
            return repeatUntil(
                runner,
                (x) => {
                    return every(x, isPositive, isInteger)
                },
                answer
            )
        },
    },
]

//console.log('\2'.replace('\\2', 'hi')); throw '';
//console.log(data0823(cogFromAlgebra))

// 08-30-2022

function getHighest(items, f) {
    return Math.max(...items.map(f).filter(exists))
}
function onlyOnly(items, bypass) {
    if (bypass) return items
    if (!items.some((x) => x.hasOwnProperty('only'))) {
        return items
    }
    const highest = getHighest(items, (x) => x.only)
    return items.filter((x) => x.only == highest)
}
function injectKey(key) {
    let regex
    Object.entries(MathTemplaterRegexes).find(([a, b]) => {
        let found = b.indexOf(key)
        if (found < 0) return
        regex = b[found - 1]
        return true
    })
    let payload = [regex, key]
    MathTemplaterRegexes.default.push(...payload)
    console.log('injected', payload)
}

function hasDollarVariable(s) {
    return /\$\[a-zA-Z]/.test(s)
}

runClassPreloadConfig = {
    Worksheet3: {
        onlyOnly: true,
        preloaders: [mixinMaster, () => injectKey('qaBraces')],
        constructorArgs: null,
    },
}
function nameOf(x) {
    if (isFunction(x)) {
        return x.name
    }
}
function runClass2(X, arg) {
    ref = runClassPreloadConfig[nameOf(X)]
    let constructorArgs = ref.constructorArgs || []
    if (ref.onlyOnly) arg = onlyOnly(arg)
    if (ref.preloaders) {
        for (let preloader of ref.preloaders) {
            console.log(preloader)
            preloader()
        }
    }
    let obj = new X(...constructorArgs)
    let value = obj.run(arg)
    if (value) {
        console.log(value)
    } else {
        console.log('no value @runclass2')
    }
}
//runClass2(Worksheet3, cogFromAlgebra)

// 08-31-2022
function modularIncrementWithFn(index, data, f, dir = 1) {
    let length = data.length
    if (!isDefined(index)) return 0
    if (f) {
        if (
            (dir > 0 && index == length - 1) ||
            (index == 0 && dir == -1)
        ) {
            let newIndex = data.find(f)
            if (isDefined(newIndex)) {
                return newIndex
            } else {
                return 0
            }
        }

        index += dir
        let current = data[index]
        while (!f(current)) {
            index += dir
        }
        return index
    }
}

function generateValueDone(a) {
    return a.map((item, i) => {
        return {
            value: item,
            done: false,
        }
    })
}
//thomasHyunSAT = generateValueDone([0,1,2,3,4,5])
//console.log(modularIncrementWithFn(0, thomasHyunSAT, (x) => !x.done, -1))

function notDone(x) {
    return !x.done
}
function loremText() {
    return randomPick(alphabet).repeat(rng(1, 100))
}

function splitRecursive(s) {
    s = `
        a
            b
                c
            b
            b
    `
    s = smartDedent(s)
}
//console.log(splitRecursive())

const titlePage = `
        
        a
        b
            c
            d
                e
            f
        
    `
//const alan = new AlanParser2()
//const htmlTitlePageResult = alan.run(titlePage)
//console.log(htmlTitlePageResult)

function isSentence(s) {
    const regex = /[a-zA-Z\']+ [a-zA-Z\']+ [a-zA-Z\']+/
    return s.length > 10 && test(regex, s)
}

function runClass3(State, items, config) {
    //return console.log('no go press rc3 to cancel')
    /** rc3 **/
    let defaultConfig = {
        normalizeAmounts: 12,
        packetType: 'homework',
    }

    if (!State) return
    if (!config) config = defaultConfig

    if (isArray(items) && isObject(items[0])) {
        items = skipSkip(items)
        items = onlyOnly(items, config.bypass)
        if (config.normalizeAmounts) {
            normalizeAmounts(items, config.normalizeAmounts)
        }
    }

    const state = new State(config.constructorArg)
    const value = state.run(items)
    if (config.debug) {
        console.log(value)
        throw ''
    }

    const titlePage = {
        component: 'MathDocTitlePage',
        payload: {
            props: {
                title: 'Grade 4 Math',
                packetType: config.packetType,
                date: upcomingSaturday(),
                //toc: getToc(items)
            },
        },
    }
    value.unshift(titlePage)

    if (config.write) {
        writeVueDataAndOpen(value, state.activeKey)
        /** rc3 **/
    }
    return value
}

const hyunMathAnswersRegexes = [
    /Section \d+-\d+/,
    /\d+\. *(\d+\n\d+|\S+)/,
    /Chapter \d+ Practice Test/,
]

function removeUntil(r, s) {
    const regex = RegExp(`[^]*?(?=${reStr(r)})`)
    return s.replace(regex, '')
}

class Tokenizer3 {
    /* to parse hyun-math answerkey */
    constructor(regexes) {
        mixin(this, StringMixins)
        this.regex1 = RegExp(`[^]*?(?=${reStr(regexes[0])})`)
        this.regexes = regexes.map((r, i) => {
            return RegExp('^' + reStr(r))
        })
        this.store = []
    }

    run(s) {
        if (s) this.s = del(this.regex1, s)

        while (true) {
            this.trim()
            let found = false
            for (let r of this.regexes) {
                let m = this.mreplace(r)
                if (m) {
                    if (isString(m)) {
                        m = m.replace(/^\d+\n\d+$/, (x) =>
                            x.replace(/\n/, '/')
                        )
                    }
                    this.push(m)
                    found = true
                    break
                }
            }
            if (!found) {
                const r = /^\d+ */
                if (r.test(this.s)) {
                    this.s = del(r, this.s)
                    return this.run()
                } else if (test(this.regex1, this.s)) {
                    return this.run(this.s)
                } else {
                    break
                }
            }
        }
        return this.store
    }
    push(item) {
        this.store.push(item)
    }
}

function groupByLabel(a, label) {
    assert(label)
    const isLabel = ftestFactory(label)
    const storage = new Storage({mergeArray: false})
    let currentLabel
    for (let item of a) {
        if (isLabel(item)) {
            currentLabel = item
            continue
        }
        storage.add(currentLabel, item)
    }
    return storage.value
}

function hyunMathAnswers(s) {
    const pages = read('pages2.json').answers
    jsonData = read(
        '/mnt/chromeos/MyFiles/Downloads/Acing the New SAT Math PDF Book.pdf.json'
    )
    const value = pages.map((answerIndex, i) => {
        let text = jsonData[answerIndex - 2]
        const items = runClass3(
            Tokenizer3,
            hyunMathAnswersRegexes,
            text
        )
        let value = groupByLabel(items, /^Chapter|^Section/)
        return value
    })
    //console.log(stringify(value)); throw ""
    return value
    json(value)
}

/* hard to focus. */
/* gives me a bad feeling */
/* jie-jie ... */
function readClip(s) {
    return read(clipfile)
}
function partitionRanges(items) {
    const storage = new Storage()
    let last = 1000
    let count = 0
    for (let item of items) {
        if (delta(last, item) > 3) {
            count++
        }
        storage.add(count, item)
        last = item
    }
    return Object.values(toJSON(storage))
}

function hyunSetup() {
    const ref = read('pages2.json')
    const tests = partitionRanges(ref.tests)
    const answers = hyunMathAnswers()
    ref.tests = tests
    ref.answers = answers
    return ref
}

function reducer(k, v) {
    let [chapterNumber, chapterTitle] = search(
        /Chapter (\d+): (.+)/,
        k
    )
    const children = v.map((item, i) => {
        let [index, title] = splitonce(item)
        let pageNumber = ref.exercises.shift()
        let answerRefKey = `Section ${index}`
        let answers =
            ref.answers[chapterNumber - 1][answerRefKey]
        return {
            index: i + 1,
            title,
            pageNumber,
            answers,
        }
    })
    let examRefKey = `Chapter ${chapterNumber} Practice Test`
    let examAnswers = ref.answers[chapterNumber - 1][examRefKey]
    let examPageNumbers = ref.tests.shift()
    let chapterExam = {
        pageNumbers: examPageNumbers,
        answers: examAnswers,
    }
    return {
        chapterNumber,
        chapterTitle,
        children,
        chapterExam,
    }
}
function hyunToc() {
    jsonData = read(
        '/mnt/chromeos/MyFiles/Downloads/Acing the New SAT Math PDF Book.pdf.json'
    )
    //.slice(4, 10 - 1)

    const regexes = [
        /Chapter\s+\d+:\s+\S+(?: \S+)*/,
        /\d+-\d+\s+\S+(?: \S+)*/,
    ]

    let creator = (text) => {
        const items = runClass3(Tokenizer3, regexes, text)
        return groupByLabel(items, /^Chapter/)
    }
    let payload = merge({}, ...map(jsonData, creator))
    return payload
}

function hyunCreate() {
    ref = hyunSetup()
    json(Object.values(reduce(hyunToc(), reducer)), 'hyun-data')
}
var AssertionMessages = {
    /* assertionref */
    groupByLabel:
        'requires a secondary argument, "the label", a function or a regex to perform the grouping by label.',
    boo: 'vvv',
    aggregatorFromColonsToDictionary: 'need to have config',
}

function toModuleExports(items) {
    return (
        '\n' +
        join(map(toArray(items), 'module.exports.$1 = $1'))
    )
}

// 09-05-2022
function toModuleImports(path, items, short) {
    if (short) {
        return `var {${items}} = require("${localPath(path)}")`
    }
    return `${brackify(
        'var',
        toArray(items).map(addf(','))
    )} = require("${localPath(path)}")`
}

function mathDecompose(n, subtraction) {
    let orig = n
    function runner(n) {
        let a = rng(2, n - 2)
        if (a <= 1) return n
        let b = n - a
        //console.log(a, b)
        store.push(a)
        if (count++ > limit) return
        return runner(b)
    }

    let limit = 3
    let count = 0
    const store = []
    push(store, runner(n))
    if (subtraction) {
        store.unshift(orig * 2)
        return latex.subtract(...store)
    }
    return latex.add(...store)
}
//console.log(mathDecompose(5, true)); throw '';

function mathDecomposedMultiplication(s) {
    let f = partial(mathDecompose, coinflip())
    let numbers = parseArithmetic(s).map(f)
    //console.log(numbers); throw '';
    return latex.multiply(...numbers)
}
//console.log(mathDecomposedMultiplication('3 * 6'))
//console.log(asciiLetterCoordinates('a'))

//What we will learn today
//grouped multiplication
//finding the secret number
//fruity math

function fruityMath(s) {
    /* later */
}
function findTheSecretNumber(s) {}

//active0812a()

function changeNumbersAround(s, mode) {
    const numbers = {}

    const text = s.replace(/\b\d+\b/g, (x) => {
        if (numbers.hasOwnProperty(x)) return numbers[x]
        let value
        do {
            value = rngAround(x)
        } while (Object.values(numbers).includes(value))
        numbers[x] = value
        return value
    })
    return mode == Array ? [text, numbers] : text
}
function solveQuestionForX(s, answer) {
    if (isEquation(s)) return s
    const value = nerdEval(nerdSub(s, { x: answer }))
    return equationify(s, value)
}

/* spaghetti ... */

class EasyMathGenerator extends BaseGenerator {
    constructor() {
        super()
    }

    run(x) {
        const items = toArray(x)

        return items
            .map((item) => {
                let payload = this.runner(item)
                if (!payload) return
                //if (item.shuffle) shuffle(payload)
                const vd = vdFunction(item.key)
                if (vd) payload = vd(smallify(payload))
                this.activeKey = item.key
                return payload
            })
            .filter(exists)
    }

    runner(options) {
        const answers = numberPattern(options)
        if (!options.amount) options.amount = answers.length
        let nextAnswer = nextf(answers)
        let nextOption = progressionFactory(
            options.progression,
            options.amount,
            options.shuffle
        )

        this.f = validationFactory(
            emFunction(options.key),
            options.validator
        )

        if (nextOption) {
            return range(options.amount).map((_, i) => {
                const answer = nextAnswer && nextAnswer()
                let o = nextOption(i)
                let value = this._generate(o, answer)
                /*---------------------------------*/
                /* due to the shuffle effect */
                while (!value) {
                    o = nextOption(i)
                    value = this._generate(o, answer)
                    breaker(20)
                }
                /*---------------------------------*/
                breaker.reset()
                return value
            })
        }

        if (options.amount && nextAnswer) {
            return range(options.amount).map((_, i) => {
                return this._generate(nextAnswer())
            })
        }

        if (options.amount) {
            return range(options.amount).map((_, i) => {
                return this._generate()
            })
        }

        return this.f()
    }
}

function nerdSub(s, obj) {
    for (let [a, b] of prepareIterable(obj, 'entries')) {
        s = nerdamer(s).sub(a, b)
    }
    return s
}
function equationify(s, value) {
    return s + ' = ' + value
}
function floorDivision(a, b) {
    return Math.floor(a / b)
}

function emptyArray(a, b) {
    if (!b) b = a
    const filler = (x) => new Array(x).fill()
    return filler(b).map(() => filler(a))
}

function numberSpiral(a = 5, b = 4) {
    if (!b) b = a
    let result = emptyArray(a, b)
    let counter = 1
    let startCol = 0
    let endCol = a - 1
    let startRow = 0
    let endRow = b - 1
    while (startCol <= endCol && startRow <= endRow) {
        for (let i = startCol; i <= endCol; i++) {
            result[startRow][i] = counter
            counter++
        }
        startRow++
        for (let j = startRow; j <= endRow; j++) {
            result[j][endCol] = counter
            counter++
        }

        endCol--

        for (let i = endCol; i >= startCol; i--) {
            result[endRow][i] = counter
            counter++
        }

        endRow--
        for (let i = endRow; i >= startRow; i--) {
            result[i][startCol] = counter
            counter++
        }

        startCol++
    }

    return result
}

var CoordinatorRef = {
    numberSpiral(aa) {
        return
    },
}

/* needs a minimum level of passability */

function upcomingDate(day = 'sunday', mode = String) {
    const index = isNumber(day)
        ? day
        : weekdays.indexOf(capitalize(day))

    const date = new Date()
    while (true) {
        if (date.getDay() == index) {
            return mode == String ? datestamp(date) : date
        }
        date.setTime(date.getTime() + 86400000)
    }
}
//console.log(numberSpiral().map(reverse))
//console.log(upcomingDate('saturday'))
//console.log(groupMath()) /* 1 + 6, 2 + 5, 3 + 4 ... the problem is that it has duplicates */
/* in this file */
function limitFirstCoefficient(s, limit) {
    if (!limit) return s
    return s.replace(/\d+(?=x)/, (x) => {
        if (limit == 1) return ''
        if (Number(x) <= limit) return x
        let value = rng(1, limit)
        if (value == 1) return ''
        return value
    })
}

// 09-07-2022
function expandMultiplicationToAddition(s) {
    return s.replace(/(\d+)x/, (_, x) => {
        const numbers = map(Number(x), () => 'x')
        return latex.add(...numbers)
    })
}
function xToQuestionMark(question) {
    return question.replace(/x/g, '?')
}
//progressionFactory({a: 'hi', b: 'bye'}, 4)
function progressionFactoryArray(a, amount) {
    let d = floorDivision(amount, a.length)
    if (d == 1) d = 2
    let limit = d
    let length = a.length
    let breakpoints = range(amount).filter(
        (x) => x % limit == 0
    )
    let currentIndex = 0
    let currentLimit = breakpoints[currentIndex]
    let current = {}
    return function lambda(i) {
        if (i >= currentLimit) {
            currentLimit = breakpoints[++currentIndex]
        }
        const value = a[currentIndex]
        if (isObject(value)) {
            Object.assign(current, value)
            return current
        } else if (value) {
            return value
        }
    }
}

function progressionFactory(o, amount, shuffle) {
    if (!o) return

    if (shuffle) {
        /* basically no more progression.
         * the progression is randomized */
        if (isObject(o)) {
            o = Object.values(o)
        }
        return function lambda(i) {
            return randomPick(o)
        }
    }
    if (isArray(o)) {
        return progressionFactoryArray(o, amount)
    }
    let entries = prepareIterable(o, 'entries')
    if (entries[0][0] == 'a') {
        let breakPointIndexes = []
        let limit = floorDivision(amount, entries.length)
        for (let i = 0; i < amount; i++) {
            if (i % limit == 0)
                breakPointIndexes.push(i + limit)
        }
        const values = Object.values(o)
        entries = zip(breakPointIndexes, values)
    }
    let length = entries.length - 1
    let currentIndex = 0
    let limit = Number(entries[currentIndex][0])
    let current = {}

    return function lambda(i) {
        if (i >= limit && currentIndex < length) {
            currentIndex++
            limit = entries[currentIndex][0]
        }
        /* overwriting is hard -- how do u delete */

        const value = entries[currentIndex][1]
        Object.assign(current, value)
        return current
    }
}
function mathRearrange(s) {
    /* it will rearrange the pieces */
    return s
    let [a, b] = shortLong(...splitonce(s, / = /))
    //return b.
}

INSTRUCTIONS_STRING = `

---------------
finding x
grade 4
---------------

Finding x is one of the most important things you will do in your mathematics career.

You will do it in 4th grade, 5th grade, 6th grade, 12th grade, and even ... college!

Later on, there will be more advanced ways of find x. But more advanced doesnt necessarily mean better. One of the best ways of finding x


For now, the way we will do it is with guessing.

Guess a number for x, and then check it.
Does everything fit match up perfectly?
Excellent work. You have just found the answer!
------------------------------
`
function dollarLetter(s) {
    return rng()
}
function randomPopFactory(...args) {
    args = gatherArgs(args)
    let orig = copy(args)
    return function lambda(s) {
        if (!exists(args)) {
            args = copy(orig)
        }
        return args.pop()
    }
}

function emGuessForX(options, answer) {
    /* input: 3x + 4
     * output: x + x + x + 4 = 7
     * */

    if (!options) {
        options = {template: randomLinear()}
        answer = rng()
    }
    let s = changeNumbersAround(options.template)
    s = limitFirstCoefficient(s, options.limit)
    s = solveQuestionForX(s, answer)
    s = expandMultiplicationToAddition(s)

    if (options.reverse && coinflip()) {
        s = reverse(s)
    }

    if (options.rearrange) {
        s = mathRearrange(s)
    }

    let payload = { question: s, answer }
    return payload
}

function emMoreThanLessThan(options) {
    function runner() {
        return buildTree(options.terms, options).toString()
    }

    return options.equality
        ? infuseX(joinString(runner(), 'is', runner()))
        : runner()
}

//nerdamer = require("nerdamer/all.min")
//runClass3(EasyMathGenerator, [{

//
//

function foo(config) {
    return runClass3(
        EasyMathGenerator,
        [
            {
                progression: [{ template: '20 + 30 + 40' }],
                only: 13,
                key: 'emArithmetic',
                title: 'sum to 10000',
                pattern: '100',
                amount: 1,
            },

            {
                progression: [{ template: '2000 + 8000' }],
                only: 12,
                key: 'emArithmetic',
                title: 'sum to 10000',
                pattern: '10001',
                amount: 1,
            },

            {
                progression: [
                    { template: '2000 + 3222 + 4000' },
                ],
                only: 12,
                key: 'emArithmetic',
                title: 'sum to 10000',
                pattern: '10002',
                amount: 1,
            },

            {
                progression: [
                    { template: '2000 + 3222 + 1232 + 2343' },
                ],
                //shuffle: 1,
                only: 12,
                key: 'emArithmetic',
                title: 'sum to 10000',
                pattern: '10003',
                amount: 1,
            },

            {
                skip: 1,
                progression: [
                    { template: '2 + 3' },
                    { template: '5 - 3' },
                    { template: '4 * 5' },
                ],
                shuffle: 1,
                only: 10,
                key: 'emArithmetic',
                title: 'Warmup Math',

                pattern: '2x + 3',
                start: 4,
            },
            {
                progression: {
                    10: {
                        template: '3x + 4',
                        limit: 1,
                    },
                    14: {
                        template: '2x + 2',
                        reverse: true,
                        limit: 2,
                    },

                    16: {
                        template: '2x + 4 + 2',
                        reverse: true,
                        limit: 3,
                    },
                },
                key: 'guessForX',
                amount: 4,
                pattern: 'funnel',
                start: 6,
                only: 11,
                /*---------------------------------*/
            },
            {
                key: 'moreThanLessThan',
                skip: 1,
                amount: 20,
                pattern: 'pyramid',

                progression: {
                    5: {
                        terms: 2,
                        moreThan: 1,
                    },

                    10: {
                        terms: 2,
                        getValue:
                            randomPopNumbersAndVariables(
                                'variables'
                            ),
                        moreThan: 1,
                    },

                    15: {
                        terms: 3,
                        getValue:
                            randomPopNumbersAndVariables(),
                        moreThan: 1,
                    },
                },
            },

            {
                title: 'Multiplication 1',
                desc: 'The questions are ordered from the bottom up. With the smallest answers going first.',
                key: 'orderedMultiplication',
                done: 1,
            },

            {
                title: 'What number or numbers come next?',
                title: 'Find the number or numbers that come next!',
                mode: 'classwork',
                key: 'emNumberPatterns',
                amount: 10,
                progression: [
                    { terms: [4, 7], blanks: 1, ending: true },
                    { terms: [4, 7], blanks: 2, ending: true },
                ],
            },

            {
                go: 1,
                only: 1,
                title: 'Big Additions',
                key: 'emArithmetic',
                progression: [
                    '323 + 254 + 53',
                    '1000 + 800 + 123',
                ],
                amount: 6,
                pattern: '400 + 200x',
            },

            {
                go: 1,
                only: 1,
                title: 'Super Big Additions',
                key: 'emArithmetic',
                progression: [
                    '3230 - 2540 - 530',
                    '10000 - 8000 - 1230',
                    '100000 - 80000 - 12300',
                ],
                amount: 6,
                pattern: '4000',
            },

            {
                title: 'Big Subtractions',
                key: 'emArithmetic',
                progression: [
                    '323 - 254 - 53',
                    '1000 - 800 - 123',
                ],
                amount: 6,
                pattern: '400 + 200x',
            },

            {
                title: 'Multiplication and then Subtraction',
                key: 'emArithmetic',
                progression: [{ template: '2 * 3 - 4' }],
                amount: 16,
                pattern: 'funnel',
            },

            {
                only: 0,
                go: 1,
                title: 'Adding Fractions',
                key: 'emFractionDecomposition',
                progression: [
                    { terms: 2 },
                    { terms: 3 },
                    { terms: 4 },
                ],
                amount: 10,
                level: 'g5s',
                validator: noIntegers,
                /* validator not in use yet */
            },
            {
                only: 4,
                title: 'Mixed Arithmetic Warmup',
                type: 'warmup',
                key: 'emArithmetic',
                progression: [
                    { template: '4 + 5' },
                    { template: '4 - 2' },
                    { template: '4 * 3' },
                    { template: '6 + 5' },
                    { template: '7 - 2' },
                    { template: '8 * 3' },
                ],
                pattern: 'pyramid',
                amount: 10,
            },

            {
                only: 6,
                title: 'Sudoku',
                key: 'emSudoku',
                progression: [{ size: 4 }],
                amount: 1,
            },

            {
                only: 2,
                go: 1,
                title: 'Plugger Chuggers',
                key: 'emArithmetic',
                progression: [
                    { template: '2 * 3 - 4', letters: 0.5 },
                    { template: '2 * 3 - 4', letters: 0.6 },
                ],
                amount: 4,
                pattern: 'funnel',
            },
        ],
        config
    )
}

function randomPopNumbersAndVariables(key) {
    if (key == 'variables') {
        function generate() {
            return shuffle(copy(alphabet.slice(0, 10)))
        }
        let ref = generate()
        return function lambda() {
            if (!exists(ref)) {
                ref = generate()
            }
            return ref.pop()
        }
    }

    function generate() {
        const letters = shuffle(copy(alphabet.slice(0, 10)))
        const numbers = shuffle(range(10))
        return [letters, numbers]
    }
    let ref = generate()
    let i = 0
    return function lambda(s) {
        i = i == 0 ? 1 : 0
        let current = ref[i]
        if (!exists(current)) {
            ref = generate()
            current = ref[i]
        }
        return current.pop()
    }
}

function numberArray(f, { start = 1 } = {}) {
    const store = []
    for (let i = start; i <= 9; i++) {
        for (let j = i; j <= 9; j++) {
            store.push(f(i, j))
        }
    }
    return store
}
function emOrderedMultiplication(s) {
    const store = numberArray((i, j) => {
        return [i, j, i * j]
    }, { start: 2 })

    sorted(store, (x) => x[2])
    return store.map(([a, b, answer], i) => {
        const question = coinflip()
            ? latex.multiply(a, b)
            : latex.multiply(b, a)

        return {
            question,
            answer,
        }
    })
}

function replaceAllButOne(r, f, s, other = 'x') {
    //console.log(s); throw '';
    //console.log(arguments); throw '';
    let c = count(r, s)
    let i = 1
    let touched
    return s.replace(r, (x) => {

        if (!touched && (++i == c || coinflip(i / c))) {
            touched = true
            return other
        }
        return f(x)
    })
}

function replaceInOrderFactory(f) {
    return f
    let seen = []
    return function lambda(x) {
        x = Number(x)
        let value = f(x)
        if (seen.length > 0) {
            let last = getLast(seen)
            console.log({ last })
            throw ''
            while (true) {
                if (last[0] > x && value < last[1]) {
                    console.log([last[0], x])
                    //console.log(last, [x, value])
                    breaker(5)
                    value = f(x)
                    continue
                }
                break
            }
        }
        seen.push([x, value])
        return value
    }
}
function emArithmetic(options, answer) {
    let s = isString(options) ? options : options.template
    let f = replaceInOrderFactory(rngAround)
    s = replaceAllButOne(/\d+/g, f, s, 'x')
    s += ' = ' + answer
    s = solveAndReplace(s, options.requirements || isInteger)
    //console.log({s}); throw ""
    if (!s) {
        return
    }
    s = fixPlusMinus(s)
    s = fixNegativeAtFront(s)
    s = removeEqualSignAndAnswer(s)

    if (options.letters) {
        const dict = numbersToVariables(s)
        const e = mapArray(dict, (k, v) => equationify(v, k))
        const oxford = oxfordComma(e)
        const q = dreplace3(s, dict, 'bgr')
        s = `${oxford}. Find the value of ${q}.`
    }
    return { question: s, answer }
    return s
}
function emMultiplicationSubtraction(answer) {
    /* works */
    let a = rng()
    let b = rng()
    let c = a * b
    let d = c - answer
    if (d <= 0) return
    let question = latex.subtract(latex.multiply(a, b), d)
    return question
    return { question, answer }
}

function fixNegativeAtFront(s) {
    return s.replace(
        /^-(\d+ (?:- \d+)*) \+ (\d+)/,
        (_, a, b) => {
            return b + ' - ' + a
        }
    )
}

function randomLinear(options = {}) {
    let a = options.slope || rng()
    let b = options.yint || rng()
    let operator = options.operator || eitherOr('+', '-')
    return a + 'x' + ' ' + operator + ' ' + b
}
function emNumberPatterns(options = {}) {
    let template =
        options.template || randomLinear(options.yint)
    let f = bringToLife(template)
    let start = isNumber(options.start)
        ? options.start
        : rng(3, 7)

    let end = isArray(options.terms)
        ? start + rng(...options.terms)
        : isNumber(options.terms)
        ? start + options.terms - 1
        : options.end || start + rng(3, 5)
    //console.log(f(start))
    //console.log(range(start, end)); throw '';
    //
    //console.log({start, end, f: f.toString()}); throw '';
    let store = range(start, end).map(f)
    //console.log(options.ending, 'hiiic')
    return addBlanks(
        store,
        options.blanks || 1,
        options.ending || options.last
    )
    /* it is more descriptive to write 'blanks' */
}
function addBlanks(a, n, ending) {
    let store = []
    if (ending) {
        for (let i = 1; i <= n; i++) {
            a[a.length - i] = null
        }
        return a
    }
    for (let i = 0; i < n; i++) {
        let index = rng(0, a.length - 1)
        if (store.includes(index)) i--
        else {
            store.push(index)
            a[index] = null
        }
    }
    return a
}
//console.log(emNumberPatterns())

/* start with a strong multiplication base */

//f = progressionFactoryArray([{a:1}, {b:2}, {c:3, a:null}], 10)
//for (let i = 0; i < 10; i++) {
//console.log(f(i))
//}
function useNerdamer(s) {
    if (typeof nerdamer == 'undefined') {
        nerdamer = require('nerdamer/all.min')
    }
}
function solveAndReplace(s, requirements) {
    useNerdamer()
    let a = solveFor(s, 'x')
    if (isNull(a)) {
        console.log('null')
        return
    }
    if (!numberf(requirements, s)) {
        console.log('no')
        return
    }
    s = s.replace(/x/g, a)
    return s
}

function earlyReturn(m) {
    if (m) m = 'early return: ' + m
    console.log(m || 'early return returns null')
    return null
}
function emFunction(key) {
    let name = key.startsWith('em')
        ? key
        : 'em' + capitalize(toCamelCase(key))

    return bringToLife(name)
}

function isBigAdditionorSubtraction(s) {
    const m = findall(/[^\d\s]/, s)
    const ignore = ['*', '/']
    return m.length > 1 && m.every((x) => !ignore.includes(x))
}
function removeEqualSignAndAnswer(s) {
    if (/\b[a-z]\b/.test(s)) return s
    return s.replace(/ *=.+/, '')
}

v = { template: '2 * 3 - 4', letters: 0.5 }
//{ template: '2 * 3 - 4', letters: 0.6 },

function numbersToVariables(s, percentage = 0.6) {
    let m = shuffle(getNumbers(s))
    let vars = Math.round(m.length * (percentage - 0.01))
    let a = rng(0, 26 - vars)
    let b = a + vars
    let letters = alphabet.slice(a, b)
    let store = reduce(m, (x) => {
        vars--
        return letters[vars]
    })
    return store
}

function dreplace3(s, dict, flags) {
    const r = reWrap(dict, flags)
    const f = flags.includes('c')
        ? (_, x) => dict[x]
        : (x) => dict[x]
    return s.replace(r, f)
}
function oxfordComma(items) {
    if (items.length == 2) return items.join(' and ')
    let s = items[0]
    for (let i = 1; i < items.length; i++) {
        s += ', '
        if (isLast(i, items)) s += 'and '
        s += items[i]
    }
    return s
}
function mapArray(x, f) {
    const iterable = prepareIterable(x, 'entries')
    const g = isNestedArray(iterable)
        ? (x) => f(x[0], x[1])
        : (x) => f(x)
    return iterable.map(g)
}

function emFactorPairs(options, answer) {
    const pairs = range(options.start, options.end).map(
        doublef(getFactorPairs)
    )
    return pairs
    console.log(JSON.stringify(pairs))
    throw ''
}

function multiplyf(s) {
    return function lambda(...args) {
        return latex.multiply(...args)
    }
}

function katexArrowFraction(options) {
    /* bigpapa */
    let fontSize = katexFontSize(options.fontSize)
    let [a, b] = toFraction(options.fraction, Array)
    let [c, d] = options.value.map(
        multiplyf(options.multiplier)
    )
    let verticalSpace = options.verticalSpace || '10.8mm'
    let paddingBottomTop = `\\\\[${verticalSpace}]`
    s = `
\\frac{\\,\\,${a}\\,\\,}{\\,\\,${paddingBottomTop}${b}\\,\\,}

\\,\\,
\\begin{array}{c}
     \\${fontSize}\\times\\, ${multiplier}  \\longrightarrow \\\\
 \\hline
    \\${fontSize}\\times\\, ${multipler}  \\longrightarrow
    
\\end{array}
\\,\\, \\frac{\\boxed{\\color{${showTop}}${c}}}{\\boxed{\\color{${showBottom}}${d}}}
    `
    return katexWrapper(s)
}
function katexFontSize(fontSize) {
    const ref = {
        verysmall: 'scriptsize',
        small: 'footnotesize',
    }
    return ref[fontSize] || fontSize
}
var defaultKatexOptions = {}

function katexWrapper(s, displayMode) {
    const options = { displayMode }
    return function lambda(el) {
        return katex.render(s, el, options)
    }
}
function randomFraction(i) {
    if (i > 4) i == 3
    let a = rng(1, 4 - i)
    let b = a + rng(1, 4)
    return toFraction(a, b)
}
function nerdEval2(...args) {
    useNerdamer()
    return nerdEval(...args)
}
function equivalentFractionFactory(s, o = {}) {
    const seen = new Set()
    let count = 0
    return function lambda(f) {
        let [a, b] = getNumbers(f)
        seen.add(b)
        if (count++ == 0) return f
        let copy = b
        let k
        while (seen.has(b)) {
            breaker(40)
            k = rng(2, 5)
            b = copy * k
            if (seen.has(b)) {
                continue
            } else {
                seen.add(b)
                break
            }
        }
        const value = toFraction2(k * a, b)
        return value
    }
}
function sameDenominatorFactory(s) {
    let denom
    return function lambda(f) {
        if (!denom) {
            denom = getDenominator(f)
            if (!denom) return false
            return true
        } else if (getDenominator(f) == denom) {
            return true
        }
    }
}
function nerdFractionArray(items) {
    const sameDenominator = sameDenominatorFactory()
    const equivalentFraction = equivalentFractionFactory()

    if (items.every(sameDenominator)) {
        items = items.map(equivalentFraction)
    }

    let s = items.join(' + ')
    s = fixPlusMinus(s)
    return s
}
function emFractionDecomposition(options, answer = 1) {
    if (!options.terms) options.terms = 2

    let s = answer
    let output = answer
    let store = []
    for (let i = 0; i < options.terms - 1; i++) {
        let t = latex.subtract(s, randomFraction(i))
        s = nerdEval2(t, 'fractions')
        store.push(s)
    }
    let start = nerdFractionArray(store)
    let expr = start + ' + x = ' + answer
    let next = solveFor(expr, 'x')
    store.push(next)
    let question = nerdFractionArray(store)
    return { question, answer }
}
function getNumerator(f) {
    return search(/\/ *(.+)/, f)
}

function getDenominator(f) {
    return search(/\/ *(.+)/, f)
}
function toFraction2(a, b, o = {}) {
    let n
    let d
    if (arguments.length == 2 && isObject(b)) {
        ;[n, d] = a
        o = b
    } else {
        n = a
        d = b
    }

    if (o.simplify) {
        ;[n, d] = simplifyFraction(n, d)
    }
    if (o.kFactor) {
        ;[n, d] = [n * o.kFactor, d * o.kFactor]
    }
    if (o.mode == 'latex') return latex.frac(n, d)
    return n + '/' + d
}
//console.log(fractionDecomposition(2, 2))
function latexImproperFraction(f) {
    /* further fraction equivalencies can be generated here */
    let [a, b] = getNumbers(f)
    if (a == b) return 1
    if (a > b) {
        let [whole, top] = divmod(a, b)
        if (!top) return whole
        return whole + latex.frac(top, b)
    }
    return f
}
function hasIntegers(s) {
    return test(/ \d+ /, s)
}
function noIntegers(s) {
    return !hasIntegers(s)
}
//console.log(latexImproperFraction('60/23'))
function validationFactory(f, validator, transformer) {
    /* precursors:
     * repeatUntilFactory
     * repeatUntil
     * Watcher
     * ...some others I believe
     * */
    /* todo later */
    return f
    if (!validator) return f
    return function lambdaValidator(...args) {
        const value = f(...args)
        if (isObject(value)) {
            return value
        }
        if (validator(value)) {
            /* can put a seen check here */
            /* it is a bad feeling to be late */
        }
    }
}
function vdSudoku(value) {
    /* connects from the last given value of the emSudoku */
    const children = flat(value.data).map((item, i) => {
        const payload = item.answer ? item.value : ''
        const wrapperClass = item.answer
            ? 'sudoku-item'
            : 'sudoku-blank'
        return {
            wrapperClass,
            payload,
        }
    })
    const size = value.dimensions[0]
    return {
        wrapperClass: 'sudoku-grid-' + size,
        children,
    }
}
function emSudoku(options) {
    let f = (x) => x.dimensions[0] == options.size
    let data = read('sudoku.json')
    let sudoku = data.find(f)
    return sudoku
}

function katex1213Example(a, b) {
    /* todo */
    const underline = '\\under'
    const underlines = underline.repeat(3)
    return latex.multiply(a, b) + ' = ' + underlines
}
function vdFunction(s) {
    s = s.replace(/.*?(?=[A-Z])/, '')
    s = 'vd' + s
    console.log({ vd_function_name: s })
    return bringToLife(s)
}

function isExistant(s) {
    let expr = `typeof(${s})`
    return eval(expr) != 'undefined'
}

function isUndefined(x) {
    return x == null
}

function dategetter(date) {
    function parse(s) {
        return s
    }
    if (isString(date)) {
        return new Date(parse(date))
    }
    return date
}
function getAge(date) {
    var today = new Date()
    var birthDate = dategetter(date)
    var age = today.getFullYear() - birthDate.getFullYear()
    var m = today.getMonth() - birthDate.getMonth()
    if (
        m < 0 ||
        (m === 0 && today.getDate() < birthDate.getDate())
    ) {
        age--
    }
    return age
}

const myFamily = [
    {
        name: 'dad',
        birthday: '09-08-1959',
    },

    {
        name: 'maylynn',
        birthday: '05-02-2000',
    },

    {
        name: 'mom',
        birthday: '01-18-1962',
    },

    {
        name: 'yeye',
        birthday: '01-18-1962',
    },

    {
        name: 'lailai',
        birthday: '01-18-1962',
    },

    {
        name: 'justin',
        birthday: '01-18-1962',
    },

    {
        name: 'yijie',
        birthday: '10-01-1989',
    },

    {
        name: 'norah',
        birthday: '09-29-2021',
    },

    {
        name: 'me',
        birthday: '01-31-1990',
    },
]
class Family {
    constructor(family) {
        this.family = family
        /* PersonGroup */
        /*
         * like a family
         * or a team
         * or an event
         * PersonGroups likewise should be able to return
         * additional PersonGroups
         * likewise filtered
         * */
    }
    get(key) {
        switch (key) {
            case 'family':
            case 'cousins':
        }
        const f = (x) => test(key, x.name, 'i')
        const person = this.family.find(f)
        return new Person(person)
        /* dad.get('wife') */
        //oobject-oriented programming right here.
    }
}
//console.log((new Family(myFamily).get('dad')).age)
//console.log(splitKatex0820('value of x is $x = 4-3 got it?'))
//splits but needs help posts to get there

/* foo1 seems to be some sort of question-generator */
/* currently we are on EasyMathGenerator */
/* everything is loaded into this class */

function isPureArithmetic(s) {
    if (/=/.test(s)) return false /* no equations */
    if (/\\/.test(s)) return true /* because latex has words */
    if (isWordy(s)) return false
    return true
}
function isPureProse(s) {
    return !/[\\*+]/.test(s)
}
function qualifiesForVerticalArithmetic(s, vertical) {
    const ops = getOperators(s)
    if (!allSame(ops)) return
    const nums = getNumbers(s)
    if (nums.length > 3) return true
    if (nums.some((x) => len(x) > 3)) return true
}

function allSame(items) {
    return items.every((x) => x == items[0])
}
//console.log(upcomingDate(6))
function writeVueDataAndOpen(value, activeKey) {
    const data = createVariable('outboundData', value)

    const template = `<!DOCTYPE html><html lang="en">
    <head>
        <link rel="stylesheet" href="normalize.css"/>
        <link rel="stylesheet" href="interactive.css"/>
        <script charset="utf8" src="vue.js"></script>
        <script charset="utf8" src="utils.js"></script>
        <script charset="utf8" src="browser.js"></script>
        <script charset="utf8" src="css-utils.js"></script>
        <script charset="utf8" src="vue-utils.js"></script>
        <script charset="utf8" src="mc2.js"></script>
    </head>

    <body><div id="app"></div></body>
    
    <script>
        __activeKey__ = "${activeKey || ''}"
        ${data}
    </script>
    <script>vueLoader(App)</script>
</html>`

    const ofile = require('./node-utils.js').ofile
    ofile('temp-vue-data.html', template)
}

// 09-08-2022
function transformInstructions(s) {
    return s
}
function aggregatorFromColonsToDictionary(s) {
    let config
    ;[s, config] = mget(/^config *= *({.*?\n})/ms, s)

    if (config) {
        config = fixJson(config)
        config = eval(parens(config))
    } else {
        return aggregatorSimpleColonDictionary(s)
    }

    /* parse */
    let current
    const childKeys = Object.keys(config)
    const regex = /^(\S+?:) */m
    const store = {}
    const items = split(s, regex)

    for (let item of items) {
        let label = item.endsWith(':') && backspace(item)
        if (label) {
            if (childKeys.includes(label)) {
                currentKey = label
            } else {
                parentKey = label
                current = store[parentKey] = {}
            }
        } else {
            current[currentKey] = item
        }
    }

    /* post-parse */
    for (let [k, v] of Object.entries(store)) {
        for (let [k2, v2] of Object.entries(config)) {
            if (!v.hasOwnProperty(k2)) {
                if (v2.default == 'parent') {
                    v[k2] = k
                }
            }
            if (v2.transform) {
                let f = isString(v2.transform)
                    ? bringToLife(v2.transform)
                    : v2.transform
                v[k2] = f(v[k2])
            }
        }
    }
    return store
}

function fixJson(s) {
    //s =  s.replace(/^( *)(\w+):/gm, (_, spaces, key) => {
    //return spaces + doublequote(key) + ':'
    //})

    s = s.replace(/^( +)} *$/gm, (_, spaces, key) => {
        return spaces + '},'
    })
    s = s.replace(/[\w\'\"] *$/gm, (x) => x.trim() + ',')
    s = quotifyEverythingExceptNullAndNumbers(s)
    return s
}
function capitalizeTitle(s) {
    const fillerWords = [
        'a',
        'in',
        'to',
        'from',
        'by',
        'of',
        'the',
    ]
    const fn = (x, i) => {
        if (i == 0) return capitalize(x)
        return fillerWords.includes(x) ? x : capitalize(x)
    }
    return splitMapJoin(s, ' ', fn)
}
function quotifyEverythingExceptNullAndNumbers(s) {
    const ignore = ['null', 'true', 'false']
    return s.replace(/[a-zA-Z]{3,}/g, (x) => {
        if (ignore.includes(x)) return x
        return doublequote(x)
    })
}

function dreplace4(s, f) {
    const regex = /\$(\w+)/g
    return s.replace(regex, (_, x) => f(x))
}

function aggregatorSimpleColonDictionary(s) {
    const regex = /^(\S+?:) */m
    const items = split(s, regex)
    return toDictionary(partition(items))
}

MATH_DOC_STRING = `
config = {
    instructions: {
        default: null
        transform: transformInstructions
    }
    title: {
        default: parent
        transform: capitalizeTitle
    }
}

sudoku:
instructions: 
Fill in the empty boxes with a number from 1 to 4.
The rule is no row or column can repeat numbers.



warmup:

`

function defaultMathDocQuestion(o) {
    let question = o.question
    let type = getTypeMathDocQuestion(question)
    let displayMode = true

    switch (type) {
        case 'prose':
            return {
                wrapperClass: 'prose',
                payload: question,
            }

        case 'mixed':
            displayMode = false
        case 'equation':
        case 'arithmetic':
        case 'vertical':
            return {
                component: 'MathDocQuestion',
                payload: {
                    directives: [
                        {
                            name: 'katex',
                            modifiers: {
                                [toCamelCase(type)]: true,
                                displayMode: displayMode,
                            },
                            value: question,
                        },
                    ],
                    staticClass: type,
                },
            }
            break

        case 'object':
        case 'array':
        default:
            throw 'not done yet'
    }
}
function getTypeMathDocQuestion(s, vertical) {
    if (isArray(s)) {
        return 'object'
    }

    if (isObject(s)) {
        return 'object'
    }

    if (isPureArithmetic(s)) {
        if (qualifiesForVerticalArithmetic(s, vertical)) {
            return 'vertical'
        }
        return 'arithmetic'
    }

    if (isPureProse(s)) {
        return 'prose'
    }

    return 'mixed'
}
function hasAlgebra(s) {
    return /[=/]/.test(s)
}

function vdArithmetic(a) {
    return a
    return a.map(defaultMathDocQuestion)
}

function isLongWord(s) {
    return /^[a-zA-Z\']{4,}/.test(s)
}
function goForwardsUntil(items, i, r, dir = 1) {
    while (i > 0 && i < items.length - 1) {
        i += dir
        const item = items[i]
        if (r.test(item)) return item
    }
}
function goBackwardsUntil(items, i, r) {
    return goForwardsUntil(items, i, r, -1)
}
function splitKatexNoHelpingMarkers0908(s) {
    function getType(s, i, items) {
        if (!s) return 'prose'
        if (/^[ia]$/i.test(s)) {
            let prev = goBackwardsUntil(items, i, /\S/)
            let next = goForwardsUntil(items, i, /\S/, 1)
            if (!next) return 'prose'
            if (next.length == 1) return 'math'
            let nextType = getType(next)
            return nextType
        }
        if (numberArrayRE.test(s)) {
            return 'numberArray'
        }
        if (splitRE.test(s)) {
            if (s.trim()) return 'prose'
            return 
        }
        if (/[a-zA-Z']{3,}/.test(s)) return 'prose'
        if (proseWords.includes(s.toLowerCase())) return 'prose'
        return 'math'
    }

    let numberArrayRE = /^ *(?:\d+ *, *)+\d+ *$/
    let splitRE = /(\??!| +|\. +| *(?:\d *, *)+\d+ *|[:,?] *|["]|\.$)/
    const items = s
        .trim()
        .split(splitRE)
        .filter(hasValue)

    let store = []
    let type = ''
    let current = ''

    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        let newType = getType(item, i, items)

        if (i == 0) {
            type = newType
            current = item
        } else if (!newType) {
            current += item
        } else if (newType == type) {
            current += item
        } else {
            store.push({ type, value: current })
            if (type == 'math' && current.endsWith(' ')) {
                current = ' ' + item
            } else {
                current = item
            }
            type = newType
        }
    }

    if (current) {
        store.push({ type, value: current })
    }

    store = changeStore(store)

    return store.map((x) => {
        if (x.type == 'math') x.value = fixMath(x.value)
        return x
    })

    function changeStore(store) {
        for (let i = 0; i < store.length; i++) {
            let prev = store[i - 1]
            let item = store[i]
            let next = store[i + 1]
            if (!prev || !next) continue
            if (prev.type == 'prose' && next.type== 'prose' && isNumber(item.value.trim())) {
                let val = [prev, item, next].map((x) => x.value.trimStart()).join('')
                //bot.push(val)
                store[i].value = val
                store[i].type = 'prose'
                store[i - 1] = null
                store[i + 1] = null
                i++
            }
        }
        return store.filter(hasValue)
    }
}
let fixMathString = curryEnd(fixMath, String)
function katexMixed(s) {
    const items = splitKatexNoHelpingMarkers0908(s)
    return items
        .map((item, i) => {
            const f =
                item.type == 'prose' ? latex.prose : fixMathString

            return f(item.value)
        })
        .join(' ')
}

/* dataWriter is??? */

function getToc(items) {
    return items.map((item, i) => {
        return item.title
    })
}
function upcomingSaturday() {
    return upcomingDate(6)
}

function upcomingSunday() {
    return upcomingDate(7)
}
function normalizeAmounts(items, amount) {
    items.forEach((item, i) => {
        if (
            (item.amount && item.amount > 5) ||
            (item.progression && !item.amount) ||
            false == true
        ) {
            item.amount = amount
        }
    })
}
function skipSkip(items) {
    return items.filter((x) => !x.skip)
}


function aaa(s) {
    return addExtension(s, 'pdf')
}
function ccc(s) {
    return addExtension(s, 'pdf')
}
function bbb(s) {
    return numberGetter(s)
}
function numberGetter(s) {
    const r = /(\d+) *(?:to|-) *(\d+)|(\d+)/g
    const m = findall(r, s).map(([a, b, c], i) => {
        if (c) return Number(c)
        return range(Number(a), Number(b))
    })
    return flat(m)
}
function mathBookRun(s) {
    const f = ([aa, cc, bb]) => {
        const range = bbb(bb)
        //while (range.length > 10) {
            //range.pop()
        //}
        return {
            file: aaa(aa),
            range: range,
            outpath: ccc(cc),
            size: range.length,
        }
    }


    let refString = `
        classwork packet
        homework packet
        quiz
        progress reports
    `
    const base = linegetter(refString).map(capitalizeTitle)
        .map((x) => addExtension(x, 'pdf'))
    const g4 = base.map((item, i) => {
        return 'Grade 4 '+ item
    })
    const g5 = base.map((item, i) => {
        return 'Grade ' + 5 + ' ' + item
    })
    const preset = g4.concat(g5)

    const mathBookRE = /(\w.*?) as (.+)\n+(.+)/g
    s = getLast(split(s, /^\d+-\d+-\d+.+/m))
    let value = findall(mathBookRE, s).map(f)
    value = rigidSort(value, preset, (x) => x.outpath)
    return value
    const files = value.map((x) => x.outpath)
    const subject = 'Grade 4/5 Math Materials ' 
                    + wrap(upcomingSaturday(), [])
    const attachments = JSON.stringify(files)

    const body = bodyItems.map((item, i, a) => {
        item = removeExtension(item)
        let style = ''
        if (i == 0) {
            style = 'style="margin-top: 20px"'
        }

        else if (i == a.length - 1) {
            style = 'style="margin-bottom: 20px"'
        }

        return divify('div', style, [
            divify('span', 'style="font-weight: bold; margin-right: 5px;"', i + 1 + '.'),
            divify('span', '', item)
        ])
    }).join('\n')
    const email = {files, subject, attachments, body}

    return {
        value,
        email,
    }
    json(value)
}
//console.log(parseInt('dfh Grade 5.pdf')); throw '';
// 09-09-2022 mathbook-end
//function rigidSort(items, preset, transform) {

function text(s) {
    const file = 'text.js'
    write(file, join(s))
    ofile(file)
}
//s = read("/home/kdog3682/appscript.temp.json")
//s = unique(map(s, 'sender'))
//clip(s, 0)

//s = read('/home/kdog3682/CWF/raw2.txt')
//clip(getWords(s), 0)
//console.log(katexMixed('hi go a bar x = 3+34234 is cool beans. okay mr. tom'))

function spawnSaturdayWorkSchedule(key = 'saturday', start) {
    //start = '09-10-2022'
    start = start ? dategetter(start) : upcomingDate(key, Date)

    const yearLimit = getYear(start) + 1
    const store = []

    while (true) {
        breaker(20)
        const year = getYear(start)
        if (year == yearLimit) {
            return store
        } else {
            store.push(datestamp(start))
            addTimeToDate(start, 'week')
        }
    }
    return store
}
//console.log(spawnSaturdayWorkSchedule())

function addTimeToDate(start, k) {
    const ref = {
        week: 86400000 * 7,
        day: 86400000,
        minute: 60000,
        hour: 360000,
        second: 1000,
    }

    let [key, negative] = mget(/^-/, k)
    let value = ref[key] || key
    if (negative) value = value * -1
    let time = start.getTime() + value
    start.setTime(time)
    return start
}

//rpw('/home/kdog3682/CWF/public/raw.js', (s) => {
//append('names.list.txt')
//clip(unique(getWords(s)))
//}, 'throw')
//
//

s = `
QUIZ 1 Topics
Comparing fractions
Simplifiying fractions
Converting from an improper fraction into a mixed number
adding, subtracting, multiply fractions
canceling fractions

Rank the fractions from smallest to greatest

Which fraction is different from the other fractions?


Simplify each fraction as much as possible.
Convert the following fractions into a mixed number. Make sure the mixed number is as simplified as possible.

5/4 1 1/4
88/87 = 1-1/87
86/85 = 1 1/86
85/84 = 


Bonus Challenge (1 point)
What is a/b * b/a?


Fourth Grade Quiz
date
names
You are going to do Great!



To sit and enjoy it. 

Tuesday Evening ... I need to send the materials to R.Posner.


Hey Fiona, Two assistants to bounce back and forth.
They have some students.


`

function hasExtension(s) {
    return getExtensions(s)
}

function fixQuotes(s) {
    //const regex = /['"＂〃ˮײ ″״ ‶ ˶ʺ“”˝‟]/g
    // 〃＂
    const regex = /['"ˮײ″״‶˶ʺ“”˝‟]/g
    return s.replace(regex, '"')
}
//rpw('/home/kdog3682/lobel-frog-toad.pdf.json', (s) => {
//s = fixQuotes(s)
//s = s.replace(/" "/g, '"\n"')
//console.log([s]); throw '';
//return s
//}, 'foo.js')

//console.log(magicSquares[3].slice(0, 8).map(toStringMagicSquare).join('\n\n' ))
function toStringMagicSquare(s) {
    return s.map((x) => joinString(x)).join('\n')
    //console.log(s); throw '';
    //return join(s.map())
}
//foo({ debug: 1, write: true, normalizeAmount: true })

const schoolMonths = [
    'September',
    'October',
    'November',
    'December',
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
]
//console.log(schoolMonths.length)
//15000 / 10 = 1500

/* make the bordered aspect have ... something that doesnt go ... it is going to be ... it will ... there are some asp */

function emGuidedMultiplication() {
    const [a, b] = longShort(...parseMathArguments(arguments))

    //const options = {
    //includeZeroes: true,
    //randomProliferate: true,
    //}
    //const mode = 'showAnswers'
    //const mode = 'randomProliferate'
    const mode = 'includeZeroes'

    const kgm = 'guided-multiplication-item katex'
    const kgma = 'guided-multiplication-answer katex'
    const bottomNumbers = split(b)
    const bottomLength = bottomNumbers.length
    const bottomReversed = reverse(bottomNumbers)
    const topNumbers = split(a)
    const topLength = topNumbers.length
    const mapper = (x) => classAndValue(kgm, x)
    const topArray = [classAndValue()]
    topArray.push(...topNumbers.map(mapper))
    topArray.push(classAndValue(kgm, '×'))
    const topGridLength = topLength + 1

    const lengthDifference = topLength - bottomLength
    for (let i = 0; i < lengthDifference; i++) {
        topArray.push(classAndValue(kgm))
    }

    topArray.push(...bottomNumbers.map(mapper))

    const topQuestions = bottomReversed.map((n, i) => {
        return katexVertical([a, n], '*')
    })
    const store = bottomReversed.map((n, i) => {
        return a * n * Math.pow(10, i)
    })

    const bottomArray = []
    const bottomGridLength = len(Math.max(...store))
    for (let item of store) {
        let length = len(item)
        while (length < bottomGridLength) {
            length++
            bottomArray.push(classAndValue())
        }
        const items = split(item)
        const values = items.map((item, i, a) => {
            let value

            if (mode == 'includeZeroes') {
                value = i == a.length - 1 && item == 0 ? 0 : ''
            } else if (mode == 'randomProliferate') {
                value = coinflip(0.5) ? item : ''
            } else if (mode == 'showAnswers') {
                value = item
            } else {
                value = ''
            }
            return classAndValue(kgma, value)
        })
        bottomArray.push(...values)
    }
    //console.log(bottomArray); throw '';

    return {
        top: topArray,
        bottom: bottomArray,
        topGridLength: topGridLength,
        bottomGridLength: bottomGridLength,
        answer: split(a * b),
        //topQuestions,
        //question: [a, b],
        //bottom: store,
    }
}
function parseMathArguments(args) {
    if (args.length == 2) {
        return args
    }
    return getNumbers(args[0])
}
function classAndValue(a, b) {
    if (!isDefined(a)) a = ''
    if (!isDefined(b)) b = ''
    return {
        class: a,
        value: b,
    }
}

//console.log(guidedMultiplication(234, 56))
function monthDay() {
    const date = new Date()
    const month = zeroPad(date.getMonth() + 1)
    const day = zeroPad(date.getDate())
    return month + day
}

function exponentSeries1(a, b) {
    return `${a}^${b} = ${a}${(' \\times ' + a).repeat(
        b - 1
    )} = \\boxed{\\vphantom{\\Large |}\\color{white}8888}`
}
//console.log(exponentSeriesThing(3, 4))

//nerdamer = require("nerdamer/all.min")
//console.log(arithmeticVariations('a + b * c - d', 10)) // PEMDAS
function multiplesOf(n, amount = 9) {
    return map(amount, (x) => n * x)
}
//console.log(multiplesOf(32))
//console.log(37/32)

//console.log(createSequence())

function createSequence2() {
    const s = sequenceFromEquation('r')
    console.log({ s })
    throw ''
}

function pokeArrayHoles(a, amount) {
    const indexes = getRandomIndexes(a, amount)
    return a.map((item, i) => {
        if (indexes.includes(i)) return null
        return item
    })
}

function getRandomIndexes(a, amount) {
    const store = []
    if (amount >= a.length) {
        throw 'throw'
    }
    for (let i = 0; i < amount; i++) {
        let index = rng(0, a.length - 1)
        if (store.includes(index)) {
            i--
            continue
        }
        store.push(index)
    }
    return store
}
//console.log(createSequence2([1,2,3,4], 3))

const progression = [
    { terms: 6, blanks: 1, yint: 2, start: 0, last: 1 },
    { terms: 6, blanks: 1, yint: 10, last: 1 },
    { terms: 7, blanks: 2 },
    { terms: 8, blanks: 2 },
    { terms: 8, blanks: 3 },
    { terms: 10, blanks: 4 },
]

function wrapData(key, value) {
    return {
        key,
        value,
    }
}
//aggregatorFromColonsToDictionary(MATH_DOC_STRING)

/* it goes a certain way ... */
/* to get this done with */
/* to not hurt anything */
//

function getRemainder(a, b) {
    return a % b
}
function passTimeMathSameRemainder(a = 463, b = 503) {
    return getFactors(b - a)
    let end = Math.floor(Math.min(a, b) / 2)
    const store = []
    for (let i = 2; i < end; i++) {
        let ra = getRemainder(a, i)
        let rb = getRemainder(b, i)
        if (ra == rb) {
            store.push(i)
        }
    }
    /* sum of the factors of 40 */
    return store
}
//console.log(passTimeMathSameRemainder())
//nerd = reduce(nerd, (k, v) => [k, compose(nerdEval, v)])

//There is a box with 5 gold coins and 5 silver coins.
//You pick a coin and it is gold.
//What is the percent chance the next coin picked is also good?

//console.log(longDivision(12, 5))

function rainbow(numOfSteps = 3, step = 1) {
    // Adam Cole, 2011-Sept-14
    var r, g, b
    var h = step / numOfSteps
    var i = ~~(h * 6)
    var f = h * 6 - i
    var q = 1 - f
    switch (i % 6) {
        case 0:
            r = 1
            g = f
            b = 0
            break
        case 1:
            r = q
            g = 1
            b = 0
            break
        case 2:
            r = 0
            g = 1
            b = f
            break
        case 3:
            r = 0
            g = q
            b = 1
            break
        case 4:
            r = f
            g = 0
            b = 1
            break
        case 5:
            r = 1
            g = 0
            b = q
            break
    }
    return (
        '#' +
        ('00' + (~~(r * 255)).toString(16)).slice(-2) +
        ('00' + (~~(g * 255)).toString(16)).slice(-2) +
        ('00' + (~~(b * 255)).toString(16)).slice(-2)
    )
}

function spanify(value, options) {
    console.log(options)
    const attrs = Object.entries(options)
        .reduce((acc, [a, b], i) => {
            acc += a + '="'
            if (b == 'style') {
                if (isObject(b)) {
                    for (let [k, v] of Object.entries(b)) {
                        acc += k + ':' + v + '; '
                    }
                }
                acc = acc.trim()
            }
            acc += '" '
            return acc
        }, '')
        .trim()
    return divify('span', attrs, value)
}

function infuseSpanColors(s, colors) {
    if (isArray(colors)) {
        colors = reduce(colors, rainbow)
    }
    const regex = ncg(' ($1) |({{$1}})', colors)
    return replace(
        regex,
        (_, a, b) => {
            let value = a || b
            let color = colors
                ? colors[getFirstWord(value)]
                : rainbow()
            return spanify(value, { style: { color } })
        },
        s,
        'g'
    )
}

function lineNeedsEndingColon(s) {
    if (test(/[^a-zA-Z]$/, s)) {
        return false
    }
    const words = ['is', 'of', 'currently', 'has', 'be']
    let word = getLastWord(s)
    if (words.includes(word)) {
        return true
    }
}

function generatePassword({
    length = 6,
    capitals = false,
    numbers = true,
    startingNumber = false,
}) {
    let charset = 'abcdefghijklmnopqrstuvwxyz'
    if (capitals) {
        charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    }
    if (numbers) {
        charset += '0123456789'
    }

    let s = ''
    for (var i = 0, n = charset.length; i < length; ++i) {
        s += charset.charAt(Math.floor(Math.random() * n))
    }
    return s
}

function prepareReddit(s) {
    const keys = Object.keys(subreddits)
    const regex = toRegExp(
        '^(?:($1|@\\w+) (.+))',
        subreddits,
        'm'
    )
    const items = partition(split(s, regex), 3)
    return map(items, parser)

    function parser([key, title, body]) {
        key = key.replace('@', '')
        if (key in subreddits) {
            key = subreddits[key]
        }
        title = capitalizeTitle(spellcheck(title), 1)

        return {
            subreddit: key,
            title: title,
            body: fixSpellingAndGrammar(body),
        }
    }
}

const subreddits = {
    e: 'express',
    math: 'cheatatmathhomework',
    mhw: 'cheatatmathhomework',
    ebs: 'explainbothsides',
    ck: 'cooking',
    cook: 'cooking',
    ap: 'askprogramming',
    ljs: 'learnjavascript',
    js: 'learnjavascript',
    lp: 'learnpython',
    me: 'mementomoriok',
    nsq: 'nostupidquestions',
    vue: 'vuejs',
    py: 'learnpython',
    p: 'learnpython',
    eli5: 'explainlikeimfive',
    vim: 'vim',
    v: 'vim',
    vimrc: 'vim',
    css: 'css',
}

function runReddit(s) {
    const spellcheck = spellcheckf()
    rpw(
        '/home/kdog3682/CWF/questions.txt',
        '/home/kdog3682/CWF/public/questions.json',
        prepareReddit
    )
}

function oneThird(x) {
    return Math.round(x * 0.33)
}

function allDone(x) {
    return x.every((x) => x.done)
}

function formatLevelName(n, mode) {
    if (mode == 'roman') {
        n = romanCase(n)
    } else if (mode == 'letter') {
        n = numberToWord(n).toUpperCase()
    }
    let prefix = 'ROUND'
    return prefix + ' ' + n
}

function splitOnPeriods(s) {
    return flat(
        linegetter(s).map((x) => {
            const value = split(x, /([.?]) /)
            return joinOn(split(x, /([.?]) /))
        })
    )
}

function joinOn(items) {
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        if (item == '.' || item == '?') {
            items[i - 1] += item
            items[i] = null
        }
    }
    return items.filter(notNull)
}

function literal(s) {
    if (isArray(s)) {
        s = s.join('\n' + latex.newline() + '\n')
    }
    return clip(s, 0)
}
function katexVerticalAlign(numbers, operator) {
    if (operator == '-' && numbers.length > 2) {
        limitSize(numbers, 2)
    }

    const f = (x) => x.toString().replace(/\./, '&.')
    const g = (x) => `${operator} ${'\\, '.repeat(len(x) * 2)} ${x}`

    numbers = numbers.map(f)
    edit(numbers, -1, g)

    let s = `\\begin{align*} ${numbers.join(' \\\\ ')}
             \\\\ \\hline \\end{align*}`
    return s
}
//literal(katexVertical([123.45, 6.006, 54, 67823]))
function limitSize(a, n) {
    while (a.length > n) {
        a.pop()
    }
}

//console.log(longDivision(817152, 38))
//The part of long division with big nm
//use the multiplication tables provided to help you.
//i will go on Friday
//u dont know how many days it will take in order for the package to be delivered.

function fillInTheOperators(elements) {
    //2 \,\,\boxed{\color{white}*}\,\, 3 \,\,\boxed{\color{white}*}\,\, = 44
    const spaces = latex.spaces(2)
    const box = latex.emptyBox('*')
    const el = spaces + box + spaces
    const items = elements.map((item, i) => {
        if (item == null) return el
        if (item == '=') return item
        if (isNumber(item)) return item
        return latex.fixOperator(item)
    })
    const value = items.join(' ')
    return value
}
//literal(fillInTheOperators([2, null, 6, '+', 12, null, 4, ' = ', 34]))

function crossBreed(a, b, f) {
    const store = []
    for (let c of a) {
        for (let o of b) {
            let base = interweave(c, o)
            let results = f(base)
            push(store, results)
        }
    }
    return store
}
function brute24(card, {answer = 24, amount = 2} = {}) {
    let ops = permuteWithRepetition(MATH.operators.easy)
    let cards = permute(card)
    let store = crossBreed(cards, ops, getParenPermutations)
    let values = store.filter((x) => eval(x) == answer)

    let f = (x) => getOperators(x).join('')
    let watcher = new Watcher(f)
    let payload = watcherUnique(watcher, values, true)

    return payload
}


function permuteWithRepetition(a) {
  var store = [];
  var recursiveABC = function(singleSolution) {
      if (singleSolution.length > 2) {
        store.push(singleSolution);
        return;
      }
      for (var i=0; i < a.length; i++) {
        recursiveABC(singleSolution.concat([a[i]]));
      }
  };
  recursiveABC([]);
  return store;
};
function getParenPermutations(s) {
    //s = "2 + 3 + 4 + 5"
      const items = split(s, ' ')
      const a = [12, 13, 34, 23, 24, 1234].map((x) => {
        return split(x).map((x) => x - 1)
      })

      return a.map(([a,b,c,d]) => {
          let count = 0
          const els = copy(items)
          for (let i = 0; i < els.length; i++) {
              let el = els[i]
              if (isNumber(el)) {
                  if (count == a) {
                      els[i] = '(' + els[i]
                  }

                  else if (count == b) {
                      els[i] = els[i] + ')'
                  }

                  else if (count == c) {
                      els[i] = '(' + els[i]
                  }

                  else if (d && count == d) {
                      els[i] = els[i] + ')'
                  }
                  count++
              }
          }
          return els.join(' ')
      })
}
//literal(brute24([1,2,3,4], 24))

function halfOf(x) {
    if (isArray(x)) {
        return x.slice(0, Math.floor(x.length / 2))
    }
}
function isOperator(s) {
    return mathOperators.includes(s)
}

function poke(a, key) {
    let length = a.length
    if (!key) return a
    if (key == 'patternDiamond') {
        switch (length) {
            case 9:
                indexes = [1, ]
        }
    }
    if (isNumber(key)) {
        return pokeArrayHoles(a, key)
    }
}
function emMultiplicationTable({rows = 3, columns = 3, min = 2, max = 9, holes = null} = {}) {
    /* need to fix the alignments */

    rows = map(rows, () => rng(min, max))
    columns = map(columns, () => rng(min, max))

    let body = cartesianProduct([columns, rows])
        .map(([a,b]) => multiply(a,b))

    body = poke(body, holes)
    increment = incrementf('A')
    rows = map(rows, increment)
    columns = map(columns, increment)

    return {
        rows, 
        columns, 
        body,
        width: columns.length,
    }
}
//

function patternDiamond(size) {
  let col = size * 2 - 1;
  const store = []
  for (let i = 1; i <= size; i++) {
    let s = "";
    for (let j = 1; j <= col; j++) {
      if (j >= size + 1 - i && j <= size - 1 + i) {
        s += "$";
      } else {
        s += " ";
      }
    }
    store.push(s)
  }
  for (let i = size - 1; i >= 1; i--) {
    let s = "";
    for (let j = 1; j <= col; j++) {
      if (j >= size + 1 - i && j <= size - 1 + i) {
        s += "$";
      } else {
        s += " ";
      }
    }
    store.push(s)
  }
  return store.join('\n')
  return store
}
//console.log(patternDiamond(3))

function patternCross(n) {
    const store = []
  if (n % 2 === 0 || n < 3) {
    return;
  }

  for (let y = 0; y < n; y++) {
    let line = "";
    for (let x = 0; x < n; x++) {
      line += x == y || x == n - 1 - y ? "x" : " ";
    }
    store.push(line)
  }
  return store.join('\n')
}
function getPatternIndexes(s) {
    const items = s.split('\n').map((x) => x.split(''))
    const width = items[0].length
    const body = flat(items)
    const indexes = []
    const empty = []
    const dollar = body.includes('$')
    body.forEach((item, i) => {
        if (dollar) {
            if (item == '$') {
                indexes.push(i)
            }
            else {
                empty.push(i)
            }
            return 
        }
        if (item.trim()) {
            indexes.push(i)
        }
        else {
            empty.push(i)
        }
    })
    return {
        width,
        indexes,
        empty,
        length: body.length,
    }
}

//console.log(getPatternIndexes(patternCross(5)))

function patternHollowDiamond(row) {
  let s = "";
 let extra = 1
// upper
  for (i = 1; i < row + 1; i++) {
    s += "\n";
    for (j = 1 + extra; j <= row - i + 1; j++) {
      s += "*";
    }
    for (j = 1; j <= 2 * i - 1; j++) {
      if (j == 1 || j == 2 * i - 1) {
        s += "$";
      } else {
        s += " ";
      }
    }
    for (j = 1 + extra; j <= row - i + 1; j++) {
      s += "*";
    }
  }
// bellow
  for (i = row - 1; i > 0; i--) {
    s += "\n";
    for (j = 1 + extra; j <= row - i + 1; j++) {
      s += "*";
    }
    for (j = 1; j <= 2 * i - 1; j++) {
      if (j == 1 || j == 2 * i - 1) {
        s += "$";
      } else {
        s += " ";
      }
    }
    for (j = 1 + extra; j <= row - i + 1; j++) {
      s += "*";
    }
  }
  console.log(s)
  return s;
}
//console.log(getPatternIndexes(patternHollowDiamond(2)))


function removeDuplicates(arr) {
  const watcher = new Watcher()
  return watcherUnique(watcher, arr)
}

function watcherUnique(watcher, values, reverse) {
    const payload = []
    values.forEach((item, i) => {
        if (watcher.isFresh(item, reverse)) {
            payload.push(item)
        }
    })
    return payload
}

function exports() {
    if (typeof window !== 'undefined') {
        return 
    }
    const ref = {mathBookRun}
    module.exports = ref
}
//console.log([].toString())
//mathBookRun('s')
function clipData(s) {
    return clip(s, 'append')
}

console.clip = clipData
//clip(guidedMultiplication(234, 56), 'append')
//clip(wrapData('sequences', progression.map(emNumberPatterns)), 'append')
//wrapData ... makes it so that ...
//

function emMultiplicationFactorTuples() {
    function getIndexes(pairs, answer) {
        let store = [0]
        //let length = pairs.length
        //if (length == 1) {
            //if (answer < 20) return [0]
            //else if (coinflip()) return [0]
        //}
        if (pairs.length > 3) {
            store.push(rng(1, 3))
        }
        return store
    }
    let numbers1 = shuffle(range(2, 20)).slice(0, 5)
    let numbers2 = shuffle(range(30, 80)).slice(0, 5)
    let value = sort(numbers1.concat(numbers2))
    .map((answer) => {
        let pairs = getFactorPairs(answer)
        let indexes = getIndexes(pairs, answer)
        let elements = pairs.map((el, i, a) => {
            if (indexes.includes(i)) {
                return latex.times(...el)
            }
            return null
        })
        return {
            elements,
            answer,
        }
    })
    return value
}
//console.log(emMultiplicationFactorTuples())
//console.clip(emMultiplicationTable())
// to move back ... i miss the park ... i dont like being all in the open
//



const emItems = [
  "emGuessForX",
  "emMoreThanLessThan",
  "emOrderedMultiplication",
  "emArithmetic",
  "emMultiplicationSubtraction",
  "emNumberPatterns",
  "emFunction",
  "emFactorPairs",
  "emFractionDecomposition",
  "emSudoku",
  "emMultiplicationTable",
  "emMultiplicationFactorTuples"
]

function stringEval(s, ...args) {
    let expr = toStringCallable(s, ...args)
    return eval(expr)
}
function vueMaker(s) {
    const name = fuzzyMatch('e' + s, emItems)
    const value = stringEval(name)
    assert(value)
    const vueName = 'V' + name.slice(2)
    const payload = [
        vueName,
        value,
    ]
    clipData(payload)
    //ofile('test2.html')
}

function dollarify(attrVar) {
    //return `\${${attrVar}}`
}

function wrapFactory(f, ...args) {
    if (args.length == 1) {
        return (first, ...rest) => {
            return f(args[0](first), ...rest)
        }
    }

    if (args.length == 2) {
        return (first, second, ...rest) => {
            return f(args[0](first), args[1](second), ...rest)
        }
    }
}

function getConstructorName(s) {
    return s && s.constructor && s.constructor.name
}
//console.log(getConstructorName(Storage)); throw '';




function googleGetStartFromRangeKey(rangeKey) {
    let s = search(/^\w+/, rangeKey)
    let [a,b] = [s[0].toLowerCase(), s.slice(1)]
    return [char2n(a), Number(b)]
}
//console.log(googleGetStartFromRangeKey('C7:33')); throw '';


//console.log(char2n('A'.toLowerCase()))
//console.log(vueMaker('mft'))
s = "steph"
const studentz = ['Stephanie Li']

function nameMatch(key, ref, presets = {}) {
    key = key.toLowerCase()
    if (ref.includes(key)) {
        return [ref[key]]
    }
    if (presets[key]) {
        return [presets[key]]
    }
    if (key.length < 4) {
        let ent = ref.filter((x) => {
            let abrev = 
             splitMapJoin(x.toLowerCase(),' ', (x) => x[0], '')
            return abrev == key
        })
        if (exists(ent)) return ent
    }

    const value = ref.filter(namef(key))
    return exists(value) ? value : null
}
function namef(key, transform = identity) {
    return function lambda(s) {
        let r = RegExp('^' + key, 'i')
        return r.test(s)
    }
}
//console.log(nameMatch('s'))
s = `
::g4q1
dh 94
and95
arc
ad32
al45

::g4q2
dh 94
and95
b34
ax
`

const gradeRegexes = [
    /:+(.+)/,
    ///([a-zA-Z]+) *(\d*)/g
    /([a-zA-Z]*[a-wy-z]) *([x\d]*)/g
]
function pairAbrevsToRef(abrevs, ref) {

    const presets = {
        jw: 'Jamin Weng',
        'steg': 'Stephanie Li',
        oj: 'Olivia Jiang',
        'steph': 'Stephanie Li',
        'sj': 'Shu Jing Zhao',
        'mr': 'Ming Rui Zhu',
        'stev': 'Stephen Mai',
        'fl': 'Felix Lee',
        'jl': 'Jeffery Liang',
    }

    let store = {}

    for (let abrevGroup of abrevs) {
        let pool = ref.filter((x) => {
            return x.toLowerCase().startsWith(abrevGroup[0][0])
        })

        let originals = copy(abrevGroup)
        let tally = new Tally()
        let abrev

        while (true) {
            breaker(200)
            if (abrev && tally.add(abrev) == 3) {
                console.log('seen many times popping', abrev)
                pop(abrevGroup, abrev)
                continue
            }
            abrev = modularIncrement(abrevGroup, abrev)
            if (!abrev) {
                console.log('no abrev', 'breaking')
                for (let item of originals) {
                    if (!store[item]) store[item] = ''
                }
                break
            }
            let possibles = nameMatch(abrev, pool, presets)
            if (possibles) {
                if (possibles.length == 1) {
                    store[abrev] = possibles[0]
                    pop(pool, possibles[0])
                }
                else {
                    console.log('continuing')
                }
                continue
            }
        }
    }
    console.log(store)
    return store
}
function partitionByAlphabeticalOrder(items) {
    const storage = new Storage()
    items.sort()
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        let letter = item[0].toLowerCase()
        storage.add(letter, item)
    }
    return Object.values(storage.value)
}

function generateJsonFromText(key) {

    /* a way to find the next available item */
    const s = normRead(addExtension(key, 'txt'))

    let assumptiveScores = {
        
    }
    let studentNames
    let absences

    ;[text, studentNames] = mget(/[^]*?(?=:)/, s)
    studentNames = linegetter(studentNames)
    const tokenizer = new Tokenizer3(gradeRegexes)
    //console.log(tokenizer.run(text)); throw '';
    const items = groupByLabel(tokenizer.run(text), (x) => isString(x) && /^(hw|q)/.test(x))
    //console.log(JSON.stringify(items)); throw '';
    const allAbrevs = partitionByAlphabeticalOrder(unique(flat(Object.values(items).map((x) => x.map((x) => x[0])))))
    //console.log({allAbrevs}); throw ""
    const nameRef = pairAbrevsToRef(allAbrevs, studentNames)
    //console.log(len(unique(Object.values(nameRef))))
    //return
    //console.log({nameRef}); throw ""

    let storage2 = new Storage()
    for (let [k, v] of Object.entries(items)) {
        let seen = []
        for (let [a, b] of v) {
            a = nameRef[a]
            seen.push(a)
            if (b != 'x') {
                b = Number(b)
                if (b < 30) b = 100 - b
            }
            storage2.add(a, k, b)
        }
        let leftovers = unique(studentNames, seen)
        for (let name of leftovers) {
            let assumptiveScore = 
                (assumptiveScores[name] || 94)
            storage2.add(name, k, assumptiveScore)
        }
    }
    //console.log(nameRef); throw '';
    console.log(storage2.value)
    return storage2.value

}

function normAppend(file, data) {
    return require('./node-utils.js').normAppend(file, data)
}

function normRead(file) {
    return require('./node-utils.js').normRead(file)
}



function emSum10({n = 2, target = 10} = {}) {
    let count = 0
    let store = []
    let letters = []
    let start = 1
    let end = target

    function creator(n) {
        let s = ''
        let spaceString = '  '
        for (let i = 0; i < n; i++) {
            let ch = n2char(i)
            letters.push(ch)

            let spaces = spaceString.repeat(i)
            s += `${spaces}for (let ${ch} = ${start}; ${ch} < ${end}; ${ch}++) {\n${spaceString.repeat(i + 1)}`

            start = ch
        }


        s += `${spaceString.repeat(n)}runner(${letters.join(', ')})\n`
        for (let i = n - 1; i > -1; i--) {
            let spaces = '    '.repeat(i)
            s += spaces + '}\n'
        }

        expr = ''
        expr += sumRunner(letters, target)
        expr += period
        expr += oxfordJoin(letters.map(upperCase))
        expr += ` are each different numbers from 1 to ${end}.`

        return s
    }
    function runner(...args) {
        const total = sum(args)
        if (total != target) {
            return 
        }
        if (unique(args).length != args.length) {
            return 
        }
        store.push(args)
    }
    function sumRunner(args, target) {
        let s =  args.map(upperCase).join(' + ')
        if (isDefined(target)) {
            s += ' = ' + target
        }
        return s
    }

    let expr
    eval(creator(n))
    if (store.length > 1) {
        let sample = store.pop()
        expr += ' One way of doing it is ' 
        expr += sumRunner(sample, target) + period
        expr += `Try to find ${Math.min(3, store.length)} more ways of doing it`
        expr += period
        expr += `Important: All ${letters.length} numbers need to be different because ${oxfordJoin(letters.map(upperCase))} are each different letters`
        expr += period
        /* there has got to be a way to languagify it */
    }

    return {
        store,
        expr,
    }
}



function upperCase(s) {
    if (isString(s)) {
        return s.toUpperCase()
    }
    return s
}
function lowerCase(s) {
    if (isString(s)) {
        return s.toLowerCase()
    }
    return s
}

function emAddingTens({amount = 3} = {}) {
    const numbers = numbergen({amount})
    const items = range(4).map((item, i) => {
        return numbers.map((x) => x * Math.pow(10, i))
    })
    return items
}

//console.log(emAddingTens())
//console.log(emSum10({n: 4, target: 15}))
//console.log(emGuessForX())

function mapper0926(obj) {
    const store = {}
    const ref = {
        q1: 7,
        quiz1: 7,
        hw1: 2,
        hw2: 6,
    }
    for (let [k, v] of Object.entries(obj)) {
        let key = ref[k]
        store[key] = v
    }
    const indexes = Object.values(ref)
    for (let i = 1; i <= 8; i++) {
        if (!store.hasOwnProperty(String(i))) {
            store[i] = null
        }
    }
    return Object.values(store)
}


function mapObject(o, f) {
    const store = {}
    const g = countParameters(f) == 2 ? f : (k, v) => f(v)
    for (let [k, v] of Object.entries(o)) {
        store[k] = g(k, v)
    }
    return store
}



let studentScoreDataRef = {
    'Shu Jing Zhao': [1,10,10,10,1,10,10,10]
}



async function fetchPost(url, data) {
    const fetch = require('node-fetch')
    return await fetch(url, {
        method: 'POST',
        body: JSON.stringify(data),
        headers: { 'Content-Type': 'application/json' },
    })
        .then((res) => res.json())
        .then((json) => {
            return json
        })
}

async function doGoogle2(f, options = {}) {
    let callable = toStringCallable(f, options.args || [])
    let s = read(appscriptfile) + '\n\n' + callable
    return await fetchPost(appscripturl, { evaluate: s })
}
async function doGoogle(data, f = 'uploadStudentScoreData', ...args) {
    async function callGoogle(f, data) {
        let appscriptfile = '/home/kdog3682/CWF/public/app2.js'
        let googleUrl =
            'https://script.google.com/macros/s/AKfycbx3VFYdpdvIOMu6g5WFs4965dcYf7rTfF3YKDZ-Hr-KmUVut9My7qcOeqpeSJuMGbY3/exec'

        let callable = f ? toStringCallable(f, data, ...args) : ''
        //console.log(callable)
        //return
        let s = read(appscriptfile) + '\n\n' + callable
        return await fetchPost(googleUrl, { evaluate: s })
    }

    return await callGoogle(f, data)
}


function googleUploadGrades(gradeLevel) {
    const data = mapObject(generateJsonFromText('g' + gradeLevel), mapper0926)
    let sheetKey = 'Grade ' + gradeLevel
    doGoogle(data, 'uploadStudentScoreData', sheetKey)
}

//googleUploadGrades(5)

const EasyMathHandlerRef = {
    emMysteryAlphabetAddition: {
        args: {
            String(s) {
                return s
            },
            Null(s) {
                return '34 + 57'
            },
            Object(s) {
                const numbers = numbergen(s)
                const expression = numbers.join(' + ')
                return expression
            },
        },
        postParse(o) {
            //return {
                //answer: o.answerRef,
                //question: o.items,
                //type: 'ff'
            //}
        },
    }
}
function emMysteryAlphabetAddition(options = {}) {
    // 10-10-2022 
    const expression = options.expression
    const answer = nerdEval(expression)
    const numbers = parseArithmetic(expression)
    const operator = getOperator(expression)

    const digits = tally(numbers.join('').split(''), Array)
    let [A, B] = partitionByFunctions(digits, (x) => x[1] > 1)
    B = shuffle(B, true) /* make a copy of it */
    const digits2 = A.concat(B)
    const n = options.mysteryLetterCount || numbers.length - 0
    const digitOrder = digits2.map((x) => x[0]).slice(0, n)

    const increment = incrementf('A')
    const answerRef = {}
    const seen = {}
    const transformer = (item, i) => {
        return item.toString().replace(/\d/g, (x) => {
            if (digitOrder.includes(x)) {
                if (seen[x]) {
                    return seen[x]
                }
                let letter = increment()
                seen[x] = letter
                answerRef[letter] = x
                return letter
            }
            return x
        })
    }
    let answerString = transformer(answer)
    let numberStrings = numbers.map(transformer)
    return {
        operator,
        groups: [numberStrings, [answerString]],
        answerRef,
        expression,
    }

}



function html2json(x) {
    var f = require('html2json').html2json
    return f(x).child[0].child[0]
}
//doGoogle2('getDocumentAsHtml').then((x) => json(html2json(x)))

//c3 = bolditalic
//c1 = regular
//c2 = paragraph line
//c11 = bold
//c12 = italic

//let textChild = o.tag == 'p' && o.child && o.child && o.child.child
//let singletonNodeText = textChild && textChild.length == 1 && textChild[0].text

class HtmlObjectParser {
    constructor(obj) {
        this.runner(obj)
    }
    runner(obj) {
        let f = this[obj.tag]
        if (f) return f(obj)

        for (let child of obj.child) {
            runner(child)
        }
    }
    /* ---------------------------- */
    p(s) {
        return s.child.map((node, i) => {
            if (node.text) {
                return node.text
            }
            return node.child[0].text
        })
    }
    table(s) {
        
    }
}
//new HtmlObjectParser(clip())
//s = clip()
//parser(s)
//clip(s)

//console.log(fixExpression('time for the beach. 100^100 * 100^99 = x^198 * 100^y. x + y = ? $input(101)'))

s = `
2500t4p=25t4 and then add 2 zeros and then remove 2 zeroes
2500t4p=100

how many years will it take to get to 500qm

`
//exports()
//G4/G5 Math [10/01/2022]

//json((mathBookRun(normRead('mathbook.raw.txt'))))

function cliprw(f) {
    rpw(clipfile, f)
}



function walk(x, fn) {
    function walker(key, value) {

        if (isArray(x)) {
            return x.map((item) => walker(key, item))
        }

        else if (isObjectLiteral(x)) {
            return Object.entries(x).reduce((acc, [a, b]) => {
                const value = walker(a, b)
                if (value != null) {
                    acc[a] = value
                }
                return acc
            }, {})
        }

        else {
            return fn(a, b)
        }
    }
    return walker(x)
}
//console.log(nestobj)
//s = read('clip2.js')
//console.log(s)
function g(key, value) {
    console.log(key, value)
    if (key == 'da') return 
}
//console.log(walk(nestobj, g))

// the students are very hard to teach.
// for the students who can take it.

// Something easier to do.
// Low hanging fruit.


function announce(...args) {
    console.log(...args)
}


// There is nothing that I can do which would win their respect.
// There is absolutely nothing that would be effective.
// And I guess that is okay. 

function toggle2(state, key, from, to, duration = 750) {
    let value
    if (arguments.length == 2) {
        value = opposite(state[key])
        state[key] = value
        return value
    }

    if (arguments.length == 3) {
        if (isFunction(state)) {
            return toggleFunction(...arguments)
        }
        if (isBoolean(state[key])) {
            from = state[key]
            to = !state[key]
            duration = arguments[2]
        } else {
            to = from
            from = state[key]
        }
    }

    state[key] = to
    setTimeout(() => {
        state[key] = from
    }, duration)
}

function walk(x, fn, depthLimit = 7) {
    function walker(x, depth, a) {
        if (depth > depthLimit) {
            return evaluator(x)
        }
        if (isArray(x)) {
            return x.map((y) => walker(y, depth + 1))
        }

        if (isObjectLiteral(x)) {
            return Object.entries(x).reduce((acc, [a, b]) => {
                acc[a] = walker(b, depth + 1, a)
                return acc
            }, {})
        }
        return evaluator(x, depth, a)
    }

    function evaluator(x, depth, a) {
        const value = fn(x, depth, a)
        return value == null ? x : value
    }
    return walker(x, 0)
}
function reduceToString(iterable, fn, options = 'entries') {
    if (!fn && isObject(iterable)) {
        fn = (k, v) => v
    }
    let mode = 'entries'
    let delimiter
    if (isObject(options)) {
        mode = options.mode
        delimiter = options.delimiter || null
    }
    iterable = prepareIterable(iterable, mode)
    const runner = isDoubleIterable(iterable)
        ? (x, i) => fn(...x, i)
        : fn
    const values = iterable.map(runner).filter(exists)
    return values.join(delimiter || '\n')
}

function oldEdit(x, ...args) {
    /* functions are internal */
    if (isArray(x)) {
        return editArray(x, ...args)
    }

    if (isObject(x)) {
        return editObject(x, ...args)
    }

    function editArray(items, index, value) {
        if (isNumber(index) && index < 0) {
            index = items.length + index
        }
        if (isNestedArray(items)) {
            index = items.findIndex((x) => x[0] == index)
            items[index][1] = fparse(value, items[index][1])
        }
        else {
            items[index] = fparse(value, items[index])
        }
        return items
    }

    function editObjectFunctional(object, kt, vt) {
        return reduce(object, (k, v) => {
            if (kt) k = kt(k)
            if (vt) v = vt(v)
            return [k, v]
        })
    }

    function editObject(obj, key, fn) {
        if (isFunction(key)) {
            obj = editObjectFunctional(...arguments)
        } else {
            obj[key] = fn(obj[key])
        }
        return obj
    }

    function editObject2(obj, fn) {
        const value = fn(key, obj[key])

        if (isArray(value) && value.length == 2) {
            obj[value[0]] = value[1]
        } else if (value != null) {
            obj[key] = value
        }
        console.log(obj)
        return obj
        /* not in use */
    }
}
function oldTemplater(s, ref, keep) {
    if (!s.includes('$')) {
        if (isObject(ref)) {
            return dreplace2(s, ref)
        }
        return s
    }

    if (!ref)
        return s.replace(/\$\{(.*?)\}/g, (_, x) => eval(x))
    let regex = /\$(\w)/g
    if (isPrimitive(ref)) {
        ref = [ref]
    } else {
        regex = /\$(\w+)/g
    }

    let functionals = []
    let offset = s.includes('$0') ? 0 : 1
    let value = s.replace(regex, (_, x) => {
        if (x == 'c') return '$c'
        let val = isArray(ref)
            ? ref[Number(x) - offset]
            : ref[x]
        if (val == null) {
            return keep ? '$' + x : ''
        }
        if (isFunction(val)) {
            functionals.push(val)
            return '###'
        }
        return val
    })

    if (exists(functionals)) {
        let parts = value.split(/###(?:\(.*?\))?/)
        return (a, b, c) => {
            let s = ''
            for (let i = 0; i < parts.length; i++) {
                let part = parts[i]
                s += part
                if (i < parts.length - 1) {
                    s += functionals[i](a)
                }
            }
            return s
        }
    }
    return value
}
function oldNcg(template, ref, escape) {
    if (typeof template == 'object' && !ref) {
        return regexTemplater(/\b(?:$1)\b/g, template)
    }

    if (template == boundary) {
        return regexTemplater(/\b(?:$1)\b/g, ref)
    }

    if (isRegExp(template)) {
        return regexTemplater(template, ref)
    }
    if (template === '') template = '(?:$1)'
    if (arguments.length == 1) {
        return '(?:' + ncgRunner(template) + ')'
    }

    if (!ref && isIterable(template)) {
        return '\\b(?:' + ncgRunner(template, escape) + ')\\b'
    } else if (
        !isPrimitive(ref) &&
        ref[0] &&
        !isPrimitive(ref[0])
    ) {
        let value = oldTemplater(
            template,
            ref.map((el) => ncgRunner(el, escape))
        )
        if (escape) return RegExp(value, escape)
        return value
    } else {
        return oldTemplater(template, ncgRunner(ref, escape))
    }
}



function parseFraction(s) {
    if (isArray(s)) {
        return s
    }
    if (isString(s)) {
        return getNumbers(s)
    }
    if (arguments.length == 2) return Array.from(arguments)
}
function isEndOfSentence(s) {
    return /[.?]$/.test(s)
}



usef = "Rank the following fractions from lowest to highest: 1/4, 2/3, 4/5. Pretty cool right? What is the answer 1/4? how about: 2xp3-6x is also pretty big, but the real one is 2xp4-10e3bg p 4 - 4"
s = `
    
`
//console.log(splitKatexNoHelpingMarkers0908(usef))
//console.log(katexMixed(usef))

function katexParserToArray(s) {
    const wrapIt = wrapFactoryFactory('vv')
    return split(s, /\n\n+/).map((x) => {
        return splitSentences(x)
            .map(wrapIt(splitKatexNoHelpingMarkers0908))
    })
}

function wrapFactoryFactory(wrapperClass) {
    return function lambda1(f) {
        return f
        return function lambda2(s) {
            const value = f(s)
            return {
                class: wrapperClass,
                value,
            }
        }
    }
}

//print(katexParserToArray(usef))

//console.log(nerdEval('4 * 5%'))
//while (10) {
    //breaker()
//console.log(emArithmetic('40 * 5%', 10))
//}
/* 09-28-2022 */

//console.log(brute24([2,4,5,6])) /*  */

function brute24Connector(payload) {
    return payload.map((item, i) => {
        const elements = split(item, ' ')
        const indexes = []
        for (let i = 0; i < elements.length; i++) {
            let element = elements[i]
            if (isOperator(element)) {
                indexes.push(i)
            }
        }
        shuffle(indexes)
        for (let i of indexes.slice(0, amount)) {
            elements[i] = null
        }
        return fillInTheOperators(elements) + ' = ' + answer
    })
}
/* 09-28-2022 */


/* 09-28-2022 */

class GeometryGUI {
    /* yeah it works but it will be hard */
    constructor() {
        this.points = new Set()
        this.group = new PointGroup()
        this.storage = new Storage()
        this.shapes = []
        this.lib = {}
        this.items = []
        this.pos = new CoordinateSystem(0, 10, 0, 10)
    }
    addPoint(x, y) {
        const point = new Point(x, y)
        this.items.push(point)
        this.group.add(point)
    }
    click() {
        this.addPoint(this.pos.get())
        if (this.group.size == 3) {
            
        }
    }
}
/* 09-28-2022 */


function joinf(d = '\n') {
    return function lambda(s) {
        return s.join(d)
    }
}
function mutationIteration(board, f) {
    let count = 0
    board.forEach((row, i) => {
        row.forEach((el, j) => {
            const index = i * board.length + j
            const value = f(el, i, j, index, count++)
            if (value) {
                board[i][j] = value
            }
        })
    })
    return board
}
//new SudokuBoard(3, 0.65).run() /* size = 3, holes = 65% */

function range2d(rows, cols) {
    const grid = []
    for (var i = 0; i < rows; i++) {
        grid[i] = []
        for (var x = 0; x < cols; x++) {
            grid[i][x] = ''
        }
    }
    return grid
}

function sudokuGrid(gridSize = 4) {
    /* how does this magic work??? */
    const grid = range2d(gridSize, gridSize)
    var possibleValues = range(gridSize)
    var origVals = shuffle(possibleValues)
    var currVals = copy(origVals)

    for (var i = 1; i <= gridSize; i++) {
        for (var r = 0; r < gridSize; r++)
            grid[r][currVals[r] - 1] = i
        currVals.push(currVals.shift())
    }

    return shuffle(grid)
}

function viewSudoku(x) {
    let f
    f = (x) => x.map((y) => len(y) == 1 ? y + ' ' : y).join('|')
    return x.map(f)
}

function dreplacef2(dict, template, flags = 'g') {
    const r = RegExp(`(?:${Object.keys(dict).join('|')})`, flags)

    return function lambda(s) {
        const f = (x) => {
            return dict[x]
        }
        return s.replace(r, f)
    }
}

function vimify() {
    
    s = `
        [ shift-tab 
        ] enter-enter
        tab TextTab()
    `
    const vimConverterRef = {
        'shift-tab': '<c-d>',
        'cr': '<cr>',
        'tab': '<tab>',
        'enter-enter': '<enter><enter>',
        'enter': '<enter>',
    }

    const dreplace5 = dreplacef2(vimConverterRef, '(?:$1)')
    const value = linegetter(s).map((x) => {
      let [a,b,c] = search(/^(iab )?(\S+) (.+)/, x)
      let prefix = 'inoremap'
      let buffer = '<buffer>'
      let expr = '<expr>'
      let items = []
      if (c) {
          prefix = a.trim()
          a = b
          b = c
      }
      let callable = isCallable(b)
      items.push(prefix)
      items.push(buffer)

      let value = dreplace5(b)
      if (callable) items.push(expr)
      items.push(dreplace5(a))
      items.push(value)
      return items.join(' ')
    })

    const payload = value.join('\n')
    //write('/home/kdog3682/CWF/public/vim-commands', payload)
    return payload
}


//console.log(viewSudoku(sudokuGrid()))
//console.log(vimify())

/* 09-29-2022 */

function generateHomeworkID(initials, difficulty = 1) {
    /* uses the student name */
    const ref = {
        '1': 'e',
        'easy': 'e',
        '2': 'm',
        'medium': 'm',
        '3': 'h',
        'hard': 'h',
    }
    difficulty = ref[difficulty] || difficulty
    let letter = randomLetter(['e', 'm', 'h'])
    s = letter + rng() + initials + difficulty + rng()
    s = upperCase(s)
    return s
}
//console.log(foo('sj', 1))
//
function emShiftLeftOrRight({amount = 5, base = 1.23, direction = 1} = {}) {
    const store = map(amount, (x) => {
        let term = Math.pow(10, x)   
        console.log(term)
        return latex.multiply(base, term)
    })
    /* to do it all  */
}
//console.log(emShiftLeftOrRight())

class Tokenizer4 {
    constructor() {
        this.store = {}
        this.items = []
        this.regexes = []
        this.todo = []
    }
    add(regex, f) {
        this.todo.push({
            regex: addCaret(regex),
            parser: f,
            gFlag: regex.flags.includes('g'),
            name: f.name,
        })
    }
    run(s) {
        let store = []

        for (let i = 0; i < this.todo.length; i++) {
            let item = this.todo[i]
            let gFlag = item.gFlag
            let temp = []
            let m

            function push(s) {
                const value = item.name ? 
                {name: item.name, value: s} : {value: s}
                store.push(value)
            }

            while (true) {
                ;[s, m] = eatUntil(s, item.regex)
                if (!m) {
                    if (exists(temp)) {
                        push(temp)
                    }
                    break
                }
                let payload = item.parser(m)
                if (gFlag) {
                    temp.push(payload)
                    continue
                }
                else {
                    push(payload)
                    break
                }
            }
            
        }
        return store
    }
}
//c Lin
function secondRun(s) {
    return s
    console.log(s); throw '';
}
function parse(s) {
    let r = new Tokenizer4()
    //let r2 = new Tokenizer5()

    //r2.add()

    //let secondRun = r2.run.bind(r2)
    //secondRun = identity

    r.add(/#(.+)/, capitalizeTitle)
    r.add(/--+(.*?)\n--+/s, createConfig)
    r.add(/([^]+?)\n+---+/g, secondRun)
    return r.run(s)
}
function fx(s) {
    r = /^#\w+ \w+[^]+?\n(?=#\w+ \w)/gm
    m = findall(r, s)
    let first = m[0]
    console.log(parse(first))
}
function addCaret(regex) {
    return RegExp(
        '^' + (isString(regex) ? regex : regex.source)
    )
}
function eatUntil(s, regex) {
                s = s.trim()	
                //console.log([s.slice(0, 40)]); throw '';
                let m = s.match(regex)
                if (!m) {
                    return [s, null]
                }
                s = s.slice(m[0].length)
                //console.log([s.slice(0, 40)]); throw '';
                m = matchgetter(m)
                return [s, m]
}
function createConfig(s) {
    return s
}
var BaseLineEditPlugins = [
    {
        test: isDashedLine, 
        parser: parseHorizontalLine,
        rank: 1,
        name: 'horoline',
    },
    {
        test: (_, c) => c.newlines,
        parser: (_, {newlines}) => ({newlines}),
        rank: 2,
        name: 'countNewLines',
    },

    {
        rank: 2,
        name: 'boldColonStart',
        test: /^(example): *(.+)/i,
        parser(s, c) {
            return s
            return c.matches[0] + 'fff'
        },
    },
]
function getterf(ref) {
    if (isArray(ref)) {
        let first = ref[0]
        let t = type(first)
        let touchFn
        return function lambda(x) {
            if (type(x) == t) return x
            if (!touchFn) {
                let key
                let keys = ['key', 'name', 'file']
                for (let key of keys) {
                    if (first.hasOwnProperty(key)) {
                        touchFn = (y, z) => y[key] == z
                        break
                    }
                }
            }
            return ref.find((y) => touchFn(y, x))
        }
    }
}
class BaseLineEdit {
    export() {
        return this.run.bind(this)
    }
    constructor(options) {
        this.onStart = logf('starting')
        this.onEnd = logf('ending')
        this.plugins = []
        bindObject(this, options)

        let f = getterf(BaseLineEditPlugins)
        this.plugins = this.plugins.map(f)
        modifyObjectKeyInsideArray(this.plugins, 'test', searchf)
        console.log(this.plugins)
    }

    reset(s) {
        this.tracker = {}
        this.store = []
        this.index = 0
        this.s = s
        this.lines = this.s.trim().split(/(\n+)/)
        this.size = this.lines.length
        this.store = []
    }

    run(s) {
        this.reset(s)
        while (this.index < this.size) {
            let startingIndex = this.index
            let [spaces, lineValue, newlines] =
                getIndentAndLine(this.lines[this.index])

            this.spaces = spaces
            this.newlines = newlines - 1 && newlines

            if (this.index == 0) {
                this.onStart(lineValue)
            } else if (this.index == this.size - 1) {
                this.onEnd(lineValue)
            }

            let value
            let match
            for (let plugin of this.plugins) {
                if (match = plugin.test(lineValue, this)) {
                    console.log({match})
                    if (isArray(match)) {
                        this.matches = match
                    } else {
                        this.match = match
                    }
                    value = plugin.parser(lineValue, this)
                    break
                }
            }

            if (!value) value = this.parser(lineValue)
            assertObject(value)
            push(this.store, value)
            if (this.index == startingIndex) this.index++
        }
        return this.store
    }
}

class LineEdit0929 extends BaseLineEdit {
    constructor() {
        super()
    }
    parser(s) {
        let [value, attrs] = getAttrsFromString(s)

        if (!value && attrs) {
            Object.assign(getLast(this.store), attrs)
            return 
        }

        return {
            attrs,
            value,
        }
    }
}

//s = 'sdfg class:sdfgsdf-dfgsdfg sdfgdfg style: sdfg'
//console.log(getAttrsFromString(s))
s = '                                first used for "greater-than-smaller-than.math"\n         sdfg\n\n\n\n                   sd class:dfg'
//console.log({v}); throw ""
//rpw('/home/kdog3682/MATH/greater-than-smaller-than.math', fx)
function getAttrsFromString(s) {
    const items = split(s, /(class|style) *:/)
    let value
    if (isOdd(items.length)) {
        const [a,b] = splitonce(items)
        value  =  toDictionary(b)
        return [a, value]
    } else {
        value  = toDictionary(items)
        return [null, value]
    }
}
function assertObject(value) {
    return 
                if (value && !isObject(value)) {
                    throw new Error(stringify({
                        message: 'value must be type-object',
                        value,
                    }))
                }
}
function isDashedLine(s) {
    return /^--+/.test(s)
}

function parseHorizontalLine(s) {
    let color = 'black'
    let width = 1
    return {
        horizontalLine: {
            thickness: width, background: color
        }
    }
}


function toPixels(s, f = identity) {
    let px = /\d$/.test(s) ? 'px' : ''
    return f(s) + px
}
function hideLog(s) {
    console.log('hiding the console')
    let mylog = console.log.bind(console)
    console.view = mylog
    if (!isBrowser()) console.log = yes
    return mylog
}
function isCssWord(s) {
    return isString(s) && /^[\w-]+$/.test(s)
}
    console.view = console.log
mylog = console.log
//mylog = hideLog()
/* 09-30-2022 */


function toVueProseObject(o) {
    return {
        tag: 'p',
        attrs: {
            style: o.style,
            class: o.class,
        },
        value: o.value,
    }
}

function lorem(key, arg) {
    return loremIpsum(key, arg, true)
}
var loremIpsumRef = {
    toVueProseObject(i) {
        return {
            style: '2em',
            class: 'vue-prose-item',
            value: lorem('sentence', i)
        }
    },
    sentence(i) {
        return 'sup my nikkas' + i
    }
}
function loremIpsumRunner(key, i) {
    return fparse(loremIpsumRef[key], i)
}
function loremIpsumFunctionRunner(f, i) {
    return f(loremIpsumRunner(f.name, i))
}
function loremIpsum(x, n = 1, singleton = false) {
    function runner(x, i) {
        if (isFunction(x)) {
            return loremIpsumFunctionRunner(x, i)
        }
        return loremIpsumRunner(x, i)
    }
    if (singleton) {
        return runner(x, n)
    }
    const value = smallify(range(n).map((_, i) => runner(x, i)))
    console.log(value)
    return value
}

//var dialogueItems = loremIpsum(toVueProseObject, 5)
function enforce(x, arg) {
    const ref = {
        Arguments: {
            message: `
                [$1] requires ${arg} arguments
                but only has ${2} arguments.
            `,
            fn: (x, arg) => x.length == arg
        },

        Null: {
            message: `
                [$1] requires a valid first argument
                but the first argument is null
            `,
            fn: no
        },
    }

    let key = x ? type(x) : 'Null' 
    let {message, fn} = ref[key]
    if (fn(x, arg)) return
    throwErrorMessage(message)
}

function throwErrorMessage(template) {
    let caller = getCaller(-2)
    let message = replaceTemplate(template, caller)
    throw message
}
function useSecondArgf(f) {
    return (_, x) => f(x)
}
function replaceTemplate(s, ref) {
    let offset = s.includes('$0') ? 0 : 1
    let regex = /\$(\w+)/g

    if (isPrimitive(ref)) {
        ref = [ref]
    } 

    let transform = isArray(ref) ? 
        (x) => ref[Number(x) - offset] :
        (x) => ref[x]

    return s.replace(regex, useSecondArgf(transform))
}
//console.log(vv)

function walk2(obj, fn) {
    function walker(x, y) {
        if (isArray(y)) {
            return y.map((el) => walker(null, el))
        }

        if (isObjectLiteral(y)) {
            return Object.entries(y).reduce((acc, [k, v]) => {
                acc[k] = walker(k, v)
                return acc
            }, {})
        }

        const value = fn(x, y)
        if (isDefined(value)) return value
        return y
    }

    return walker(null, obj)
}

function joinSimple(x) {
    if (isString(x)) {
        return x
    }
    if (isObject(x)) {
        return Object.values(x).join('\n')
    }
    if (isArray(x)) {
        return x.join('\n')
    }
}
function numberToDateNumber(s) {
    s = s.toString()
    if (s.length == 3) {
        return '0' + s
    }
    return s
}

function textFileToJavascriptDataFileConverter(key) {
    let items = [
        {
            outpath: 'math-doc-string',
            fn: aggregatorFromColonsToDictionary,
        },
    ]
    let ref = items.find((x) => fuzzyMatch(key, x))
    let fn = ref.fn || throwError()
    /* need to do this part */
    fn = wrapAgain()
    return createVariable('mathDocRef', store, '')
    let name = addExtension(key, 'txt')
    let outpath = changeExtension(name, 'js')
    rpw(name, fn, outpath)
    let camelName = toCamelCase(key)
}
//console.log(aggregatorSimpleColonDictionary('hi: sdf\nbye: sfsdf'))
//console.log(emMultiplication(null, 4))
//console.log(numberArray((i, j) => [i, j]))
//console.log(emOrderedMultiplication())
/* there are different ways to place it */
/* different ways to  */

function emFoo() {
    for (let j = 1; j < 3; j++) {
        for (let i = 1; i <= 5; i++) {
            let s = j.toString().repeat(i)
            let t = map(3, s).join(' * ')
            console.log([t, eval(t)])
        }
    }
}

//clip(getFunctionNames(self()))
//console.log(getFactors(100000-1))
//console.log((100000-1)/813)
//console.log(eval('813 * 41 * 3'))
//console.log(googleUploadGrades())
function isLetter(v) {
    return isString(v) && /^[a-z]$/i.test(v)
}
    //const ref = reduce(digits, (k, v, i) => {
        //return i < 2 ? capitalize(n2char(i)) : k
    //})

//console.log(emMysteryAlphabetAddition())
        //let x = {
            //amount: 2, min: 11, max: 99,
        //}

function runAndLog(f, args) {
    if (!isArray(args)) args = [args]
    const value = f(...args)
    console.log(value)
    return value
}
function easyMathHandler(f, arg) {
    const name = f.name
    const ref = EasyMathHandlerRef[name]
    if (!ref) {
        return runAndLog(f, arg)
    }

    let value
    if (ref.args) {
        let t = type(arg)
        let argHandler = ref.args[t]
        let args = argHandler(arg)
        value = runAndLog(f, args)
    }
    if (ref.postParse) {
        let newValue = runAndLog(ref.postParse, value)
        if (newValue) value = newValue
    }
    return value
}
function partitionByFunctions(items, ...fns) {
    /* no sorting and no breakage
     * the number of bins determined by the number of fns
     * */
    let store = map(fns.length + 1, () => [])
    for (let item of items) {
        for (let i = 0; i < fns.length; i++) {
            let fn = fns[i]
            if (fn(item)) {
                store[i].push(item)
                break
            }
            
            if (i == fns.length - 1) {
                store[i + 1].push(item)
            }
        }
    }
    return store
}

//easyMathHandler(emMysteryAlphabetAddition, '456 + 12 + 54 + 874')

function emGuidedMultiplication2(s, difficulty) {

    let question = longShort(...getNumbers(s))
    const [a, b] = question
    let longest1 = a

    const bottomNumbers = split(b)
    const topSingles = bottomNumbers.map((n, i) => {
        return [a,n]
    })
    function singler(value, index, A, sign = '+', className = 'number') {
        //console.log({value})
        
        let s = splitSingles(value).map((item) => {
            return {
                value: item,
                class: className,
            }
        })
        if (index != null && index == A.length - 1) {
            s.unshift({
                class: 'operator',
                value: sign,
            })
        }
        return s
    }

    const reversedTop = reverse(copy(topSingles))
    let longest2 = 0
    const bottomAnswers = reversedTop.map(([a, b], index, A) => {
        let value = a * b
        if (value > longest2) longest2 = value
        let s = singler(value, index, A, plusSign, 'answer')

        for (let i = 0; i < index; i++) {
            s.push({
                value: 0,
                class: 'starting-zero',
            })
        }
        return s
    })

    topSingles.reverse()
    //console.log(topSingles); throw '';
    let questionArray = question.map((value, index, A) => {
        return singler(value, index, A, multiplySign)
    })
    const answerString = superCalculate(a, b, '*')
    const answerArray = [singler(answerString, null,null,null, 'answer')]
    let deltaLength = len(longest2) - len(longest1)
    const payload = {
        questionString: latex.times(a, b), answerString: answerString, deltaLength, bottomAnswers, answerArray, topSingles, questionArray}
    return payload
    //clip(payload)
}
function splitSingles(s) {
    return s.toString().trim().split('')
}


function listHtml(items, {marginTop = 20, marginBottom = 20, marginRight = 5, bulletType = 'circle'} = {}) {

    function getBullet(i, bulletType) {
        switch (bulletType) {
            case '#': return i + 1 + '.'
            case 'number': return i + 1 + '.'
            case 'circle': return circleBullet
        }
    }

    const body = items.map((item, i, a) => {
        item = String(item)
        item = removeExtension(item)
        let style = ''
        if (i == 0) {
            style = `style="margin-bottom: ${marginTop}px"`
        }

        else if (i == a.length - 1) {
            style = `style="margin-bottom: ${marginBottom}px"`
        }

        let bullet = divify('span', `style="font-weight: bold; margin-right: ${marginRight}px;"`, getBullet(i, bulletType))

        return divify('div', style, [
            bullet,
            divify('span', '', item)
        ])
    }).join('\n')
    return body
}
//console.log(listHtml([1,2,3,4], {bulletType: 'number'}))

//learning
//let A = (x) => x + 2
//let B = (x) => x + 3
//let C = (x) => x + 4
//console.log(compose(A, B, C)(3))

function strftime(date, strife) {
    return strife.replace(templaterRE, (_, x) => {
        switch (x) {
            case 'day':
                return ordinal(date.getDate())
            case 'dayNumber':
                return date.getDate()
            case 'month':
                return MONTHS[date.getMonth()]
            case 'monthNumber':
                return date.getMonth() + 1
            case 'shortYear':
                return String(date.getFullYear()).slice(2)
            case 'year':
                return date.getFullYear()
            case 'weekday':
                return DAYS[date.getDay()]
        }
    })
}
function formatDatestamp(date, type = 'long') {
    let strifeRef = {
        long: '$weekday, $month $day, $year',
    }
    return strftime(date, strife)
    let options = {
        weekday: 'long', 
        month: 'long', 
        day: 'numeric', 
        year: 'numeric'
    }
    languageRef = {
        'spanish': 'es-ES',
        'english': 'en-US',
    }
    let lang = 'english'
    let language = languageRef[lang]
    return date.toLocaleString(language, options)
}
//console.log(formatDatestamp('saturday'))
//

function evalFromObject(key, obj) {
    /* must be a way to improve this */
    let parts = split(key, '.')
    let [a,b,c,d] = parts
    switch (parts.length) {
        case 1:
            return obj[a]
        case 2:
            switch (b) {
                case 'length': return obj[a].length
                case 'toString': return obj[a].toString()
                default: return obj[a][b]
            }
        case 3:
            switch (c) {
                case 'length': return obj[a][b].length
                case 'toString': return obj[a][b].toString()
                default: return obj[a][b][c]
            }
    }
}
function transformObject(obj, f, ...args) {
    let parameters = getParameters(f)
    let hasK = parameters.includes('k')
    let hasV = parameters.includes('v') || parameters.includes('s')
    let g
    let mode = 'values'
    if (hasK && hasV) {
        g = f
    } else if (hasV) {
        g = (k, v) => f(v, ...args)
    } else if (hasK) {
        mode = 'keys'
    } else {
        throw 'nope'
    }

    const store = {}
    for (let [k, v] of Object.entries(obj)) {
        const value = g(k, v)
        if (value == null) continue
        if (mode == 'keys') {
            store[value] = v 
        }
        else if (mode == 'values') {
            store[k] = value
        }
    }
    return store
}
//console.log(evalFromObject('abc.ged.length', {abc: {ged: [{bb: 'hi'}]}}))

function superCalculate(a, b, mode = '*') {
    function runner(a, b) {
        switch (mode) {
            case '+': return a + b
            case '-': return a - b
            case '/': return a / b
            default: return a * b
        }
    }
    let answer = runner(a, b)
    if (answer > Number.MAX_SAFE_INTEGER) {
        return runner(BigInt(a), BigInt(b)).toString()
    }
    return answer
}

//console.log(easyMathHandler(emMysteryAlphabetAddition, '456 + 12 + 54'))
//easyMathHandler(emMysteryAlphabetAddition, '456 - 123', {mysteryLetterCount: 2})
//easyMathHandler(emMysteryAlphabetAddition, '25 - 123', {mysteryLetterCount: 2})

var GRE = {
    configString: /^\s*--+(.*?)\n--+\n/s,
}
var REGEX_REF = {
    expr: '\\d+(?: *[-+*/] *\\d+)+',
    num: '\\d+',
}
var EASY_MATH_RAW_STRING = `
-----------------
emMysteryAlphabetAddition:
$expr $num

emGuessForX:
$expr $num

-----------------
emMysteryAlphabetAddition:
25 + 13 1
25 + 13 2
123 + 13 2
123 + 133 2
123 + 133 + 45 3
22 - 13 2

`
class Tokenizer6 {
    /* 
     * 10-10-2022 
     * EASY_MATH_RAW_STRING
     * emMysteryAlphabetAddition
     * export to jsonLikeObject
     * some magical
     * */
    static toObject(payload, key) {
        const ref = {
            emMysteryAlphabetAddition: ['expression', 'mysteryLetterCount'],
            emGuessForX: ['template', 'mysteryLetterCount'],
        }
        return zip(ref[key], payload)
    }
    constructor() {
        mixinManager(this, 'mreplace', 'eatStart')
        this.store = {}
    }
    run(s) {
        const store = this.parse(s)
        for (let [k, v] of Object.entries(store)) {
            let f = bringToLife(k)
            testsuite2(f, v)
        }
    }
    parse(s) {
        const output = {}
        this.init(s)
        for (let i = 0; i < this.regexItems.length; i++) {
            let store = []
            let [name, regex, parser] = this.regexItems[i]
            let regexName = addCaret(`(${name.replace(/\W*$/, '')})[:]?`)
            name = this.eatStart(regexName)
            if (!name) continue
            while (true) {
                let match = this.eatStart(regex)
                if (!match) break
                if (parser) {
                    match = parser(match)
                }
                store.push(Tokenizer6.toObject(match, name))
            }
            output[name] = store
        }
        return output
    }
    init(s) {
        this.s = s
        let configString = this.mreplace(GRE.configString)
        this.regexItems = chunker(configString, (chunk) => {
            let [a,b] = linegetter(chunk)
            let dollars = findall(templaterRE, b)
            let parsers = dollars.map((item, i) => {
                if (item == 'num') return (x) => Number(x)
                return identity
            })
            let parser = dollars.length > 1 ?
                (x) => x.map((y, i) => parsers[i](y)) :
                parsers[0]

            return [a, createRE(b), parser]
        })
    }
}

const GlobalStringMixins = {

    eatStart(regex) {
        const match = this.s.match(regex)
        if (match) {
            this.s = this.s.slice(match[0].length).trim()
            const value = matchgetter(match)
            return value
        }
        return null
    },

    toString() {
        return this.s
    },

    mreplace(regex, mode) {
        let [a, b] = mget(regex, this.s)
        b = parseMatch(b, mode)
        this.s = a
        return b

        function parseMatch(b, mode) {
            if (mode == Object) {
                if (isNestedArray(b)) {
                    b = toDictionary(b)
                } else if (isArray(b)) {
                    b = b.reduce((acc, item, i) => {
                        acc[item] = true
                        return acc
                    }, {})
                } else {
                    b = {}
                }
            }
            return b
        }
    },
    trim() {
        this.s = this.s.trim()
        return this.s
    },
    findall(r) {
        const regex = addGFlag(r)
        const matches = findall(regex, this.s)
        return mapToNumber(matches)
    },
}
function mixinManager(state, ...objects) {
    let ref = GlobalStringMixins
    objects.map(runner)

    function runner(obj) {
        if (obj == 'default') {
            obj = {
                toString: true,
            }
        }

        if (isString(obj)) {
            state[obj] = ref[obj].bind(state)
            return
        }

        for (let [k, v] of Object.entries(obj)) {
            if (isObject(v)) {
                let get = v.get && v.get.bind(state)
                let set = v.set && v.set.bind(state)
                Object.defineProperty(state, k, { get, set })
            } else if (v === true) {
                state[k] = ref[k].bind(state)
            } else {
                state[k] = ref[v].bind(state)
            }
        }
    }
}

function createRE(s) {
    let caret = '^'
    let value = caret +  s.trim().split(templaterRE)
        .filter(hasValue).map(runner).join('')

    return RegExp(value)

    function runner(x) {
        if (x == ' ') return ' +'
        let part = REGEX_REF[x]
        if (!part) return x
        return parens(part)
    }
}
function chunker(configString, f = identity, mode = Array) {
        const p = split(configString, /\n\n+/).map(f)
        return mode == Object ? toDictionary(p) : p
}

function emCarrySubtraction(o = {}, numbergen = null) {
    let terms = o.terms || 2
    let digitCount = o.numDigits || 2
    //if (!numbergen) numbergen = new Numbergen()
    //let a = numbergen.generateNumber(digitCount)
    let topStore = []
    let bottomStore = []
    let count = digitCount - 1
    function boop() {
                let n = rng(0,7)
                topStore.push(n)
                bottomStore.push(rng(n + 1, 9))
    }
    function goop(s) {
                let n = rng(3,9)
                topStore.push(n)
                bottomStore.push(rng(1, n - 1))
    }

    if (o.mode == 'alternating') {
        for (let i = 0; i <= count; i++) {
            if (isEven(i)) {
                goop()
            }
            else {
                boop()
            }
        }
    }
    else if (o.mode == 'random') {
        goop()
        for (let i = 0; i < count; i++) {
            coinflip() ? boop() : goop()
        }
    }

    else {
        goop()
        for (let i = 0; i < count; i++) {
            boop()
        }
    }

    //let topStore = []
    //let bottomStore = []
    //console.log(topStore)
    //console.log(bottomStore)
    let a = topStore.join('')
    let b = bottomStore.join('')
    let expression = a + ' - ' + b
    return numberGroup([topStore, bottomStore], expression)
}
function numberGroup(groups, expr) {
    return {
        groups,
        length: len(eval(expr)),
        expr,
    }
}
//(new Tokenizer6()).run(EASY_MATH_RAW_STRING)
//console.log(emCarrySubtraction({numDigits: 4, mode: 'al'}))
///* increase the font size */
//console.log(emGuidedMultiplication2('2345*678'))


function isMathy(s) {
    if (isVeryWordy(s)) {
        return 
    }
    return /[=*+-\/\\]|^\d+(?:\.\d+)?$/.test(s)
}

function isVeryWordy(s) {
    return /(?:[a-zA-Z\']+ ){3,}/.test(s)
}
//console.log(isMathy('1234')); throw '';
//console.log(splitSentences('hi. bye. b go.'))
function kate(s) {
    let name = 'kate.js'
    write(name, s)
    ofile(name)
}
//kate(katexVertical([2345, 678]))

/* 
 * she copies off of me too.
 * makeup-quiz.
 * to treat the children without respect.
 * which will teach them that aspect too.
 * falling into mistakes.
 * */
function cloneObject(obj) {
    var clone = {};
    for(var i in obj) {
        if(typeof(obj[i])=="object" && obj[i] != null)
            clone[i] = cloneObject(obj[i]);
        else
            clone[i] = obj[i];
    }
    return clone;
}

function cloneFromBase(base, possibles, key = 'arg') {
    return possibles.map((item, i) => {
        let copy = cloneObject(base)
        copy[key] = item
        return copy
    })
}
    //console.log(cloneFromBase({arg: 3, foo: 1}, [2,3,4]))
//console.log(emGuidedMultiplication2('2345 * 234'))
//
//

function rotateMatrix(grid) {
    var newGrid = []
    var rowLength = Math.sqrt(grid.length)
    newGrid.length = grid.length

    for (var i = 0; i < grid.length; i++) {
        var x = i % rowLength
        var y = Math.floor(i / rowLength)
        var newX = rowLength - y - 1
        var newY = x
        var newPosition = newY * rowLength + newX
        newGrid[newPosition] = grid[i]
    }
    return newGrid
}
//module.exports.rotateMatrix = rotateMatrix
//module.exports.test = test
//console.log(magicSquare(4))


function numberBoundary(i, limit) {
    //return i % limit
    return Math.round(i / limit) + 1
}

//nerdamer = require("nerdamer/all.min")
function isPositiveAnswer(s) {
    return !isNegativeAnswer(s)
}

function isNegativeAnswer(s) {
    return /^-|-\w+ *$/.test(s.toString())
}
function emGuessForXArger(i) {
    let answer = i
    let template = randomLinear({
        slope: numberBoundary(i, 4),
        yint: rng(),
    })
    return [{template}, answer]
}
function emWrapper(o) {
    const store = [] 
    const checkpoint = numberf(o.checkpoint || {positive: true})
    const breaker = new simpleBreaker()
    const fn = emFunction(o.key)
    for (let i = 1; i <= o.amount; i++) {
        breaker()
        let args = o.argf(i)
        let val = fn(...args)
        if (val == null) {
            i--
            continue
        }
        if (!checkpoint(val.question || val)) {
            i--
            continue
        }
        store.push(val)
    }
    //pprint(store)
    console.log('emwraper success', store.length)
    return store
}

    //runClockUntil((count) => {
        //console.log(count)
        //if (count === 3) return true
    //}, 1000)

class Clock1010 {
    constructor(options) {
        this.onStart = logf('starting')
        this.onEnd = logf('ending')
        this.onTick = options.onTick || console.log
        this.duration = options.duration || 6000
        this.interval = options.interval || 1000
        this.speed = options.speed || 1
        this.delta = this.interval / this.speed
    }
    pause() {
        this._pause = true
    }
    async start() {
        if (this._pause) {
            this._pause = false
            this.count += 1
        } else {
            this.count = 0
            this._stop = false
        }
        return await this.runner()
    }

    stop() {
        this._stop = true
        clearTimeout(this.timerID)
        this.onEnd()
    }
    async resume() {
        this._stop = false
        await this.runner()
    }

    runner() {
        this._onStart()
        this._onTick()

        return new Promise((resolve, reject) => {
            const runner = () => {
                if (this.isDone()) {
                    clearTimeout(this.timerID)
                    this._onEnd()
                    resolve()
                } else if (this._pause) {
                    clearTimeout(this.timerID)
                    resolve()
                } else {
                    this.count += 1
                    this.timerID = setTimeout(() => {
                        this._onTick()
                        runner()
                    }, this.delta)
                }
            }

            runner()
        })
    }

    at(n, fn) {
        let current = this._onTick
        this._onTick = () => {
            this.count == n ? this.handle(fn(this)) : current()
        }
    }

    set onTick(fn) {
        //this._onTick = () => this.handle(fn(this.timeLeft))
        this._onTick = () => this.handle(fn(this.count, this.timeLeft, this.duration))
    }
    set onStart(fn) {
        this._onStart = () => fn(this.timeLeft)
    }

    set onEnd(fn) {
        this._onEnd = () => fn(this.timeLeft)
    }

    isDone() {
        return this.count >= this._duration || this._stop
    }
    get timeLeft() {
        return this._duration - this.count
    }
    get _duration() {
        return Math.floor(this.duration / 1000)
    }

    handle(result) {
        if (result === true) {
            this._stop = true
        } else if (isNumber(result)) {
            this.duration += result * 1000
        }
    }
}

async function runClockUntil(onTick, options = {}) {
    const clock = new Clock1010({onTick, ...options})
    return await clock.start()
}

//runClockUntil((count, timeLeft, duration) => {
    //console.log({count, timeLeft, duration})
    //if (count > 3) return true
        //console.log(count)
//})

function cssModifyNumber(s, dir = 1) {
    let unit = search(/r?em|px|%|v[wh]|in/, s)
    if (!unit) unit = ''
        const ref = {
            'rem': 0.2,
            px: 1,
            vw: 5,
            vh: 5,
            in: 1,
            em: 0.1,
        }
    function f(n) {
        let delta = ref[unit] * dir
        return n + delta
    }
    return modifyNumber(s, f)
}
//console.log(cssModifyNumber('2rem', -1))
//console.log(isMathy('x = ?'))
s = `
asdfasdf
// asdfasdf
//  sadfsdf
  // asdfasdfasdf
  // //sdfasdf
  // df
  //
  sdfsdfsdfsdf


  sdfsdf //sdf
  f
`
//console.log(removeComments(s))

function smfj(s, r, f, j = ' ') {
    const filter = (x) => {
        return x != '' && hasValue(x)
    }
    return s.trim().split(r).filter(hasValue).map(f).join(j)
}
function smartCapitalize(s) {
    const allCaps = ['shsat', 'sat', 'gre', 'mcat', 'tofl']
    const noCaps = ['to', 'from', 'how', 'and', 'by', 'the']

    function f(s, i) {
        s = String(s)
        if (isDefined(i) && i == 0) return capitalize(s)
        if (allCaps.includes(s)) return s.toUpperCase()
        if (noCaps.includes(s)) return s
        return capitalize(s)
    }
    return smfj(s, ' ', f)
}

function randomAmount(a, n) {
  const shuffled = [...a].sort(() => 0.5 - Math.random())
  return shuffled.slice(0, n)
}
var LoremIpsumLibrary = {
            sentences: [
                'Hi how are you?',
                'Hii how are you?',
                'Hiii how are you?',
                'Hiiii how are you?',
                'Hiiiii how are you?',
                'Hiiiiii how are you?',
                'Hiiiiiii how are you?',
                'Hiiiiiiii how are you?',
            ]

}

class LoremIpsum {
    constructor(store) {
        this.store = store || LoremIpsumLibrary
        let keys = Object.keys(this.store)
        for (let k of keys) {
            let ref = this.store[k]
            this[k] = curryStart(ref, randomAmount)
            this[backspace(k)] = curryStart(ref, randomPick)
        }
    }
}
function reduceObjectToString(x, f, delimiter = '\n') {
    let g = ([a,b]) => f(a,b)
    return Object.entries(x).map(g).join(delimiter)
}
//console.log(getLongest([{a:1}, {a:2}], (x) => x.a, null))

class Tokenizer1011 {
    /* 
     * // 10-11-2022 
     * dialogue
     * dialogueParser
     * (new Tokenizer1011).run(normRead('story.math'))
     * use breaker ... to stop it early
     * removeBreaker
     * */
    constructor() {
        this.lineIndex = 0
        this.chunkIndex = 0
        this.speakers = []
        this.status = 'finding-speakers'
        this.nameRE = reWrap(sorted(unique(flat(Object.entries(g4studentNames)).map(lowerCase))), 'gbri')
    }
    set status(s) {
        console.log(s)
        this._status = s
        if (s == 'no more speakers') {
            this.speakers = map(this.speakers, (x) => {
                return g4studentNames[x] || x
            })
        }
    }
    get status() {
        return this._status
    }
    findSpeaker(s) {
        if (this.status == 'finding-speakers') {
            let name = search(this.nameRE, s)
            if (name) {
                this.speakers.push(name)
                this.status = 'found-a-speaker'
            }
        }
        else if (this.status == 'found-a-speaker') {
            let name = search(this.nameRE, s)
            if (name) {
                this.speakers.push(name)
            } else {
                this.status = 'no more speakers'
            }
        }
        else if (this.status  ==  'no more speakers') {
            console.log('no mo speakers yo')
        }
    }
    run(s) {
        let speakers = []
        let status
        let self = this
        self.categorizer = new RegexCategorizer()

        self.lineEditor = new BaseLineEdit({
            parser: dialogueLineParser,
            onStart(firstLine) {
                self.chunkIndex++
                self.findSpeaker(firstLine)
            },
            onEnd(lastLine) {
                console.log('last line done!', lastLine)
            }
        })

        let dialogueChunkParser = self.lineEditor.export()

        function dialogueLineParser(line, i, a) {
            self.lineIndex++
            if (!line) return {type: 'newline'}
            if (isProse1010(line)) {
                //bot.push(line)
                return {
                    type: 'prose',
                    value: periodify1010(line),
                }
            }
            let value = self.categorizer.fix(line)
            return {
                type: 'math',
                value
            }
            return value
        }
        function dialogueParser(s) {
            return split(s, linebreakRE).map(dialogueChunkParser)
        }
        function practiceProblemParser(s) {
            if (!s) return 'no-practice-problems-yet'
            return s
        }
        let titleParser = smartCapitalize
        let storyParser = (s) => {
            let [a,b] = split(s, /^pp/m)
            a = a.replace(self.nameRE, (x) => {
                return g4studentNames[x] || x
            })
            a = Spellcheck.spellcheck(a)
            //console.log(a); throw '';
            a = flattenSentences(a)
            return [
                dialogueParser(a),
                practiceProblemParser(b),
            ]
        }
        s = removeBreaker(s)
        const items = partition(split(s, /^title (\w+)/mi))
            .map(atBoth(titleParser, storyParser))
        return items

    }
}
function removeBreaker(s) {
    return s.replace(/\bbreaker\b.+/s, '')
}

s = `
/* thr r tims wn u wnt 2 go out and play1 */
`



s = `
4t25=100
5t20=100
10t10=100
I think the factors of 100 are 1,100,2,50,4,25,5,20,10,10.
`
class RegexCategorizer {
    // 10-11-2022 
    constructor() {
        const questionWords = [
    'istaw',
    'would',
    'are',
    'can',
    'for',
    'will',
    'which',
    'whose',
    'shud',
    'who',
    'what',
    'where',
    'when',
    'why',
    'how',
    'should',
    'could',
    'do',
    'is',
    'have',
    'has',
    'does',
    'are',
    'might',
    'would',
    'can',
    'for',
    'will',
    'which',
    'whose',
    'shud',
    'who',
    'what',
    'where',
    'when',
    'why',
    'how',
    'should',
    'could',
    'do',
    'is',
    'have',
    'has',
    'does',
    'are',
    'might',
    ]
        const proseRef = {
            safe: '$endingPunc$',
            isQuestion: '^($word($spc$word)* $comma)? $questionWord',
        }
        const tokenRef = {
            spc: / /,
            comma: /,/,
            word: /\b[AURIauri]\b|[a-zA-Z]{2,}(?:\'[a-zA-Z])?/,
            word: /[a-zA-Z\']{2,}|[auriAURI]/,
            questionWord: questionWords,
            endingPunc: /[?.!]/,
            var: /\d*[abcxyz]+\d*|\d+/,
            mult: /[t*]/,
            eq: /eq|=/,
            add: /[p+]/,
            op: /[p+t*-e\/]/,
            minus: /-/,
            at: /@/,
            any: /.+/,
            quote: /["']/,
            punc: /[.?,]/,
            mathArray: /\d(?: *, *\d+){2,}/,
        }
        const intermediate = {
            expr: '($var $op)+ $var ($eq $var)?',
            //forwardMixed: '($expr|$mathArray)$spc$word',
            //backwardMixed: '$word$spc($mathArray|expr)',

            forwardMixed: '$word$spc$expr',
            backwardMixed: '$expr$spc$word',
        }
        for (let [k, v] of Object.entries(intermediate)) {
            intermediate[k] = replaceTransform(v, intermediate)
        }
        const ref = {
            //mixed: '($forwardMixed|$backwardMixed)',
            prose: '^$quote? $word$spc$punc? $word',
            math: '^$expr',
            at: '^$at $any',
        }
        function replaceTransform(s, additionalRef) {
            let regex1 = s.replace(/( +)|\$(\w+)([?*]?|\$(?!\w))/g, (_, spaces, key, mark) => {
                if (spaces) return ' *'
                if (key) {
                    let ref = tokenRef[key]
                    if (!ref && additionalRef) {
                        ref = additionalRef[key]
                        if (!ref) {
                            console.log(key); throw '';
                        }
                    }
                    if (isArray(ref)) {
                        return reWrap(ref)
                    }
                        let regex = ref.source
                        if (mark) {
                            return ncg1010(regex) + mark
                        }
                        if (regex.includes('|')) {
                            regex = ncg1010(regex)
                        }
                        return regex
                }
            })

            //if (!regex1.startsWith('^') && !regex1.endsWith('$')) {
                //regex1 = '^' + regex1 + '$'
            //}
            return RegExp(regex1)
        }
        this.ref = Object.entries(transformObject(ref, replaceTransform, intermediate))
        //console.log(this.ref[0][1]); throw '';
        this.proseRef = Object.entries(transformObject(proseRef, replaceTransform))
        this.transformers = {
            'add': fixMath,
            'minus': fixMath,
            'mult': fixMath,
            'expr': fixMath,
            'math': fixMath,
        }
    }
    run(s) {
        for (let [type, regex] of this.ref) {
            if (regex.test(s)) {
                let f = this.transformers[type]
                let value = f ? f(s) : s
                return {type, value}
            }
        }
        return {value: s, type: null}
    }
    getTypes(s, ref) {
        const store = []
        for (let [type, regex] of (ref || this.ref)) {
            if (regex.test(s)) {
                store.push(type)
            }
        }
        return store
    }

    getType(s, ref) {
        for (let [type, regex] of (ref || this.ref)) {
            if (regex.test(s)) {
                return type
            }
        }
    }
    error(s) {
        console.log(this.ref)
        console.log('errr', s)
        throw s
    }
    fix(s) {
        let type = this.getType(s)
        let runner = (s) => {
            if (!type) {
                this.error(s)
            }
            if (this[type]) {
                return this[type](s)
            }
            if (this.transformers[type]) {
                return this.transformers[type](s)
            }
        }
        let value = runner(s)
        return value

        return {
            type,
            value,
        }
    }
    prose(s) {
        let value = this._prose(s)
        value = splitKatexNoHelpingMarkers0908(value)
        return value
    }
    _prose(s) {
        let types = this.getTypes(s, this.proseRef)
        s = capitalize(s)
        if (types.includes('safe')) {
            return s
        }

        if (types.includes('isQuestion')) {
            return s + '?'
        }
        return s + '.'
    }
}
function ncg1010(s) {
    return `(?:${s})`
}

//console.log((new RegexCategorizer).fix('23p5p5 = 6x2'))
//console.log(splitKatexNoHelpingMarkers0908('thr anser might be 1,2,3, 4, 5 , 6'))
//console.log((new RegexCategorizer).fix('do u fwf want'))


const isWordProblem = yesNoFactory({
    no: /pr2h|special right|^\...|^questions|^if you finish|^do not|cmyk|adggg|unauthorize|^for questions|^\d+\.|^the number of deg|^according|graph|table|above/i,
    yes(s) {
        if (s.length < 30) return
        if (hasNewline(s)) {
            return 1
        }
    },
})

function fixExponents(s) {
    
    return s.replace(
        /e(-?(?:[a-zA-Z]|[\d\/]+[a-z]*)|\[.*?\])/g,
        (_, x) => {
            if (x.startsWith('['))
                return '^' + wrap(x.slice(1, -1), '{}')
            return '^' + wrap(x, '{}')
        }
    )

}
function fixOperators(s) {
    s = s.replace(/[tp]/g, (x) => {
        switch (x) {
            case 't': return '*'
            case 'p': return '+'
        }
    })
    return s
    //s = s.replace(/\*/g, '\\cdot')
    //return s
}
function fixSquareRoots(s) {
    
    return s.replace(/(\w+)rt(\w+)/g, (_, a, b) => {
        return `\\sqrt[${a}]{${b}}`
    })

    /* dangerous... */
}


//console.log(splitKatexNoHelpingMarkers0908('a factor is aomthin'))

function flattenSentences(s) {
    return s.replace(/(?<!(?:mrs?|miss|dr))[.?!] (?=\w)/g, (x) => {
        return x.trim() + '\n'
    })
}
function periodify1010(s) {
        s = capitalize(s)
        if (/[.?!]$/.test(s)) return s

        if (questionRE.test(s)) {
            return s + '?'
        }
        return s + '.'
}

let questionRE = RegExp("^(\\w+(?: \\w+)*, *)" + reWrap(questionWords))
function isProse1010(s) {
    return !/[0-9xyz]+ *[tp\-\+\*\/] *[xyz0-9]+/i.test(s)

}
//console.log(bot)
//console.log(stringify((new Tokenizer1011).run(normRead('story.math'))))
//
//

refstring1011 = `

------------------
GuessForX
------------------
Choose a number for x to make the statement true.

Example: x + x = 4
Be careful!
You cannot choose x = 1 and x = 3.
x and x are the same thing.
They have to be the same number.
The answer for this example is x = 2.
------------------

------------------
------------------
------------------
`
function splitLinebreak(s, b, a = identity) {
    return partition(split(s, linebreakRE)).map(atBoth(a,b))
}

function parseRefString1011(s) {
    let f = (new BaseLineEdit({
        parser(s) {
            return s
            console.log('gg')
        },
        plugins: [
            'horoline',
            'countNewLines',
            'boldColonStart',
        ]
    })).export()
    return splitLinebreak(s, f)[0][1]
}

class TestSuite {
    static test(key) {
        const suite = new TestSuite()
        return suite.run(key)
    }
    constructor(key) {
    }

    run(key) {
        let f = bringToLife(key)
        let arg = eval((key.name || key).toLowerCase().replace(/parse/, ''))
        console.log(f(arg))
    }
}
function modifyObjectKeyInsideArray(a, key, f) {
    for (let i = 0; i < a.length; i++) {
        let item = a[i]
        if (item.hasOwnProperty(key)) {
            let value = f(item[key])
            if (value) {
                item[key] = value
            }
        }
    }
}
//TestSuite.test(parseRefString1011)

function parlayLast(a) {
    if (getLast(a).length == 1) {
        let last = a.pop()[0]
        getLast(a).push(last)
    }
    return a
}
function swapForbiddenGroups(arr, forbidden) {
    return arr
    /* pairing high-low doesnt always work */
    /* perhaps then the algo needs to account for more variables ... not just the raw scores or abilities */
}
function hack(array, p1, p2){
  var p1Index = array.indexOf(p1);
  var p2Index = array.indexOf(p2);

  if(p1Index % 2 === 0){
    var temp = array[p1Index+1]
    array[p1Index+1] = array[p2Index]
  } else {
    var temp = array[p1Index-1]
    array[p1Index-1] = array[p2Index]
  }

  array[p2Index] = temp
  return array
}


//console.log(hack([1,2,3,4], [1,3]))
//console.log(parlayLast(partition(shuffle(unique(Object.values(g4studentNames))))))
function datestamp(date, delimiter = '/') {
    if (isZDate(date)) {
        date = new Date(date)
    }
    if (isNumber(date) && len(date) === 10) {
        date *= 1000
    }
    const [month, day, year] = getMDY(date)
    let _month = month.toString().padStart(2, 0)
    let _day = day.toString().padStart(2, 0)
    let _year = year
    return `${_month}${delimiter}${_day}${delimiter}${year}`
}


s = `
@table.noborder(Teachers for $topic, $student)
Teachers for Guess for X
Teachers for Big Subtraction
Teachers for Big Multiplication
Teachers for Magic 15
Teachers for Mystery Multiplication Table
Teachers for Number Patterns
Teachers for What number could x be?
`

function slice(a, n) {
    return a.slice(0, n)
}
//console.log(slice(['a', 'b', 'c', 'd', 'e'], 3))


class Classroom {
    constructor() {
        this.students = normRead('students.json')
    }
    getStudentNames(key = 'name') {
        return map(this.students, key)
    }
}

function spreadsheetDataValuesToArray(data) {
    const [headers, rest] = splitonce(data)

    return rest.map((row, i) => {
        return row.reduce((acc, item, j) => {
            acc[headers[j]] = item
            return acc
        }, {})
    })
}
//console.log(spreadsheetDataValuesToArray(clip()))

var jspath = pathf('js')
function pathf(e) {
    return function lambda(s, ext) {
        const p = normDirPath(addExtension(s, ext || ee), e)
        consoleThrow(p)
        return p
    }
}
function normDirPath(file, override) {
    let jsdir = '/home/kdog3682/CWF/public/'
    let sandir = '/mnt/chromeos/removable/Sandisk/'
    let pydir = '/home/kdog3682/CWF/'
    let pdfdir = '/home/kdog3682/PDFS/'
    let logdir = '/home/kdog3682/LOGS/'
    let txtdir = '/home/kdog3682/TEXTS/'
    let mathdir = '/home/kdog3682/MATH/'
    let jsondir = '/home/kdog3682/JSONS/'
    let picdir = '/home/kdog3682/PICS/'

    let dirdict = {
        js: jsdir,
        py: pydir,
        pdf: pdfdir,
        txt: txtdir,
        json: jsondir,
        math: mathdir,
        jpg: picdir,
        jpeg: picdir,
        png: picdir,
        svg: picdir,
        log: logdir,
    }
    let key = override || getExtension(file)
    return dirdict[key] + tail(file)
}

class StudentGroup {
    constructor() {
        const students = sorted(unique(flat(Object.values(g4studentNames))))
        this.students = students
    }
    get size() {
        return this.students.length
    }
    get names() {
        return map(this.students, getFirstWord)
    }
}
function mySmartStudents() {
    const group = new StudentGroup()
    return map(group.names, '$1 is smart.')
}

//console.log(mySmartStudents())

function isFactory(key) {
    return function lambdaIsFileType(f) {
        if (getExtension(f) == key) {
            return true
        }
    }
}
//var isCss = isFactory('css')
